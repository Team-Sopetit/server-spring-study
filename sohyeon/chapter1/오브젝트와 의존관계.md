# 1장 오브젝트와 의존관계
```
스프링이 자바에서 가장 중요하게 가치를 두는 것은 객체지향 프로그래밍이 가능한 언어라는 점이다.
그래서 스프링이 가장 관심을 많이 두는 대상은 오브젝트다.
스프링을 이해하려면 먼저 오브젝트에 깊은 관심을 가져야 한다.
애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고, 소멸하기까지의 전 과정을 진지하게 생각해볼 필요가 있다.
```
## 1.1 초난감 DAO
**`DAO`** : DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.
### 1.1.1 User

```java
package springbook.user.domain;

public class User {
	String id;
	String name;
	String password;

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}
}
```
🔼 사용자 정보 저장용 자바빈 User 클래스

### 1.1.2 UserDao

- 사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스 생성
- 사용자 정보를 관리하므로 UserDao로 클래스 명명
- 메소드: 새로운 사용자 생성(add), 아이디를 가지고 사용자 정보 조회(get)

```java
package springbook.user.dao;
...
public class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
	
		PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values (?, ?, ?)");
		ps.setString(1, user.getId());
		ps.setString(2, user.getName());
		ps.setString(3, user.getPassword());

		ps.executeUpdate();

		ps.close();
		c.close();
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
	
		PreparedStatement ps = c.prepareStatement("select * from users id = ?");
		ps.setString(1, id);

		ResultSet rs = ps.excuteQuery();
		rs.next();

		User user = new User();
		user.setId(rs.getString("id"));
		user.setName(rs.getString("name"));
		user.setPassword(rs.getString("password"));

		rs.close();
		ps.close();
		c.close();

		return user;
	}
}
```

🔼 JDBC를 이용한 등록과 조회 기능이 있는 UserDao 클래스

### 1.1.3 main()을 이용한 DAO 테스트 코드
- main 메소드를 만들고 그 안에서 UserDao의 오브젝트를 생성해서 add()와 get() 메소드 검증

```java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
	UserDao dao = new UserDao();

	User user = new User();
	user.setId("sohyeonkim");
	user.setName("김소현");
	user.setPassword("server");

	dao.add(user);

	System.out.println(user.getId() + " 등록 성공");
	
	User user2 = dao.get(user.getId());

	System.out.println(user2.getName());
	System.out.println(user2.getPassword());

	System.out.println(user2.getId() + " 조회 성공");
}
```

🔼 테스트용 main() 메소드

<br/>

## 1.2 DAO의 분리
```
사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.
애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다.
그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.
"분리와 확장"을 고려한 설계를 통해 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있다.
```

### 1.2.1 관심사의 분리
- 모든 변경과 발전은 한 번에 **한 가지 관심사항**에 집중에서 일어난다.
- 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만, 그에 따른 작업은 한 곳에 집중되지 않을 경우 문제가 발생한다. 따라서 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 해야 한다.
- 프로그래밍의 기초 개념 중 **관심사의 분리**를 객체지향에 적용할 수 있다.
- 관심이 같은 것끼리는 “하나의 객체 안”으로 또는 “친한 객체”로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리한다.
- 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 **같은 관심에 효과적으로 집중할 수 있게** 만들어준다.

### 1.2.2 커넥션 만들기의 추출
> ***UserDao의 관심사항***
- UserDao의 add() 메소드 하나에서만 적어도 3가지 관심사항을 발견할 수 있다.
    - DB와 연결을 위한 커넥션을 어떻게 가져올까라는 관심
    - 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
    - 작업이 끝나면 사용한 Statement와 Connection 오브젝트를 닫아서 공유 리소스를 시스템에 돌려주는 것
- 가장 문제가 되는 것은 첫째 관심사인 “DB 연결을 위한 Connection 오브젝트를 가져오는 것”이다.
- 다른 관심사와 섞여 같은 메소드에 담겨 있고, 동일한 코드가 get() 메소드에도 중복되어 있다.
- 이러한 문제는 변경이 일어날 때 하나하나 수정해주어야 하는 엄청난 고통을 일으키는 원인이 된다.

> ***중복 코드의 메소드 추출***
- 가장 먼저 커넥션을 가져오는 중복된 코드를 분리한다.
- 중복된 DB 연결 코드를 getConnection()이라는 이름의 독립적인 메소드로 만든다.
```java
public void add(User user) throws ClassNotFoundException, SQLException {
	Connection c = getConnection();
	...
}

public User get(String id) throws ClassNotFoundException, SQLException {
	Connection c = getConnection();
	...
}

private Connection getConnection() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
		return c;
}
```
🔼 getConnection() 메소드를 추출해서 중복을 제거한 UserDao
- DB 연결과 관련된 부분에 변경이 일어났을 경우, 한 메소드의 코드만 수정하면 된다.
- 관심의 종류에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다. 관심 내용이 독립적으로 존재하므로 수정도 간단해졌다.

> ***변경사항에 대한 검증: 리팩토링과 테스트***
- main() 메소드를 여러 번 실행하면 두 번째부터는 무조건 예외가 발생한다. (id 값 중복)
- 따라서 테스트 진행 전 User 테이블의 사용자 정보를 모두 삭제해줘야 한다.
- 위의 변화는 기능에 아무런 변화를 주지 않았고, 여전히 사용자 정보를 등록하고 조회하는 조금 난감한 DAO 클래스가 되었다.
- 하지만 여러 메소드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메소드로 분리해냈다.
- 이러한 작업을 **메소드 추출(extract method) 기법**이라고 부른다.

### 1.2.3 DB 커넥션 만들기의 독립
```
UserDao는 발전에 발전을 거듭해서 초슈퍼울트라캡짱 사용자 관리 DAO가 되었다.
업계에 널리 알려지면서 N사와 D사에서 사용자 관리를 위해 UserDao를 구매하겠다는 주문이 들어왔다.
하지만 문제는 N사와 D사가 각기 다른 종류의 DB를 사용하고 있고, DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법을 적용하고 싶어한다는 점이다.
심지어 UserDao를 구매한 이후에도 DB 커넥션을 가져오는 방법이 종종 변경될 가능성이 있다고 한다.
고객에게 직접 소스코드를 공개하지 않으면서, 고객 스스로 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용할 수 있도록 해보자.
```

> ***상속을 통한 확장***
- UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만든다.
- 추상 메소드라서 메소드 코드는 없지만 메소드 자체는 존재한다.
- UserDao를 구매한 포털사들은 UserDao 클래스를 상속하여 각각 NUserDao와 DUserDao라는 서브클래스를 만든다. 서브클래스는 UserDao에서 추상 메소드로 선언했던 getConnection() 메소드를 원하는 방식대로 구현할 수 있다.

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/159a1658-b8a9-4e30-8721-9bba9ad4d1c3)

```java
public abstract class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();
		...
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();
		...
	}

	public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {
	public Connection getConnection() throws ClassNotFoundException, SQLException {
		// N사 DB connection 생성코드
	}
}

public class DUserDao extends UserDao {
	public Connection getConnection() throws ClassNotFoundException, SQLExceptioin {
		// D사 DB Connection 생성코드
	}
}
```

🔼 상속을 통한 확장 방법이 제공되는 UserDao

- 어떻게 데이터를 등록하고 가져올 것인가라는 관심을 담당하는 UserDao와, DB 연결 방법은 어떻게 할 것인가라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분되고 있다.
- 새로운 DB 연결을 적용해야 할 때는 UserDao 상속을 통해 확장해주기만 하면 된다.
- 이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메소드 패턴**이라고 한다.
- 이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴**이라고 부르기도 한다.
- UserDao는 Connection 인터페이스 타입의 오브젝트라는 것 외에는 관심을 두지 않는다. 그저 Connection 인터페이스에 정의된 메소드를 사용할 뿐이다.
- UserDao는 어떤 기능을 사용하는 데에만 관심이 있고, NUserDao나 DUserDao에서는 어떤 식으로 Connection 기능을 제공하는지에 관심을 두고 있다.
- 하지만 상속을 이용한 방법에는 단점이 있다.
  - 만약 이미 UserDao가 다른 목적을 위해 상속을 사용하고 있다면? (자바는 다중상속을 허용하지 않음)
  - 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다. (슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있음)
  - 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다. (UserDao 외의 DAO 클래스들이 계속 만들어진다면 상속을 통해서 만들어진 getConnection()의 구현 코드가 매 DAO 클래스마다 중복되는 문제가 발생)
 
<br/>

## 1.3 DAO의 확장
```
추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는,
바로 이렇게 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서다.
그러나 여러가지 단점이 많은, 상속이라는 방법을 사용했다는 사실이 불편하게 느껴진다.
```

### 1.3.1 클래스의 분리
- SimpleConnectionMaker라는 새로운 클래스를 만들고 DB 생성 기능을 그 안에 넣는다.
- UserDao는 new 키워드를 사용해 SimpleConnectionMaker 클래스의 오브젝트를 만들어두고, 이를 add(), get() 메소드에서 사용한다.

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/8ac17b57-3d62-47e2-b063-bf71534e8a07)

```java
public class UserDao {
	private SimpleConnectionMaker simpleConnectionMaker;

	public UserDao() {
		simpleConnectionMaker = new SimpleConnectionMaker();
	}

	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = simpleConnectionMaker.makeNewConnection();
		...
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = simpleConnectionMaker.makeNewConnection();
		...
}
```
🔼 독립된 SimpleConnectionMaker를 사용하게 만든 UserDao

```java
package springbook.user.dao;
...
public class SimpleConnectionMaker {
	public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
		return c;
	}
}
```
🔼 독립시킨 DB 연결 기능인 SimpleConnectionMaker

- 여전히 문제가 발생한다. N사와 D사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능을 확장해서 사용하게 했던 게 불가능해졌다.
- SimpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문에 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다.
- 해결해야 할 2가지 문제가 있다.
  - SimpleConnectionMaker의 메소드가 문제다. (포털사에서 커넥션 제공 클래스와 메소드를 변경한다면 일일히 변경해주어야 함)
  - DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다.
- 즉, UserDao가 SimpleConnectionMaker 클래스에 종속적이기 때문에 이후 DB 커넥션을 가져오는 방법을 확장하기 어려워졌다.

### 1.3.2 인터페이스의 도입
- 2개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어 해결할 수 있다.
- 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이다.
- 자바가 추상화를 위해 제공하는 가장 유용한 도구는 인터페이스이다.
- 결국 오브젝트를 만들려면 구체적인 클래스 하나를 선택해야겠지만 인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들 때 사용할 클래스가 무엇인지 몰라도 된다.

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/26d9cabf-8249-4837-b28e-479d0d99fe92)

```java
package springbook.user.dao;
...
public interface ConnectionMaker {
	public Connection makeConnection() throws ClassNotFoundException, SQLException;
}
```
🔼 ConnectionMaker 인터페이스

```java
package springbook.user.dao;
...
public class DConnectionMaker implements ConnectionMaker {
	...
	public Connection makeConnection() throws ClassNoFoundException, SQLException {
		// D사의 독자적인 방법으로 Connection을 생성하는 코드
	}
}
```
🔼 ConnectionMaker 구현 클래스

```java
public class UserDao {
	private ConnectionMaker connectionMaker;

	public UserDao() {
		connectionMaker = new DConnectionMaker();
	}

	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = connectionMaker.makeConnection();
		...
	}

	public User get(String id) throws ClassNotFoundException, SQLExcption {
		Connection c = connectionMaker.makeConnection();
		...
	}
}
```
🔼 ConnectionMaker 인터페이스를 사용하도록 개선한 UserDao

- 하지만 DConnection 클래스의 생성자를 호출해서 오브젝트를 생성하는 코드가 여전히 UserDao에 남아있다.
- DB 커넥션을 제공하는 클래스에 대한 구체적인 정보는 모두 제거가 가능했지만, 초기에 한 번 어떤 크래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아있다.
- 여전히 고객에게 자유로운 DB 커넥션 확장 기능을 가진 UserDao를 제공할 수 없다.

### 1.3.3 관계설정 책임의 분리
- 여전히 UserDao에는 어떤 ConnectioinMaker 구현 클래스를 사용할지를 결정하는 코드가 남아있다.
- `new DConnectionMaker()`라는 코드는 그 자체로 충분히 독립적인 관심사를 담고 있다.
- UserDao의 클라이언트 오브젝트가 바로 제 3의 관심사항인 UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을 분리해서 두기에 적절한 곳이다.
- UserDao의 모든 코드는 ConnectionMaker 인터페이스 외에는 어떤 클래스와도 관계를 가져서는 안 되게 해야 한다.

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/05155419-b32d-49c5-ad17-2f76182f3fc6)

- 클래스 사이의 관계가 만들어진 것은 아니고, 단지 오브젝트 사이에 다이내믹한 관계가 만들어지는 것이다.
- 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다.
- 객체지향 프로그램에서는 다형성이라는 특징이 있는 덕분이다.
- UserDao 오브젝트가 DConnectionMaker 오브젝트를 사용하게 하려면 두 클래스의 오브젝트 사이에 의존관계라고 불리는 관계를 맺어주면 된다.
- 코드에는 보이지 않던 관계는 오브젝트로 만들어진 후에 생성된다.
- 이러한 런타임 오브젝트 관계를 갖는 구조로 만들어주는 게 바로 클라이언트의 책임이다.
  - 현재는 UserDao 클래스의 main() 메소드가 UserDao 클라이언트라고 볼 수 있다.
  - 좀 더 깔끔하게 구분하기 위해 UserDaoTest라는 클래스를 만들어서 main() 메소드를 옮긴다.
  - 클라이언트와 같은 제 3의 오브젝트가 UserDao 오브젝트가 사용할 ConnectionMaker 오브젝트를 전달해주도록 만든다.
  - DConnectionMaker를 생성하는 코드를 UserDao의 클라이언트에게 넘겨버린다.

```java
public UserDao(ConnectionMaker connectionMaker) {
	this.connectionMaker = connectionMaker;
}
```
🔼 수정한 생성자

```java
public class UserDaoTest {
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		ConnectionMaker connectionMaker = new DConnectionMaker();

		UserDao dao = new UserDao(connectionMaker);
		...
	}
}
```
🔼 관계설정 책임이 추가된 UserDao 클라이언트인 main() 메소드

```java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
	ConnectionMaker connectionMaker = new NConnectionMaker();
	...
}
```
🔼 클라이언트 역할의 UserDaoTest

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/d10dabd3-d77c-451a-b642-3e0102a49554)

### 1.3.4 원칙과 패턴
> ***개발 폐쇄 원칙***
- 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
- UserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려 있다.
- 동시에 UserDao 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀 있다고 말할 수 있다.

> ***높은 응집도와 낮은 결합도***
- **높은 응집도**
  - 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. (변화가 일어날 때 해당 모듈에서 변하는 부분이 큼)
  - ConnectionMaker 인터페이스를 이용해 DB 연결 기능을 독립시킨 경우에서, 그저 DB 커넥션 풀을 활용하는 ConnectionMaker 구현 클래스를 새로 만들기만 하면 된다.
  - DB 연결 방식에 변경이 일어난 경우에 이를 검증하기 위해, 변경한 ConnectionMaker 구현 클래스를 직접 테스트해보는 것만으로 충분하다.
- **낮은 결합도**
  - 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다.
  - 결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다. 확장하기에도 매우 편리하다.
  - ConnectionMaker 인터페이스의 도입으로 인해 DB 연결 기능을 구현한 클래스가 바뀌더라도, DAO 클래스의 코드를 수정할 필요가 없게 됐다. ConnectionMaker와 UserDao의 결합도가 낮아진 것이다.

> ***전략 패턴***
- 개선한 UserDaoTest-UserDao-ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다.
- 전략 패턴은 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴이다.
- UserDao는 전략 패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 알고리즘(DB 연결 방식)을 ConnectionMaker라는 인터페이스로 정의하고, 전략(구현 클래스)을 바꿔가며 사용할 수 있게 분리했다.

<br/>

## 1.4 제어의 역전(IoC)
### 1.4.1 오브젝트 팩토리
- UserDaoTest는 기존 UserDao가 담당하던 기능(어떤 ConnectionMaker의 구현 클래스를 사용할지를 결정)을 엉겁결에 떠맡았다.
- 원래 UserDaoTest는 기능 테스트를 위하 만들어진 것인데, 다른 책임까지 떠맡고 있으니 문제가 있다. 분리해야 한다.
- 분리되는 기능은 UserDao와 ConnectionMaker 구현 클래스의 오브젝트를 만드는 것과, 그렇게 만들어진 2개의 오브젝트가 연결돼서 사용될 수 있도록 관계를 맺어주는 것이다.

> ***팩토리***
- 새로 추가할 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것이다. 이러한 오브젝트를 주로 **팩토리**라고 부른다.
- 단지 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용되는 것이다.
- 팩토리 역할을 맡을 클래스를 DaoFactory라고 하겠다.
- UserDaoTest에 담겨있던 UserDao, ConnectionMaker 관련 생성 작업을 DaoFactory로 옮긴다.
- UserDaoTest에는 미리 만들어진 UserDao 오브젝트를 가져와 사용하게 한다.

```java
package springbook.user.dao;
...
public class DaoFactory {
	public UserDao userDao() {
		ConnectionMaker connectionMaker = new DConnectionMaker();
		UserDao userDao = new UserDao(connectionMaker);
		return userDao;
	}
}
```
🔼 UserDao의 생성 책임을 맡은 팩토리 클래스

```java
public class UserDaoTest {
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		UserDao dao = new DaoFactory().userDao();
		...
	}
}
```
🔼 팩토리를 사용하도록 수정한 UserDaoTest

>***설계도로서의 팩토리***
- UserDao와 ConnectionMaker는 각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있고, DaoFactory는 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있다.
- 전자가 실질적인 로직을 담당하는 컴포넌트라면, 후자는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할을 한다고 볼 수 있다.
- 설계도란 간단히 어떤 오브젝트가 어떤 오브젝트를 사용하는지를 정의해놓은 코드라고 생각하면 된다.

### 1.4.2 오브젝트 팩토리의 활용
- DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능을 넣으면 어떻게 될까?
- accountDao(), messageDao() 등 새로운 메소드를 만든다면 새로운 문제가 발생한다.
- ConnectionMaker 구현 클래스의 오브젝트를 생성하는 코드가 메소드마다 반복된다.
- 중복되는 현상은 DAO가 더 많아지면 ConnectionMaker의 구현 클래스를 바꿀 때마다 모든 메소드를 수정해야 하기 때문에 좋지 않다.
- 그러므로 분리한다.

```java
public class DaoFactory {
	public UserDao userDao() {
		return new UserDao(new DConnectionMaker());
	}

	public AccountDao accountDao() {
		return new AccountDao(new DConnectionMaker());
	}

	public MessageDao messageDao() {
		return new MessageDao(new DConnectionMaker());
	}
}
```
🔼 DAO 생성 메소드의 추가로 인해 발생하는 중복

```java
public class DaoFactory {
	public UserDao userDao() {
		return new UserDao(connectionMaker());
	}

	public AccountDao accountDao() {
		return new AccountDao(connectionMaker());
	}

	public MessageDao messageDao() {
		return new MessageDao(connectionMaker());
	}

	public ConnectionMaker connectionMaker() {
		return new DConnectionMaker();
	}
}
```
🔼 생성 오브젝트 코드 수정

### 1.4.3 제어권의 이전을 통한 제어관계 역전
- 제어의 역전은 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.
- 일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고, 결정한 오브젝트를 생성하고, 만들어진 오브젝트에 있는 메소드를 호출하고, 그 오브젝트 메소드 안에서 다음에 사용할 것을 결정하고 호출하는 작업이 반복된다.
- 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다. 모든 작업을 사용하는 쪽에서 제어한다.
- **제어의 역전**은 이러한 제어 흐름을 거꾸로 뒤집은 것이다.
- 오브젝트는 자신이 사용할 오브젝트를 스스로 선택하지도, 생성하지도 않는다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다.
- UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다.
- 원래 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게 있었지만, 리팩토링 작업을 통해 DaoFactory에게 넘어왔다.
- 따라서 UserDao는 수동적인 존재가 되었다. UserDaoTest는 DaoFactory가 만들고 초기화해서 자신에게 사용하도록 공급해주는 ConnectionMaker를 사용할 수밖에 없다.
- 또한, UserDao와 ConnectionMaker의 구현체를 생성하는 책임도 DaoFactory가 맡고 있다. 이것이 제어의 역전이다.
- IoC를 적용함으로써 설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아지기 때문에 필요할 때면 IoC 스타일의 설계와 코드를 만들어 사용하면 된다.
- 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.
- DaoFactory는 오브젝트 수준의 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크라고 불릴 수 있다.

<br/>

## 1.5 스프링의 IoC
```
스프링은 애플리케이션 개발의 다양한 영역과 기술에 관여한다. 그리고 매우 많은 기능을 제공한다.
스프링의 핵심을 담당하는 건, 바로 "빈 팩토리" 또는 "애플리케이션 컨텍스트"라고 불리는 것이다.
위 두 가지는 앞서 만든 DaoFactory가 하는 일을 좀 더 일반화한 것이라고 설명할 수 있다.
```

### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
> ***애플리케이션 컨텍스트와 설정정보***

이제 DaoFactory를 스프링에서 사용 가능하도록 변신시켜보자.
- **빈(bean)** : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
- **스프링 빈** : 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트
- **빈 팩토리(bean factory)** : 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트 (IoC의 기본 기능에 초점)
- **애플리케이션 컨텍스트(application context)** : IoC 방식을 따라 만들어진 일종의 빈 팩토리 (전반적인 구성요소의 제어 작업을 담당하는 IoC 엔진)

<br/>

> ***DaoFactory를 사용하는 애플리케이션 컨텍스트***

DaoFactory를 스프링의 빈 팩토리가 사용할 수 있는 본격적인 설정정보로 만들어보자.
- 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 **@Configuration** 애노테이션 추가
- 오브젝트를 만들어주는 메소드에서는 **@Bean** 애노테이션 추가
- 자바 코드의 탈을 쓰고 있지만, 사실은 XML과 같은 스프링 전용 설정정보로 볼 수 있다.

```java
import org.springframework.context.anntation.Bean;
import org.springframework.context.annotation.Configuration;
...
@Configuration // 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
public class DaoFactory {
  @Bean // 오브젝트 생성을 담당하는 IoC용 메소드라는 표시
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  @Bean
  public ConnectionMaker connectionMaker() {
    return new DConnectionMaker();
  }
}
```

<br/>

이제 DaoFactory를 설정정보로 사용하는 애플리케이션 컨텍스트를 만들어보자.
- ApplicationContext 타입의 오브젝트
- DaoFactory처럼 @Configuration이 붙은 자바 코드를 설정정보로 사용하려면 AnnotationConfigApplicationContext 이용
- 애플리케이션 컨텍스트를 만들 때 생성자 파라미터로 DaoFactory 클래스 추가
- ApplicationContext의 getBean() 메소드를 통해 UserDao의 오브젝트를 가져올 수 있음

```java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = context.getBean("userDao", UserDao.class); // userDao가 등록된 빈의 이름(메소드명)
    ...
}
```
스프링을 적용하긴 했지만 앞에서 만든 DaoFactory를 직접 사용한 것과 기능적으로 다를 바 없다. 오히려 DaoFactory를 만들어서 바로 사용한 것보다 좀 더 번거로운 준비 작업과 코드가 필요하다.
하지만 스프링은 지금 우리가 구현했던 DaoFactory를 통해서는 얻을 수 없는 방대한 기능과 활용 방법을 제공해준다.

<br/>

### 1.5.2 애플리케이션 컨텍스트의 동작 방식
- 오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트
- 스프링에서는 이 애플리케이션 컨텍스트를 IoC 컨테이너라고도, 스프링 컨테이너라고도, 빈 팩토리라고도 부름
- 애플리케이션 컨텍스트는 ApplicatioinContext 인터페이스를 구현
- ApplicationContext는 BeanFactory 인터페이스(빈 팩토리가 구현)를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈 팩토리
- 애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정 담당
  - 직접 오브젝트를 생성하고 관계를 맺어주는 코드 X
  - DaoFactory가 UserDao를 비롯한 DAO 오브젝트를 생성하고 DB 생성 오브젝트와 관계를 맺어주는 제한적인 역할을 수행
  - @Configuration이 붙은 DaoFactory는 이 애플리케이션 컨텍스트가 활용하는 IoC 설정 정보
- 애플리케이션 컨텍스트가 동작하는 방식
  ![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/5485bf25-e4c8-4b06-bc42-39635823b9a5)
  - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
  - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
  - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
 
<br/>

### 1.5.3 스프링의 IoC의 용어 정리
> ***빈(bean)***

- 스프링이 IoC 방식으로 관리하는 오브젝트
- 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 점을 주의
- 그 중에서도 스프링이 직접 생성과 제어를 담당하는 오브젝트만이 빈

<br/>

> ***빈 팩토리(bean factory)***

- 스프링의 IoC를 담당하는 핵심 컨테이너
- 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능 담당
- BeanFactory라고 붙여쓰면 빈 팩토리가 구현하고 있는 가장 기본적인 인터페이스의 이름
- 이 인터페이스에 getBean()과 같은 메소드가 정의되어 있음

<br/>

> ***애플리케이션 컨텍스트(application context)***

- 빈 팩토리를 확장한 IoC 컨테이너
- 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일, 스프링이 제공하는 각종 부가 서비스를 추가로 제공
- 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기 하는 것
- ApplicationContext라고 적으면 애플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스를 가리키는 것이기도 함
- BeanFactory를 상속

<br/>

> ***설정정보/설정 메타정보(configuration metadata)***

- 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
- IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용
- 애플리케이션의 전체 그림이 그려진 청사진이라고도 함

<br/>

> ***컨테이너(container) 또는 IoC 컨테이너***

- IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리
- 컨테이너라는 말 자체가 IoC의 개념을 담고 있음
- 컨테이너라는 말은 애플리케이션 컨텍스트보다 추상적인 표현
- 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용됨

<br/>

> ***스프링 프레임워크***

- IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용되는 용어

<br/>

