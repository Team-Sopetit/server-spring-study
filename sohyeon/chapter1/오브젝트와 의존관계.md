# 1장 오브젝트와 의존관계
```
스프링이 자바에서 가장 중요하게 가치를 두는 것은 객체지향 프로그래밍이 가능한 언어라는 점이다.
그래서 스프링이 가장 관심을 많이 두는 대상은 오브젝트다.
스프링을 이해하려면 먼저 오브젝트에 깊은 관심을 가져야 한다.
애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고, 소멸하기까지의 전 과정을 진지하게 생각해볼 필요가 있다.
```
## 1.1 초난감 DAO
**`DAO`** : DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.
### 1.1.1 User

```java
package springbook.user.domain;

public class User {
	String id;
	String name;
	String password;

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}
}
```
🔼 사용자 정보 저장용 자바빈 User 클래스

### 1.1.2 UserDao

- 사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스 생성
- 사용자 정보를 관리하므로 UserDao로 클래스 명명
- 메소드: 새로운 사용자 생성(add), 아이디를 가지고 사용자 정보 조회(get)

```java
package springbook.user.dao;
...
public class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
	
		PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values (?, ?, ?)");
		ps.setString(1, user.getId());
		ps.setString(2, user.getName());
		ps.setString(3, user.getPassword());

		ps.executeUpdate();

		ps.close();
		c.close();
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
	
		PreparedStatement ps = c.prepareStatement("select * from users id = ?");
		ps.setString(1, id);

		ResultSet rs = ps.excuteQuery();
		rs.next();

		User user = new User();
		user.setId(rs.getString("id"));
		user.setName(rs.getString("name"));
		user.setPassword(rs.getString("password"));

		rs.close();
		ps.close();
		c.close();

		return user;
	}
}
```

🔼 JDBC를 이용한 등록과 조회 기능이 있는 UserDao 클래스

### 1.1.3 main()을 이용한 DAO 테스트 코드
- main 메소드를 만들고 그 안에서 UserDao의 오브젝트를 생성해서 add()와 get() 메소드 검증

```java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
	UserDao dao = new UserDao();

	User user = new User();
	user.setId("sohyeonkim");
	user.setName("김소현");
	user.setPassword("server");

	dao.add(user);

	System.out.println(user.getId() + " 등록 성공");
	
	User user2 = dao.get(user.getId());

	System.out.println(user2.getName());
	System.out.println(user2.getPassword());

	System.out.println(user2.getId() + " 조회 성공");
}
```

🔼 테스트용 main() 메소드

<br/>

## 1.2 DAO의 분리
```
사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.
애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다.
그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.
"분리와 확장"을 고려한 설계를 통해 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있다.
```

### 1.2.1 관심사의 분리
- 모든 변경과 발전은 한 번에 **한 가지 관심사항**에 집중에서 일어난다.
- 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만, 그에 따른 작업은 한 곳에 집중되지 않을 경우 문제가 발생한다. 따라서 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 해야 한다.
- 프로그래밍의 기초 개념 중 **관심사의 분리**를 객체지향에 적용할 수 있다.
- 관심이 같은 것끼리는 “하나의 객체 안”으로 또는 “친한 객체”로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리한다.
- 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 **같은 관심에 효과적으로 집중할 수 있게** 만들어준다.

### 1.2.2 커넥션 만들기의 추출
> ***UserDao의 관심사항***
- UserDao의 add() 메소드 하나에서만 적어도 3가지 관심사항을 발견할 수 있다.
    - DB와 연결을 위한 커넥션을 어떻게 가져올까라는 관심
    - 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것
    - 작업이 끝나면 사용한 Statement와 Connection 오브젝트를 닫아서 공유 리소스를 시스템에 돌려주는 것
- 가장 문제가 되는 것은 첫째 관심사인 “DB 연결을 위한 Connection 오브젝트를 가져오는 것”이다.
- 다른 관심사와 섞여 같은 메소드에 담겨 있고, 동일한 코드가 get() 메소드에도 중복되어 있다.
- 이러한 문제는 변경이 일어날 때 하나하나 수정해주어야 하는 엄청난 고통을 일으키는 원인이 된다.

> ***중복 코드의 메소드 추출***
- 가장 먼저 커넥션을 가져오는 중복된 코드를 분리한다.
- 중복된 DB 연결 코드를 getConnection()이라는 이름의 독립적인 메소드로 만든다.
```java
public void add(User user) throws ClassNotFoundException, SQLException {
	Connection c = getConnection();
	...
}

public User get(String id) throws ClassNotFoundException, SQLException {
	Connection c = getConnection();
	...
}

private Connection getConnection() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
		return c;
}
```
🔼 getConnection() 메소드를 추출해서 중복을 제거한 UserDao
- DB 연결과 관련된 부분에 변경이 일어났을 경우, 한 메소드의 코드만 수정하면 된다.
- 관심의 종류에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다. 관심 내용이 독립적으로 존재하므로 수정도 간단해졌다.

> ***변경사항에 대한 검증: 리팩토링과 테스트***
- main() 메소드를 여러 번 실행하면 두 번째부터는 무조건 예외가 발생한다. (id 값 중복)
- 따라서 테스트 진행 전 User 테이블의 사용자 정보를 모두 삭제해줘야 한다.
- 위의 변화는 기능에 아무런 변화를 주지 않았고, 여전히 사용자 정보를 등록하고 조회하는 조금 난감한 DAO 클래스가 되었다.
- 하지만 여러 메소드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메소드로 분리해냈다.
- 이러한 작업을 **메소드 추출(extract method) 기법**이라고 부른다.

### 1.2.3 DB 커넥션 만들기의 독립
```
UserDao는 발전에 발전을 거듭해서 초슈퍼울트라캡짱 사용자 관리 DAO가 되었다.
업계에 널리 알려지면서 N사와 D사에서 사용자 관리를 위해 UserDao를 구매하겠다는 주문이 들어왔다.
하지만 문제는 N사와 D사가 각기 다른 종류의 DB를 사용하고 있고, DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법을 적용하고 싶어한다는 점이다.
심지어 UserDao를 구매한 이후에도 DB 커넥션을 가져오는 방법이 종종 변경될 가능성이 있다고 한다.
고객에게 직접 소스코드를 공개하지 않으면서, 고객 스스로 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용할 수 있도록 해보자.
```

> ***상속을 통한 확장***
- UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만든다.
- 추상 메소드라서 메소드 코드는 없지만 메소드 자체는 존재한다.
- UserDao를 구매한 포털사들은 UserDao 클래스를 상속하여 각각 NUserDao와 DUserDao라는 서브클래스를 만든다. 서브클래스는 UserDao에서 추상 메소드로 선언했던 getConnection() 메소드를 원하는 방식대로 구현할 수 있다.

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/159a1658-b8a9-4e30-8721-9bba9ad4d1c3)

```java
public abstract class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();
		...
	}

	public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();
		...
	}

	public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {
	public Connection getConnection() throws ClassNotFoundException, SQLException {
		// N사 DB connection 생성코드
	}
}

public class DUserDao extends UserDao {
	public Connection getConnection() throws ClassNotFoundException, SQLExceptioin {
		// D사 DB Connection 생성코드
	}
}
```

🔼 상속을 통한 확장 방법이 제공되는 UserDao

- 어떻게 데이터를 등록하고 가져올 것인가라는 관심을 담당하는 UserDao와, DB 연결 방법은 어떻게 할 것인가라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분되고 있다.
- 새로운 DB 연결을 적용해야 할 때는 UserDao 상속을 통해 확장해주기만 하면 된다.
- 이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메소드 패턴**이라고 한다.
- 이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴**이라고 부르기도 한다.
- UserDao는 Connection 인터페이스 타입의 오브젝트라는 것 외에는 관심을 두지 않는다. 그저 Connection 인터페이스에 정의된 메소드를 사용할 뿐이다.
- UserDao는 어떤 기능을 사용하는 데에만 관심이 있고, NUserDao나 DUserDao에서는 어떤 식으로 Connection 기능을 제공하는지에 관심을 두고 있다.
- 하지만 상속을 이용한 방법에는 단점이 있다.
  - 만약 이미 UserDao가 다른 목적을 위해 상속을 사용하고 있다면? (자바는 다중상속을 허용하지 않음)
  - 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다. (슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있음)
  - 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다. (UserDao 외의 DAO 클래스들이 계속 만들어진다면 상속을 통해서 만들어진 getConnection()의 구현 코드가 매 DAO 클래스마다 중복되는 문제가 발생)
 
<br/>

## 1.3 DAO의 확장
