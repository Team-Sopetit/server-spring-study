## 2.4 스프링 테스트 적용
```
@Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트도 3번 만들어진다.
빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다.
테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이다.
하지만 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다.
이때도 테스트는 일관성 있는 실행 결과를 보장해야 하고, 테스트의 실행 순서가 결과에 영향을 미치지 않아야 한다.
```

### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리
스프링은 **JUnit**을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. <br/>
간단한 **애노테이션 설정**만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

<br/>

> ***스프링 테스트 컨텍스트 프레임워크 적용***

```java
@RunWith(SpringJUnit4ClassRunner.class) // 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능 지정
@ContextConfiguration(locations="/applicationContext.xml") // 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
public class UserDaoTest {

  @Autowired
  private ApplicationContext context; // 테스트 오브젝트가 만들어지고 나면 스프링 테스트 컨텍스트에 의해 자동으로 값이 주입된다.
  ...

  @Before
  public void setUp() {
    this.dao = this.context.getBean("userDao", UserDao.class);
    ...
  }
```
🔼 스프링 테스트 컨텍스트를 적용한 UserDaoTest

- JUnit 확장기능에 의해 context 변수에 애플리케이션 컨텍스트가 들어가있다. (NullPointerException 발생 X)
- **@RunWith** : JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션
- **SpringJUnit4ClassRunner** : 확장 클래스, JUnit이 테스트 진행 중 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업 진행
- **@ContextConfiguration** : 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치 지정

<br/>

> ***테스트 메소드의 컨텍스트 공유***

```java
@Before
public void setUp() {
  System.out.println(this.context);
  System.out.println(this);
}
```
🔼 확인용 코드 추가

- 실행 결과는 다음과 같다.
```
org.springframework.context.support.GenericApplicationContext@d3d6f;
springbook.dao.UserDaoTest@115d06c
org.springframework.context.support.GenericApplicationContext@d3d6f;
springbook.dao.UserDaoTest@116318b
org.springframework.context.support.GenericApplicationContext@d3d6f;
springbook.dao.UserDaoTest@15e0c2b
 ```
- context는 모두 동일하고, UserDaoTest의 오브젝트는 매번 주소 값이 다르다.
- 스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어둔다.
- 테스트 오브젝트가 만들어질 때마다 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해준다.
- 테스트 수행 속도는 매우 빨라진다.
- 결과적으로 하나의 테스트 클래스 내의 테스트 메소드는 같은 애플리케이션 컨텍스트를 공유해서 사용할 수 있다.

<br/>

> ***테스트 클래스의 컨텍스트 공유***

- 여러 개의 테스트 클래스가 모두 같은 **설정파일**의 애플리케이션 컨텍스트를 사용한다면, **클래스 사이에서 컨텍스트를 공유**하도록 해준다.
- 수백 개의 테스트 클래스가 모두 같은 설정파일을 사용한다면, 하나의 애플리케이션 컨텍스트를 사용하기 때문에 테스트 성능이 대폭 향상된다.
- 스프링은 **설정파일의 종류만큼** 애플리케이션 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트 내에서 공유할 수 있도록 한다.

<br/>

> ***@Autowired***

- @Autowired가 붙은 인스턴스 변수가 있으면, **변수 타입과 일치**하는 컨텍스트 내의 빈을 찾는다.
- 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.
- 메소드 없이 주입 가능하고, 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있는데, 이를 **자동와이어링**이라고 한다.

<br/>

```java
...
public class UserDaoTest {

  @Autowired
  UserDao dao; // UserDao 타입 빈을 직접 DI 받는다.
```
🔼 UserDao를 직접 DI 받도록 만든 테스트

- 테스트 코드가 전보다 더욱 깔끔해졌다.
- @Autowired를 지정하기만 하면 어떤 빈이든 다 가져올 수 있다.
- 단, 같은 타입의 빈이 2개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.
- 타입으로 결정할 수 없는 경우, **변수의 이름과 같은 이름의 빈**이 있는지 확인하고 결정한다.
- 변수 이름으로도 찾을 수 없으면 예외가 발생한다.
- 클래스 타입(SimpleDriverDataSource)은 물론이고, 인터페이스 타입(DataSource)으로 변수를 선언해도 된다.
  - **정의된 메소드**를 테스트에 사용하고 싶으면 **인터페이스**, **오브젝트 자체에 관심**이 있는 경우 **클래스** 타입으로 선언하는 것이 좋다.
  - 꼭 필요하지 않다면 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다.
 
<br/>

### 2.4.2 DI와 테스트
