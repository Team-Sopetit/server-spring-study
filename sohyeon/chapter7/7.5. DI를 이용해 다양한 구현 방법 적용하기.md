# 7.5 DI를 이용해 다양한 구현 방법 적용하기
- DI와 인터페이스를 활용하여 여러 가지 구현을 만들어 적용해본다.

<br/>

## 7.5.1 ConcurrentHashMap을 이용한 수정 가능 SQL 레지스트리
- 동기화된 해시 데이터 조작에 최적화되도록 만들어졌다.
- 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고 조회는 락을 아예 사용하지 않는다.
- 👍 어느 정도 안전하면서 성능이 보장된다.

<br/>

### 수정 가능 SQL 레지스트리 테스트

```java
public class ConcurrentHashMapSqlRegistryTest {
	UpdatableSqlRegistry sqlRegistry;
	
	@BeforeEach
	public void setUp() {
		sqlRegistry = new ConcurrentHashMapSqlRegistry();
		sqlRegistry.registerSql("KEY1", "SQL1");
		sqlRegistry.registerSql("KEY2", "SQL2");
		sqlRegistry.registerSql("KEY3", "SQL3");
	}
	
	@Test
	public void find() {
		checkFindResult("SQL1", "SQL2", "SQL3");
	}
	
	// 반복적으로 검증하는 부분은 별도의 메서드로 분리해두면 테스트 코드가 깔끔해진다.
	private void checkFindResult(String expected1, String expected2, String expected3) {
		assertThat(sqlRegistry.findSql("KEY1"), is(expected1));
		assertThat(sqlRegistry.findSql("KEY2"), is(expected2));
		assertThat(sqlRegistry.findSql("KEY3"), is(expected3));
	}
	
	// 주어진 키에 해당하는 SQL을 찾을 수 없을 때 예외가 발생하는지 확인한다.
	// 예외상황에 대한 테스트는 빼먹기가 쉽기 때문에 항상 의식적으로 넣으려고 노력해야 한다.
	@Test(expected = SqlNotFoundException.class)
	public void unknownKey() {
		sqlRegistry.findSql("SQL9999!!@#$");
	}
	
	// 하나의 SQL을 변경하는 기능에 대한 테스트
	// 검증할 때는 변경된 SQL 외의 나머지 SQL은 그대로인지도 확인해주는 게 좋다.
	@Test
	public void updateSingle() {
		sqlRegistry.updateSql("KEY2", "Modified2");
		checkFindResult("SQL1", "Modified2", "SQL3");
	}
	
	@Test
	public void updateMulti() { // 한 번에 여러 개의 SQL을 수정하는 기능을 검증한다.
		Map<String, String> sqlmap = new HashMap<>();
		sqlmap.put("KEY1", "Modified1");
		sqlmap.put("KEY3", "Modified3");
		
		sqlRegistry.updateSql(sqlmap);
		checkFindResult("Modified1", "SQL2", "Modified3");
	}
	
	@Test(expected = SqlUpdatableFailureException.class) // 존재하지 않는 키의 SQL을 변경하려고 시도할 때 예외가 발생하는 것을 검증
	public void updateWithNotExistingKey() {
		sqlRegistry.updateSql("SQL9999!@#$", "Modified2");
	}
}
```
🔼 ConcurrentHashMap을 이용한 SQL 레지스트리 테스트
- 테스트를 철저하게 만들어서 기능을 검증하고 구현 방식이 변경될 때마다 테스트를 실행해서 기능에 영향을 주는지 확인하는 일이 매우 중요하다.

<br/>

### 수정 가능 SQL 레지스트리 구현
```java
public class ConcurrentHashMapSqlRegistry implements UpdatableSqlRegistry {
	
	private Map<String, String> sqlMap = new ConcurrentHashMap<>();

	@Override
	public String findSql(String key) throws SqlNotFoundException {
		String sql = sqlMap.get(key);
		if (sql == null)
			throw new SqlNotFoundException(key + "를 이용해서 SQL을 찾을 수 없습니다.");
		else
			return sql;
	}

	@Override
	public void registerSql(String key, String sql) {
		sqlMap.put(key, sql);
	}

	@Override
	public void updateSql(String key, String sql) throws SqlUpdatableFailureException {
		if (sqlMap.get(key) == null)
			throw new SqlUpdatableFailureException(key + "에 해당하는 SQL을 찾을 수 없습니다.");
		
		sqlMap.put(key, sql);
	}

	@Override
	public void updateSql(Map<String, String> sqlmap) throws SqlUpdatableFailureException {
		for (Map.Entry<String, String> entry : sqlmap.entrySet()) {
			updateSql(entry.getKey(), entry.getValue());
		}
	}
}
```
🔼 ConcurrentHashMap을 사용하는 SQL 레지스트리
- 기존 HashMapSqlRegistry에서 HashMap을 ConcurrentHashMap으로 변경하고, UpdatableSqlRegistry에 추가된 메서드를 구현한다.

<br/>

<img width="625" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/ed3668dd-ed95-4a16-90ac-7c299d78a9d8">

🔼 ConcurrentHashMapSqlRegistry를 적용한 설정
- XML 설정 변경 후 UserDaoTest를 실행해보면 새로 적용한 ConcurrentHashMapSqlRegistry가 OxmSqlService와 협력해서 기본적인 SqlService 기능을 제공하는 데 이상이 없는지 확인할 수 있다.

<br/>

## 7.5.2 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기
