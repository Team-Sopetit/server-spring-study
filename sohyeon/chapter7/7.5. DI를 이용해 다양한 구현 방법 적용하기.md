# 7.5 DI를 이용해 다양한 구현 방법 적용하기
- DI와 인터페이스를 활용하여 여러 가지 구현을 만들어 적용해본다.

<br/>

## 7.5.1 ConcurrentHashMap을 이용한 수정 가능 SQL 레지스트리
- 동기화된 해시 데이터 조작에 최적화되도록 만들어졌다.
- 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고 조회는 락을 아예 사용하지 않는다.
- 👍 어느 정도 안전하면서 성능이 보장된다.

<br/>

### 수정 가능 SQL 레지스트리 테스트

```java
public class ConcurrentHashMapSqlRegistryTest {
	UpdatableSqlRegistry sqlRegistry;
	
	@BeforeEach
	public void setUp() {
		sqlRegistry = new ConcurrentHashMapSqlRegistry();
		sqlRegistry.registerSql("KEY1", "SQL1");
		sqlRegistry.registerSql("KEY2", "SQL2");
		sqlRegistry.registerSql("KEY3", "SQL3");
	}
	
	@Test
	public void find() {
		checkFindResult("SQL1", "SQL2", "SQL3");
	}
	
	// 반복적으로 검증하는 부분은 별도의 메서드로 분리해두면 테스트 코드가 깔끔해진다.
	private void checkFindResult(String expected1, String expected2, String expected3) {
		assertThat(sqlRegistry.findSql("KEY1"), is(expected1));
		assertThat(sqlRegistry.findSql("KEY2"), is(expected2));
		assertThat(sqlRegistry.findSql("KEY3"), is(expected3));
	}
	
	// 주어진 키에 해당하는 SQL을 찾을 수 없을 때 예외가 발생하는지 확인한다.
	// 예외상황에 대한 테스트는 빼먹기가 쉽기 때문에 항상 의식적으로 넣으려고 노력해야 한다.
	@Test(expected = SqlNotFoundException.class)
	public void unknownKey() {
		sqlRegistry.findSql("SQL9999!!@#$");
	}
	
	// 하나의 SQL을 변경하는 기능에 대한 테스트
	// 검증할 때는 변경된 SQL 외의 나머지 SQL은 그대로인지도 확인해주는 게 좋다.
	@Test
	public void updateSingle() {
		sqlRegistry.updateSql("KEY2", "Modified2");
		checkFindResult("SQL1", "Modified2", "SQL3");
	}
	
	@Test
	public void updateMulti() { // 한 번에 여러 개의 SQL을 수정하는 기능을 검증한다.
		Map<String, String> sqlmap = new HashMap<>();
		sqlmap.put("KEY1", "Modified1");
		sqlmap.put("KEY3", "Modified3");
		
		sqlRegistry.updateSql(sqlmap);
		checkFindResult("Modified1", "SQL2", "Modified3");
	}
	
	@Test(expected = SqlUpdatableFailureException.class) // 존재하지 않는 키의 SQL을 변경하려고 시도할 때 예외가 발생하는 것을 검증
	public void updateWithNotExistingKey() {
		sqlRegistry.updateSql("SQL9999!@#$", "Modified2");
	}
}
```
🔼 ConcurrentHashMap을 이용한 SQL 레지스트리 테스트
- 테스트를 철저하게 만들어서 기능을 검증하고 구현 방식이 변경될 때마다 테스트를 실행해서 기능에 영향을 주는지 확인하는 일이 매우 중요하다.

<br/>

### 수정 가능 SQL 레지스트리 구현
```java
public class ConcurrentHashMapSqlRegistry implements UpdatableSqlRegistry {
	
	private Map<String, String> sqlMap = new ConcurrentHashMap<>();

	@Override
	public String findSql(String key) throws SqlNotFoundException {
		String sql = sqlMap.get(key);
		if (sql == null)
			throw new SqlNotFoundException(key + "를 이용해서 SQL을 찾을 수 없습니다.");
		else
			return sql;
	}

	@Override
	public void registerSql(String key, String sql) {
		sqlMap.put(key, sql);
	}

	@Override
	public void updateSql(String key, String sql) throws SqlUpdatableFailureException {
		if (sqlMap.get(key) == null)
			throw new SqlUpdatableFailureException(key + "에 해당하는 SQL을 찾을 수 없습니다.");
		
		sqlMap.put(key, sql);
	}

	@Override
	public void updateSql(Map<String, String> sqlmap) throws SqlUpdatableFailureException {
		for (Map.Entry<String, String> entry : sqlmap.entrySet()) {
			updateSql(entry.getKey(), entry.getValue());
		}
	}
}
```
🔼 ConcurrentHashMap을 사용하는 SQL 레지스트리
- 기존 HashMapSqlRegistry에서 HashMap을 ConcurrentHashMap으로 변경하고, UpdatableSqlRegistry에 추가된 메서드를 구현한다.

<br/>

<img width="625" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/ed3668dd-ed95-4a16-90ac-7c299d78a9d8">

🔼 ConcurrentHashMapSqlRegistry를 적용한 설정
- XML 설정 변경 후 UserDaoTest를 실행해보면 새로 적용한 ConcurrentHashMapSqlRegistry가 OxmSqlService와 협력해서 기본적인 SqlService 기능을 제공하는 데 이상이 없는지 확인할 수 있다.

<br/>

## 7.5.2 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기
- 내장형 DB를 이용해 SQL을 저장하고 수정하도록 만들어본다.

<br/>

### 스프링의 내장형 DB 지원 기능
- 스프링은 내장형 DB를 초기화하는 작업을 지원하는 편리한 내장형 DB 빌더를 제공한다.
- 데이터 초기화를 위해 테이블 등을 생성하거나 초기 데이터를 삽입하는 SQL을 실행해주기도 한다.
- 모든 준비 후 내장형 DB에 대한 DataSource 오브젝트를 돌려주는데, 이후로는 일반적인 DB처럼 사용하면 된다.
- 내장형 DB는 애플리케이션 안에서 직접 DB 종료를 요청할 수 있어야 한다. (shutdown()이라는 메서드가 추가된 EmbeddedDatabase 인터페이스 제공)

<br/>

### 내장형 DB 빌더 학습 테스트
```
CREATE TABLE SQLMAP (
	KEY_ VARCHAR(100) PRIMARY KEY,
	SQL_ VARCHAR(100) NOT NULL
);
```
🔼 테이블 생성 SQL (schema.sql 파일)
- KEY와 SQL 모두 일반적으로 DB에서 키워드로 사용되기 때문에 그대로 필드 이름으로 쓸 수 없다.
- 위 문제 때문에 뒤에 _를 추가했다.

<br/>

```
INSERT INTO SQLMAP(KEY_, SQL_) values ('KEY1', 'SQL1');
INSERT INTO SQLMAP(KEY_, SQL_) values ('KEY2', 'SQL2');
```
🔼 초기 데이터 등록 SQL

<br/>

```java
new EmbeddedDatabaseBuilder() // 빌더 오브젝트 생성
	.setType(${내장형 DB 종류}) // EmbeddedDatabaseType의 HSQL, DERBY, H2 중에서 하나를 선택한다.
	.addScript(${초기화에 사용할 DB 스크립트의 리소스}) // 테이블 생성과 데이터 초기화를 위해 사용할 SQL 문장을 담은 SQL 스크립트의 위치를 지정한다.
	...
	.build(); // 주어진 조건에 맞는 내장형 DB를 준비하고 초기화 스크립트를 모두 실행한 뒤 이에 접근할 수 있는 EmbeddedDatabase를 돌려준다.
```
🔼 EmbeddedDatabaseBuilder를 사용하는 전형적인 방법

<br/>

```java
public class EmbeddedDbTest {
	EmbeddedDatabase db;
	SimpleJdbcTemplate template; // JdbcTemplate을 더 편리하게 사용할 수 있게 확장한 템플릿
	
	@BeforeEach
	public void setUp() {
		db = new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL) // 초기화 SQL이 호환만 된다면 DB 종류는 언제든지 바꿀 수 있다.
				.addScript("classpath:/springbook/learningtest/spring/embeddeddb/schema.sql")
				.addScript("classpath:/springbook/learningtest/spring/embeddeddb/data.sql")
				.build();
		
		template = new SimpleJdbcTemplate(db); // DataSource를 필요로 하는 SimpleJdbcTemplate을 만들 때 사용할 수 있다.
	}
	
	@AfterEach
	public void tearDown() { // 매 테스트 실행 후 DB를 종료한다. 내장형 메모리 DB는 매번 새롭게 DB가 만들어지고 제거되는 생명주기를 갖는다.
		db.shutdown();
	}
	
	@Test
	public void initData() { // 초기화 스크립트를 통해 등록된 데이터를 검증한다.
		assertThat(template.queryForInt("select count(*) from sqlmap"), is(2));
		
		List<Map<String, Object>> list = template.queryForList("select * from sqlmap order by key_");
		assertThat((String)list.get(0).get("key_"), is("KEY1"));
		assertThat((String)list.get(0).get("sql_"), is("SQL1"));
		assertThat((String)list.get(0).get("key_"), is("KEY2"));
		assertThat((String)list.get(0).get("sql_"), is("SQL2"));
	}
	
	@Test
	public void insert() { // 새로운 데이터를 추가하고 이를 확인해본다.
		template.update("insert into sqlmap(key_, sql_) values(?,?)", "KEY3", "SQL3");

		assertThat(template.queryForInt("select count(*) from sqlmap"), is(3));
	}
}
```
🔼 내장형 DB 학습 테스트

<br/>

### 내장형 DB를 이용한 SqlRegistry 만들기
- EmbeddedDatabaseBuilder를 활용해서 EmbeddedDatabase 타입의 오브젝트를 생성해주는 팩토리 빈을 만들어야 한다.

<br/>

```xml
<jdbc:embedded-database id="embeddedDatabase" type="HSQL">
	<jdbc:script location="classpath:schema.sql"/>
</jdbc:embedded-database>
```
🔼 HSQL 내장형 DB 설정 예
- jdbc 네임스페이스를 선언해두고 간단한 전용 태그로 빈을 정의해주면 내장형 DB를 손쉽게 사용할 수 있다.

<br/>

```java
public class EmbeddedDbSqlRegistry implements UpdatableSqlRegistry {
	SimpleJdbcTemplate jdbc;
	
	public void setDataSource(DataSource dataSource) {
		jdbc = new SimpleJdbcTemplate(dataSource); // DataSource를 DI 받아서 SimpleJdbcTemplate 형태로 저장해두고 사용한다.
	}

	@Override
	public void registerSql(String key, String sql) {
		jdbc.update("insert into sqlmap(key_, sql_) values (?,?)", key, sql);
	}

	@Override
	public String findSql(String key) throws SqlNotFoundException {
		try {
			return jdbc.queryForObject("select sql_ from sqlmap where key_ = ?", String.class, key);
		} catch (EmptyResultDataAccessException e) { // 쿼리의 결과가 없으면 해당 예외가 발생
			throw new SqlNotFoundException(key + "에 해당하는 SQL을 찾을 수 없습니다.", e);
		}
	}

	@Override
	public void updateSql(String key, String sql) throws SqlUpdatableFailureException {
		// update()는 실행결과로 영향 받은 레코드의 개수를 반환한다.
		int affected = jdbc.update("update sqlmap set sql_ = ? where key_ = ?", sql, key);
		if (affected == 0) {
			throw new SqlUpdatableFailureException(key + "에 해당하는 SQL을 찾을 수 없습니다.");
		}
	}

	@Override
	public void updateSql(Map<String, String> sqlmap) throws SqlUpdatableFailureException {
		for (Map.Entry<String, String> entry : sqlmap.entrySet()) {
			updateSql(entry.getKey(), entry.getValue());
		}
	}
}
```
🔼 내장형 DB를 사용하는 SQL 레지스트리
- 사용하지도 않을 DB 종료 기능을 가진 EmbeddedDatabase 대신 DataSource 인터페이스를 사용한다.

<br/>

### UpdatableSqlRegistry 테스트 코드의 재사용
