# 7.2 인터페이스의 분리와 자기참조 빈
- SqlService 인터페이스의 구현 방법을 고민해본다.
- 구현 방법과 확장 가능성에 따라 유연한 방법으로 재구성할 수 있도록 설계할 필요가 있다.

<br/>

## 7.2.1 XML 파일 매핑
- SQL을 저장해두는 전용 포맷을 가진 독립적인 파일을 이용하는 편이 바람직하다.

<br/>

### JAXB
- XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해준다.
- 매핑할 오브젝트의 클래스까지 자동으로 만들어주는 컴파일러도 제공한다.

<br/>

<img width="550" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/a302b338-5d15-4ce1-bb3f-c1e78853d16d">

🔼 JAXB 동작방식

<br/>

### SQL 맵을 위한 스키마 작성과 컴파일

```xml
<sqlmap>
	<sql key="userAdd">insert into users(id, name, password, email, level, login, recommend) values (?,?,?,?,?,?,?)</sql>
	<sql key="userGet">select * from users where id = ?</sql>
	...
</sqlmap>
```
🔼 SQL 맵 XML 문서
- 키와 SQL 정보를 담은 <sql> 태그를 가진 XML 문서를 만든다.

<br/>

<img width="550" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/26fc0a21-212c-4757-887d-f9b909f4f0e4">

<img width="550" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/dd982a4b-934c-456e-ad8a-0bd5a3d1602a">

🔼 SQL 맵 문서에 대한 스키마
- XML 문서 구조를 정의하고 있는 XML 스키마이다.

<br/>

```
xjc -p com.example.tobyspringexperience.sql.jaxb sqlmap.xsd -d src
```
🔼 컴파일
- `com.example.tobyspringexperience.sql.jaxb` : 생성할 클래스의 패키지 지정
- `sqlmap.xsd` : 변환할 스키마 파일
- `src` : 생성된 파일이 저장될 위치로, 소스 폴더에 추가해준다.
- 명령을 실행하면 2개의 바인딩용 자바 클래스와 팩토리 클래스가 만들어진다.

<br/>

```java
// 변환 작업에서 참고할 정보를 애노테이션으로 갖고 있다.
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "sqlmapType", propOrder = { "sql" })
@XmlRootElement(name = "sqlmap")
public class Sqlmap {

	@XmlElement(required = true)
	protected List<SqlType> sql; // <sql> 태그의 정보를 담은 SqlType 오브젝트를 리스트로 갖고 있다.
	
	public List<SqlType> getSql() {
		if (Objects.isNull(sql)) {
			sql = new ArrayList<>();
		}
		return this.sql;
	}
}
```
🔼 SqlmapType 클래스
- <sqlmap>이 바인딩될 클래스이다.

<br/>

```java
@Getter
@Setter
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "sqlmapType", propOrder = { "value" })
public class SqlType { // <sql> 태그 한 개당 SqlType 오브젝트가 하나씩 만들어진다.
	
	@XmlValue
	protected String value; // SQL 값을 저장할 스트립 타입의 필드
	
	@XmlAttribute(required = true)
	protected String key; // key 애트리뷰트에 담긴 검색용 키 값을 위한 스트링 타입의 필드
}
```
🔼 SqlType 클래스
- <sql> 태그의 정보를 담을 클래스이다.

<br/>

### 언마샬링
- 학습 테스트를 만들어본다.
- 언마샬링: XML 문서를 읽어서 자바의 오브젝트로 변환되는 것
- 마샬링: 바인딩 오브젝트를 XML 문서로 변환하는 것

<br/>

<img width="493" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/5536df8e-19b4-467f-9fc4-c9bab1426858">

🔼 테스트용 SQL 맵 XML 문서

<br/>

```java
public class JaxbTest {
	
	@Test
	public void readSqlmap() throws JAXBException, IOException {
		String contextPath = Sqlmap.class.getPackage().getName();
		JAXBContext context = JAXBContext.newInstance(contextPath); // 바인딩용 클래스들 위치를 가지고 JAXB 컨텍스트를 만든다.
		Unmarshaller unmarshaller = context.createUnmarshaller(); // 언마샬러 생성
		
		Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal( // 언마샬을 하면 매핑된 오브젝트 트리의 루트인 Sqlmap을 돌려준다.
				getClass().getResourceAsStream("sqlmap.xml") // 테스트 클래스와 같은 폴더에 있는 XML 파일을 사용한다.
		);

		List<SqlType> sqlList = sqlmap.getSql();
		
		// List에 담겨 있는 Sql 오브젝트를 가져와 XML 문서와 같은 정보를 갖고 있는지 확인한다.
		assertThat(sqlList.size(), is(3));
		assertThat(sqlList.get(0).getKey(), is("add"));
		assertThat(sqlList.get(0).getValue(), is("insert"));
		assertThat(sqlList.get(1).getKey(), is("get"));
		assertThat(sqlList.get(1).getValue(), is("select"));
		assertThat(sqlList.get(2).getKey(), is("delete"));
		assertThat(sqlList.get(2).getValue(), is("delete"));
	}
}
```
🔼 JAXB 학습 테스트

<br/>

## 7.2.2 XML 파일을 이용하는 SQL 서비스
- sqlService에 적용해보자.

<br/>

### SQL 맵 XML 파일
```xml
‹?xml versoin="1.0" encodinq="UTF-8"?>
<sqlmap xmlns="http://www.epril.com/sqlmap" 
        xmlns="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.epril.com/sqlmap http://www.epril.com/sqlmap/sqlap.xsd">
    <sqlmap>
        <sql key="userAdd">insert into users(id, name, password, email, level, login, recommend) values (?,?,?,?,?,?,?)</sql>
        <sql key="userGet">select * from users where id = ?</sql>
        <sql key="userGetAll">select * from users order by id</sql>
        <sql key="userDeleteAll">delete from users</sql>
        <sql key="userGetCount">select count(*) from users</sql>
        <sql key="userUpdate">update users set name = ?, password = ?, email = ?, level = ?, login = ?, recommend = ? where id = ?</sql>
    </sqlmap>
</sqlmap>
```
🔼 SQL 맵 XML 문서
- SQL은 DAO 로직의 일부라고 볼 수 있으므로 DAO와 같은 패키지에 두는 게 좋다.

<br/>

### XML SQL 서비스
- SqlService 인터페이스의 구현 클래스를 만들어본다.
- 가능한 한 XML 파일은 한 번만 읽도록 해야 한다.

<br/>

```java
public class XmlSqlService implements SqlService {
	
	private Map<String, String> sqlMap = new HashMap<String, String>(); // 읽어온 SQL을 저장해둘 맵
	
	// 스프링이 오브젝트를 만드는 시점에서 SQL을 읽어오도록 생성자를 이용한다.
	public XmlSqlService() {
		// JAXB API를 이용해 XML 문서를 오브젝트 트리로 읽어온다.
		String contextPath = Sqlmap.class.getPackage().getName();
		try {
			JAXBContext context = JAXBContext.newInstance(contextPath);
			Unmarshaller unmarshaller = context.createUnmarshaller();
			InputStream is = UserDao.class.getResourceAsStream("sqlmap.xml"); // UserDao와 같은 클래스패스의 sqlmap.xml 파일을 변환한다.
			Sqlmap sqlmap = (Sqlmap)unmarshaller.unmarshal(is);
			
			// 읽어온 SQL을 맵으로 저장해둔다.
			for (SqlType sql : sqlmap.getSql()) {
				sqlMap.put(sql.getKey(), sql.getValue());
			}
		} catch (JAXBException e) {
			throw new RuntimeException(e); // 복구 불가능한 예외이므로 불필요한 throws를 피하도록 런타임 예외로 포장해서 던진다.
		}
	}
	
	@Override
	public String getSql(String key) throws SqlRetrievalFailureException {
		String sql = sqlMap.get(key);
		if (Objects.isNull(sql)) {
			throw new SqlRetrievalFailureException(key + "를 이용해서 SQL을 찾을 수 없습니다.");
		} else {
			return sql;
		}
	}
}
```
🔼 생성자 초기화 방법을 사용하는 XmlSqlService 클래스
- DAO 요청에 따라 SQL을 찾아서 전달하는 방식으로 SqlService를 구현했다.

<br/>

```xml
<bean id="sqlService" class="com.example.tobyspringexperience.sql.service.XmlSqlService">
</bean>
```
🔼 sqlService 설정 변경

<br/>

> ***결과***

- 🌕 깔끔한 XML 문서이므로 작성하고 검증하기에 편리하다.
- 🌕 필요하다면 다른 툴에서도 불러서 사용할 수 있다.
- 🌕 SQL 리뷰나 튜닝이 필요하다면 sqlmap.xml 파일만 제공해주면 된다.
- 🌕 SQL 내용을 변경하더라도 애플리케이션의 코드나 DI 설정에 영향을 주지 않는다.

<br/>

## 7.2.3 빈의 초기화 작업
- 생성자에서 예외가 발생할 수도 있는 복잡한 초기화 작업을 다루는 것은 좋지 않다.
- 읽어들일 파일의 위치와 이름이 코드에 고정되어 있다는 점이 좋지 않다.

<br/>

```java
private String sqlmapFile;
	
public void setSqlmapFile(String sqlmapFile) {
	this.sqlmapFile = sqlmapFile;
}
```
🔼 SQL 맵 파일 이름 프로퍼티
- 파일 이름을 외부에서 지정할 수 있도록 한다.

<br/>

```java
private void loadSql() {
	String contextPath = Sqlmap.class.getPackage().getName();
	try {
		...
		InputStream is = UserDao.class.getResourceAsStream(this.sqlmapFile); // 프로퍼티로 설정을 통해 제공받은 파일 이름을 사용한다.
		...
	}
}
```
🔼 생성자 대신 사용할 초기화 메서드
- 생성자에서 진행하던 작업을 별도의 초기화 메서드를 만들어 옮긴다.

<br/>

```java
XmlSqlService sqlProvider = new XmlSqlService();
sqlProvider.setSqlmapFile("sqlmap.xml");
sqlProvider.loadSql();
```
🔼 XmlSqlService 오브젝트의 초기화 방법
- 오브젝트를 만드는 시점에서 초기화 메서드를 한 번 호출해준다. (XmlSqlService 오브젝트에 대한 제어권이 코드에 있다면)

<br/>

<img width="675" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/4c9bdb8b-69f8-4066-8596-7d9d8032f62a">

🔼 context 네임스페이스 선언과 annotation-config 태그 설정
- aop.tx와 함께 context 스키마의 태그를 사용할 수 있도록 네임스페이스와 스키마를 설정해준 설정파일의 앞부분이다.

<br/>

```java
public class XmlSqlService implements SqlService {
	...
	@PostConstruct // loadSql() 메서드를 빈의 초기화 메서드로 지정한다.
	public void loadSql() { ... }
}
```
🔼 @PostConstruct 초기화 메서드
- 스프링은 XmlSqlService 클래스로 등록된 빈의 오브젝트를 생성하고 DI 작업을 마친 뒤 @PostContext가 붙은 메서드를 자동으로 실행해준다.

<br/>

```java
<bean id="sqlService" class="springbook.user.sqlservice.XmlSqlService">
	<property name="sqlmapFile" value="sqlmap.xml"/>
</bean>
```
🔼 sqlmapFile 프로퍼티 추가
- sqlmapFile 프로퍼티의 값을 sqlService 빈의 설정에 넣어준다.

<br/>

<img width="641" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/0dc0aeb7-8721-44e9-aaaf-0711afd26c2e">

🔼 스프링 컨테이너의 초기 작업 순서
- 스프링 컨테이너인 애플리케이션 컨텍스트가 XML 설정파일을 읽고 진행하는 작업의 순서를 보여준다.
- @PostConstruct를 단 메서드의 코드는 모든 프로퍼티의 값이 준비됐다고 가정하고 작성하면 된다.

<br/>

## 7.2.4 변화를 위한 준비: 인터페이스 분리
- 서로 관심이 다른 코드들을 분리하고, 서로 코드에 영향을 주지 않으면서 유연하게 확장 가능하도록 DI를 적용해보자.

<br/>

### 책임에 따른 인터페이스 정의
- SQL 정보를 외부의 리소스로부터 읽어온다.
- 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해준다.

<br/>

<img width="640" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/bf7bd700-4f0b-4bd3-a7a6-3983b24b2576">

🔼 SqlService 서비스 오브젝트 구조
- SqlService의 구현 클래스가 변경 가능한 책임을 가진 SqlReader와 SqlRegistry 두 가지 타입의 오브젝트를 사용하도록 만든다.
- SQL을 런타임 시에 변경하도록 요청하는 오브젝트가 필요에 따라 이를 호출해서 SQL을 갱신하도록 요청할 수 있다.

<br/>

```java
Map<String, String> sqls = sqlReader.readSql(); // Map이라는 구체적인 전송 타입을 강제하게 한다.
sqlRegistry.addSqls(sqls);
```
🔼 SqlService 구현 클래스 코드
- SqlReader가 리소스로부터 읽어온 SQL 정보를 맵으로 돌려준다고 정의한다.

<br/>

```java
sqlReader.readSql(sqlRegistry); // SQL을 저장할 대상인 sqlRegistry 오브젝트를 전달한다.
```
🔼 변경된 SqlService 코드
- SqlReader에게 SqlRegistry 전략을 제공해주면서 이를 이용해 SQL 정보를 SqlRegistry에 저장하라고 요청한다.

<br>

```java
interface SqlRegistry {
	void registerSql(String key, String sql); // SqlReader는 읽어들인 SQL을 이 메서드를 이용해 레지스트리에 저장한디.
}
```
🔼 등록 기능을 제공하는 SqlRegistry 메서드
- sqlRegistry가 구현한 인터페이스에는 등록을 위한 메서드를 제공해준다.

<br/>

<img width="371" alt="image" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/2b5c9c5d-8cfe-4fa6-a186-829f17b30d68">

🔼 SqlRegistry에 의존하는 SqlReader 구조
- SqlReader가 SqlRegitry와 의존관계를 가지고 작업을 진행하도록 만들었을 때의 구조

<br/>

### SqlRegistry 인터페이스
```java
package springbook.user.sqlservice;
...

public interface SqlRegistry {
	void registerSql(String key, String sql); // SQL을 키와 함께 등록한다.

	String findSql(String key) throws SqlNotFoundException; // 키로 SQL을 검색한다. 검색이 실패하면 예외를 던진다.
}
```
🔼 SqlRegistry 인터페이스
- SQL을 제공받아 등록해뒀다가 키로 검색해서 돌려준다.

<br/>

### SqlReader 인터페이스
```java
public interface SqlReader {
	void read(SqlRegistry sqlRegistry); // SQL을 외부에서 가져와 SqlRegistry에 등록한다. 다양한 예외가 발생할 수 있겠지만 대부분 복구 불가능한 예외이므로 굳이 에외를 선언해두지 않았다.
}
```
🔼 SqlReader 인터페이스
- SqlRegistry 오브젝트를 메서드 파라미터로 DI 받아서 읽어들인 SQL을 등록하는 데 사용하도록 만든다.

<br/>

## 7.2.5 자기참조 빈으로 시작하기
