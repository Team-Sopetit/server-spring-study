# 6.5 스프링 AOP

- 분리해낸 트랜잭션 코드는 투명한 부가기능 형태로 제공되어야 한다.
- 투명하다는 건 부가기능을 적용한 후에도 기존 설계와 코드에는 영향을 주지 않는다는 뜻이다.

<br/>

## 6.5.1 자동 프록시 생성

- 👎 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해주는 문제점을 해결해야 한다.

<br/>

### 중복 문제의 접근 방법

- 반복적인 프록시의 메소드 구현을 코드 자동생성 기법을 이용해 해결했다면 ProxyFactoryBean 반복 설정 문제는 설정 자동등록 기법으로 해결할 수 없을까?
- 실제 빈 오브젝트는 ProxyFactoryBean을 통해 생성되는 프록시 그 자체이므로 프록시가 자동으로 빈으로 생성되게 할 수는 없을까?
- 하지만 지금까지 살펴본 방법에서는 한 번에 여러 개의 빈에 프록시를 적용할 만한 방법은 없었다.

<br/>

### 빈 후처리기를 이용한 자동 프록시 생성기

- 빈 후처리기(BeanPostProcessor)는 스프링 빈 오브젝트로 만들어진 후에 빈 오브젝트를 다시 가공할 수 있게 해준다.
- DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기다.
- 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다.
- 이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수도 있다.

<br/>

🔽 빈 후처리기를 이용한 프록시 자동생성

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/8c0c3009-5b9b-4966-a980-46a20cad8636)

- 빈 후처리기를 이용한 자동 프록시 생성 방법을 설명한다.
- 1️⃣ DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 보낸다.
- 2️⃣ DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
  - 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해준다.
- 3️⃣ 빈 후처리기는 프록시가 생성되면 프록시 오브젝트를 컨테이너에게 돌려준다.
- 4️⃣ 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.
- 이렇게 되면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있다.

<br/>

### 확장된 포인트컷

- 포인트컷은 오브젝트 내의 메소드를 선택하는 기능, 빈 오브젝트 자체를 선택하는 기능 2가지를 모두 가지고 있다.

<br/>

🔽 두 가지 기능을 정의한 Pointcut 인터페이스
```java
public interface Pointcut {
  ClassFilter getClassFilter(); // 프록시를 적용할 클래스인지 확인해준다.
  MethodMatcher getMethodMatcher(); // 어드바이스를 적용할 메소드인지 확인해준다.
}
```
- 포인트컷은 **클래스 필터**와 **메소드 매처** 두 가지를 돌려주는 메소드를 갖고 있다.
- 실제 포인트컷의 선별 로직은 이 두 가지 타입의 오브젝트에 담겨 있다.

<br/>

### 포인트컷 테스트

- NameMatchMethodPointcut을 확장해서 클래스도 고를 수 있도록 해보자.
- 프록시 적용 후보를 여럿 만들어두고 포인트컷을 적용한 ProxyFactoryBean으로 프록시를 만들도록 해서 어드바이스가 적용되는지 확인하자.

<br/>

🔽 확장 포인트컷 테스트
```java
@Test
public void classNamedPointcutAdvisor() {
  // 포인트컷 준비
  NameMatchMethodPointcut classMethodPointcut = new NameMatchMethodPointcut() {
    public ClassFilter getClassFilter() {
      return new ClassFilter() {
        public boolean matches(Class<?> clazz) {
          return class.getSimpleName().startsWith("HelloT"); // 클래스 이름이 HelloT로 시작하는 것만 선정한다.
        }
      };
    }
  };
  classMethodPointcut.setMappedName("sayH*"); // sayH로 시작하는 메소드 이름을 가진 메소드만 선정한다.

  // 테스트
  checkAdviced(new HelloTarget(), classMethodPointcut, true); // HelloTarget 적용 클래스다.

  class HelloWorld extends HelloTarget {};
  checkAdviced(new HelloWorld(), classMethodPointcut, false); // HelloWorld는 적용 클래스가 아니다.

  class HelloSohyeon extends HelloTarget {};
  checkAdviced(new HelloToby(), classMethodPointcut, true); // HelloSohyeon은 적용 클래스다.
}

private void checkAdviced(Object target, Pointcut pontcut, boolean adviced) {
  ProxyFactoryBean pfBean = new ProxyFactoryBean();
  pfBean.setTarget(target);
  pfBean.addAdvisor(new DefaultPointcutAdvisor(pontcut, new UppercaseAdvice()));
  Hello proxiedHello = (Hello)pfBean.getObject();

  if (adviced) {
    // 메소드 선정 방식을 통해 어드바이스 적용
    assertThat(proxiedHello.sayHello("Toby"), is("HELLO TOBY"));
    assertThat(proxiedHello.sayHi("Toby"), is("HI TOBY"));

    assertThat(proxiedHello.sayThankYou("Toby"), is("Thank You Toby"));
  } else {
    // 어드바이스 적용 대상 후보에서 아예 탈락
    assertThat(proxiedHello.sayHello("Toby"), is("Hello Toby"));
    assertThat(proxiedHello.sayHi("Toby"), is("Hi Toby"));
    assertThat(proxiedHello.sayThankYou("Toby"), is("Thank You Toby"));
  }
}
```
- 원래 모든 클래스를 다 받아주는 클래스 필터를 리턴하던 getClassFilter()르 오버라이드해서 이름이 HelloT로 시작하는 클래스만 선정해주는 필터로 만들었다.
- 테스트는 3가지 클래스에 대해 진행한다. 모두 기존 HelloTarget을 그대로 적용했으므로 속도 동일하다.
- HelloWorld는 선정 기준(클래스 이름)에 충족하지 못해 클래스 필터에서 탈락한다.
- 포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면  아무리 프록시를 적용해도 부가기능은 제공되지 않는다는 점을 주의해야 한다.

<br/>

## 6.5.2 DefaultAdvisorAutoProxyCreator의 적용

- 포인트컷을 적용해보자.

<br/>

### 클래스 필터를 적용한 포인트컷 작성

🔽 클래스 필터가 포함된 포인트컷
```java
package springbook.learningtest.jdk.proxy;
...
public class NameMatchClassMethodPointcut extends NameMatchMethodPointcut {
  public void setMappedClassName(String mappedClassName) {
    this.setClassFilter(new SimpleClassFilter(mappedClassName)); // 모든 클래스를 다 허용하던 디폴트 클래스 필터를 프로퍼티로 받은 클래스 이름을 이용해서 필터를 만들어 덮어씌운다.
  }

  static class SimpleClassFilter implements ClassFilter {
    String mappedName;

    private SimpleClassFilter(String mappedName) {
      this.mappedName = mappedName;
    }

    public boolean matches(Class<?> clazz) {
      // simpleMatch: 와일드카드(*)가 들어간 문자열 비교를 지원하는 스프링의 유틸리티 메서드
      // "*name, name*, *name* 3가지 방식을 모두 지원한다.
      return PatternMatchUtils.simpleMatch(mappedName, clazz.getSimpleName());
    }
  }
}
```
- NameMatchMethodPointcut(메서드 이름만 비교)을 상속해서 클래스 이름을 비교하는 ClassFilter를 추가한다.

<br/>

### 어드바이저를 이용하는 자동 프록시 생성기 등록
- DefaultAdvisorAutoProxyCreator(자동 프록시 생성기)는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다.
- 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 적용 대상을 선정한다. (선정 대상이라면 프록시로 바꿔치기)
- 타깃 빈에 의존한다고 정의한 다른 빈들은 프록시 오브젝트를 대신 DI 받게 된다.

<br/>

```xml
<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" />
```
- 등록을 위한 한 줄이다.
- 다른 빈에서 참조되거나 코드에서 빈 이름으로 조회될 필요가 없는 빈은 id를 등록하지 않아도 무방하다.

<br/>

### 포인트컷 등록

🔽 포인트컷 빈
```xml
<bean id=transactionPointcut" class="springbook.service.NameMatchClassMethodPointcut">
  <property name="mappedClassName" value="*ServiceImpl" /> <!-- 클래스 이름 패턴 -->
  <property name="mappedName" value="upgrade*" /> <!-- 메서드 이름 패턴 -->
</bean>
```
- 기존의 포인트컷 설정을 삭제하고 새로 만든 클래스 필터 지원 포인트컷을 빈으로 등록한다.
- ServiceImpl로 이름이 끝나는 클래스와 upgrade로 시작하는 메서드를 선정해준다.

<br/>

### 어드바이스와 어드바이저
- 어드바이스(transactionAdvice)와 어드바이저(transactionAdvisor) 빈은 수정할 필요는 없지만, 사용되는 방법은 바뀌었다.
- 어드바이저를 이용하는 자동 프록시 생성기(DefaultAdvisorAutoProxyCreator)에 의해 **자동수집**되고, **프록시 대상 선정** 과정에 참여하며, 자동생성된 프록시에 **다이내믹하게 DI**돼서 동작한다.

<br/>

### ProxyFactoryBean 제거와 서비스 빈의 원상복구

🔽 프록시 팩토리 빈을 제거한 후의 빈 설정
```xml
<bean id="userService" class="springbook.service.UserServiceImpl">
  <property name="userDao" ref="userDao" />
  <property name="mailSender" ref="mailSender" />
</bean>
```
- 더 이상 명시적인 프록시 팩토리 빈을 등록하지 않는다.
- ProxyFactoryBean 타입의 빈은 삭제한다.
- UserService와 관련된 빈 설정은 userService 하나로 충분하다.

<br/>

### 자동 프록시 생성기를 사용하는 테스트

- @Autowired를 통해 컨텍스트에서 가져오는 UserService 타입 오브젝트는 트랜잭션이 적용된 프록시이어야 한다.
- 이제 팩토리 빈은 존재하지 않고, 프록시 오브젝트만 남아있을 뿐이다.
- 기존에 만들었던 강제 예외 발생용 TestUserService 클래스를 직접 빈으로 등록해보자.

<br/>

🔽 수정한 테스트용 UserService 구현 클래스
```java
// 포인트컷의 클래스 필터에 선정되도록 이름 변경. 이래서 처음부터 이름을 잘 지어야한다고 한다.
static class TestUserServiceImpl extends UserServiceImpl {
  private String id = "madnite1"; // 테스트 픽스처의 users(3)의 id 값을 고정한다.

  protected void upgradeLevel(User user) {
    if (user.getId().equals(this.id)) throw new TestUserServiceException();
    super.upgradeLevel(user);
  }
}
```
- 클래스 이름을 TestUserServiceImpl으로 변경한다.
- 예외를 발생시킬 사용자 id를 클래스 내에 넣는다.

<br/>

🔽 테스트용 UserService의 등록
```xml
<bean id="testUserService" class="springbook.user.service.UserServiceTest$TestUserServiceImpl" parent="userService" />
```
- `UserServiceTest$TestUserServiceImpl` : 스태틱 멤버 클래스는 $로 지정한다.
- `parent` : 프로퍼티 정의를 포함해서 userService 빈의 설정을 상속받는다.

<br/>

🔽 testUserService 빈을 사용하도록 수정된 테스트
```java
public class UserServiceTest {
  @Autowired UserService userService;
  @Autowired UserService testUserService; // 같은 타입의 빈이 2개 존재하기 때문에 필드 이름을 기준으로 주입될 빈이 결정된다.
  ...

  @Test
  public void upgradeAllOrNothing() { // 스프링 컨텍스트의 빈 설정을 변경하지 않으므로 @DirtiesContext 어노테이션은 제거했다.
    userDao.deleteAll();
    for(User user : users) userDao.add(user);

    try {
      this.testUserService.upgradeLevels();
      fail("TestUserServiceException expected");
    } catch (TestUserServiceException e) {
    }

    checkLevelUpgraded(users.get(1), false);
  }
}
```
- 자동 프록시 생성 방식으로 테스트 코두 깔끔해졌다.
- 테스트 코드에서 예외상황을 적용하기 위해 DI를 적용함으로써 코드가 단순해졌다.

<br/>

### 자동생성 프록시 확인
- 무슨 기술이든 자동으로 무엇을 해준다고 하면 정말 그런지 한 번쯤은 직접 확인해보는 습관을 들이자.
- 후처리기 메커니즘을 통해 적용함으로써 최소 2가지를 확인해야 했다.
  - 1️⃣ 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가
  - 2️⃣ 아무 빈에나 트랜잭션이 부가기능이 적용된 것은 아닌가
 
<br/>

🔽 클래스 필터용 이름을 변경한 포인트컷 설정
```xml
<bean id="transactionPointcut" class="springbook.user.service.NameMatchClassMethodPointcut">
  <property name="mappedClassName" value="*NotServiceImpl" />
  <property name="mappedName" value="upgrade*" />
</bean>
```
- 클래스 필터용 이름 패턴을 변경함으로써 Test 클래스가 트랜잭션이 적용되지 않는지 확인한다.
- 테스트 후에는 원상복구 한다.

<br/>

🔽 자동생성된 프록시 확인
```java
@Test
public void advisorAutoProxyCreator() {
  assertThat(testUserService, is(java.lang.reflect.Proxy.class)); // 프록시로 변경된 오브젝트인지 확인한다.
}
```
- 이를 통해 자동 프록시 생성용 빈 후처리기(DefaultAdvisorAutoProxyCreator)가 자동으로 빈 오브젝트를 프록시 빈으로 바꿔준다는 사실을 충분히 알 수 있다.

<br/>

## 6.5.3 포인트컷 표현식을 이용한 포인트컷
