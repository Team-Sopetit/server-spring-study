# 6.6 트랜잭션 속성
- 트랜잭션 매니저에서 트랜잭션을 가져올 때 사용한 DefaultTransactionDefinition 오브젝트를 살펴보자.

<br/>

🔽 트랜잭션 경계설정 코드
```java
public Object invoke(MethodInvocation invocation) throws Throwable {

  TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition()); // 트랜잭션 정의

  try { // 트랜잭션 경계
    Object ret = invocation.proceed();
    this.transactionManager.commit(status); // 트랜잭션 종료
    return ret;
  } catch (RuntimeException e) {
    this.transactionManager.rollback(status); // 트랜잭션 종료
    throw e;
  }
}
```
- 트랜잭션의 경계는 트랜잭션 매니저에게 트랜잭션을 가져오는 것과 commit(), rollback() 중 하나를 호출하는 것으로 설정된다.

<br/>

## 6.6.1 트랜잭션 정의
- 트랜잭션 경계 안에서 진행된 작업은 모두 성공하거나 모두 취소해야 한다.
- 이 밖에도 TransactionDefinition 인터페이스는 트랜잭션 동작방식에 영향을 줄 수 있는 4가지 속성을 정의한다.

<br/>

### 트랜잭션 전파
- 트랜잭션 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식

<br/>

🔽 트랜잭션 전파

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/5f2b711c-fa75-4dbe-87b4-8299dcdb3d9d)

- 각각 독립적인 트랜잭션 경계를 가진 2개의 코드가 있다.
- A의 트랜잭션이 시작되고 끝나기 전에 B를 호출한다면, 어떻게 동작할까?
  - B 코드는 A에서 시작한 트랜잭션에 참여할 수 있다. (A와 B가 하나의 트랜잭션으로 묶임)
  - B의 트랜잭션은 A의 트랜잭션과 무관하게 독립적으로 만들 수 있다. (B 트랜잭션은 독자적으로 커밋/롤백, A&B 서로 영향 X)
- 독자적인 트랜잭션 경계를 가진 코드에 대해 이미 진행 중인 트랜잭션이 어떻게 영향을 미칠 수 있는가 정의하는 것이 **트랜잭션 전파 속성**이다.

<br/>

> ***PROPAGATION_REQUIRED***

- 가장 많이 사용되는 트랜잭션 전파 속성
- 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여
- DefaultTransactionDefinition의 트랜잭션 전파 속성

<br/>

> ***PROPAGATION_REQUIRES_NEW***

- 항상 새로운 트랜잭션을 시작
- 독립적인 트랜잭션이 보장되어야 하는 코드에 적용

<br/>

> ***PROPAGATION_NOT_SUPPORTED***

- 트랜잭션 없이 동작하도록 만들 수 있다. (진행 중인 트랜잭션이 있어도 무시)

<br/>

### 격리수준
- 적절하게 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 제어해야 한다.
- DefaultTransactionDefinition의 디폴트 격리수준은 ISOLATION_DEFAULT

<br/>

### 제한시간
- 트랜잭션을 수행하는 제한시간을 설정할 수 있다.
- DefaultTransactionDefinition의 기본 설정은 제한시간이 없다.
- PROPAGATION_REQUIRED 또는 PROPAGATION_REQUIRES_NEW와 함께 사용해야 의미가 있다.

<br/>

### 읽기전용
- 읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다.
- 데이터 액세스 기술에 따라서 성능이 향상될 수도 있다.

<br/>

## 6.6.2 트랜잭션 인터셉터와 트랜잭션 속성

### TransactionInterceptor
- 스프링에서 제공하는 편리하게 트랜잭션 경계설정 어드바이스로 사용할 수 있는 것
- 트랜잭션 정의를 메서드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공한다.
- PlatformTransactionManager와 Properties 타입의 2가지 프로퍼티를 갖는다.
  - Properties: 트랜잭션 속성을 정의한 프로퍼티
 
<br/>

🔽 트랜잭션 경계설정 코드의 동작방식 변경 포인트
```java
public Object invoke(MethodInvocation invocation) throws Throwable {

  TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition()); // 트랜잭션 정의를 위한 4가지 조건

  try {
    Object ret = invocation.proceed();
    this.transactionManager.commit(status);
    return ret;
  } catch (RuntimeException e) { // 롤백 대상인 예외 종류
    this.transactionManager.rollback(status);
    throw e;
  }
}
```
- 트랜잭션 부가기능의 동작방식을 변경할 수 있는 곳이 두 군데 있다.
- "트랜잭션 정의를 위한 4가지 조건"과 "롤백 대상인 예외 종류" 2가지 항목이 결합해서 트랜잭션 부가기능의 행동을 결정하는 TransactionAttribute 속성이 된다.

<br/>

### 메서드 이름 패턴을 이용한 트랜잭션 속성 지정
- Properties 타입의 transactionAttributes 프로퍼티는 메서드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다.
- 트랜잭션 속성 정의: PROGATION_NAME, ISOLATION_NAME, readOnly, timeout_NNNN, -Exception1, +Exception2
  - 트랜잭션 전파 방식, 필수항목, PROGATION_으로 시작
  - 격리수준, ISOLATION_으로 시작, 생략되면 디폴트 격리 수준으로 지정
  - 읽기전용 항목, 생략 가능, 디폴트는 읽기전용이 아님
  - 제한시간, timeout_으로 시작, 초 단위 시간을 뒤에 붙임, 생략 가능
  - 체크 예외 중에서 롤백 대상으로 추가할 것을 넣음, 1개 이상 등록 가능
  - 런타임 예외지만 롤백시키지 않을 예외들을 넣음, 1개 이상 등록 가능

<br/>

🔽 트랜잭션 속성 정의 예
```xml
<bean id="transactionAdvice" class="org.springframework.transaction.interceptor.TransactionInterceptor">
  <property name="transactionManager" ref="transactionManager" />
  <property name="transactionAttributes">
    <props>
      <prop key="get*">PROGATION_REQUIRED,readOnly,timeout_30</prop>
      <prop key="upgrade*">PROGATION_REQUIRES_NEW,ISOLATION_SERIALIZABLE</prop>
      <prop key="*">PROGATION_REQUIRED</prop>
    </props>
  </property>
</bean>
```
- 3가지 메서드 이름 패턴에 대한 트랜잭션 속성이 정의된다.
- 1️⃣ PROGATION_REQUIRED이면서 읽기전용이고, 시간제한은 30초이다. (get으로 시작하는 모든 메서드)
- 2️⃣ 독립적인 트랜잭션으로 동작하도록 설정했고, 완벽하게 고립된 상태(최고 격리수준)에서 트랜잭션이 동작하도록 설정했다. (upgrade로 시작하는 모든 메서드)
- 3️⃣ 위 2가지 조건에 해당하지 않는 나머지 모든 메서드에 필수 항목인 PROGATION_REQUIRED만 지정했다.

<br/>

### tx 네임스페이스를 이용한 설정 방법
- TransactionInterceptor 빈으로 정의한 트랜잭션 어드바이스와 메서드 패턴에 따른 트랜잭션 속성 지정은 tx 스키마의 태그를 이용해 정의할 수 있다.

<br/>

🔽 tx 스키마의 전용 태그

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/7e8e4e87-a415-4d7a-ab12-dd9c9377456f)

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/170c3950-3840-4c8f-b870-75f179dd555b)

- 설정 내용의 가독성이 향상되고, XML 에디터의 자동완성 기능을 통해 편하게 작성할 수 있다.
- XML 스키마에 미리 등록해둔 값을 통해 검증할 수 있어 오타도 줄어든다.
- tx 스키마의 태그를 사용해 어드바이스를 등록하는 것이 권장된다.

<br/>

## 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략
