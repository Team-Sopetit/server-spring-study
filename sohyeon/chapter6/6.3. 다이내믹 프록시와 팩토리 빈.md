## 6.3. 다이내믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

🔽 전략 패턴 적용을 통한 부가기능 구현의 분리

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/a09c472c-64fd-4a29-a388-c9702b274cfa)

- 트랜잭션과 같은 부가적인 기능을 위임을 통해 외부로 분리했을 때의 결과이다.
- 구체적인 구현 코드는 제거되었지만, **위임을 통해 기능을 사용하는 코드는 핵심 코드와 함께 남아**있다.

<br/>

🔽 부가기능과 핵심기능의 분리

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/26efda65-c8fe-45a3-accb-4ccacfde34b1)

- 부가기능 전부를 핵심 코드가 담긴 클래스에서 독립시킬 수 있다.
- 이를 통해 UserServiceTx를 만들었고, UserServiceImpl에는 트랜잭션 관련 코드가 하나도 남지 않도록 했다.
- 👎 하지만 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능이 적용될 기회가 없어진다.

<br/>

🔽 핵심기능 인터페이스의 적용

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/08f9f287-3c61-41c9-a7b5-40258a58e958)

- 부가기능을 통해 핵심기능을 이용하게 되는 구조이다.
- 위에서 언급한 문제를 피하기 위해, 부가기능은 자신이 핵심 기능을 가진 클래스인 것처럼 꾸며서 **클라이언트가 자신을 거쳐 핵심기능을 사용하도록** 한다.
- 이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 **프록시(proxy)** 라고 부른다.
- 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 **타깃(target)** 또는 **실체(real subject)** 라고 부른다.

<br/>

🔽 프록시와 타깃

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/da178f31-aa46-4b4a-a1f8-e072cd678a0e)

- 클라이언트가 프록시를 통해 타깃을 사용하는 구조이다.
- 프록시의 특징은 **타깃과 같은 인터페이스를 구현**했다는 것과 **프록시가 타깃을 제어할 수 있는 위치**에 있다는 것이다.
- 프록시는 사용 목적에 따라 2가지로 구분할 수 있다.
  - 1️⃣ 클라이언트가 타깃에 접근하는 방법을 제어하기 위함이다. (프록시 패턴)
  - 2️⃣ 타깃에 부가적인 기능을 부여해주기 위함이다. (데코레이터 패턴)
  - 2가지 모두 프록시를 사용한다는 점은 동일하지만, 목적에 따라 다른 패턴으로 구분된다.
 
<br/>

> ***데코레이터 패턴***

- **타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴이다.**
  - `다이내믹하게 기능 부가`: 컴파일 시점에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해지지 않는다.
- 마치 제품이나 케익 등을 여러 겹으로 포장하고 그 위에 장식을 붙이는 것처럼 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있다고 해서 **데코레이터**라고 불린다.
- 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있다.
- 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

<br/>

🔽 데코레이터 패턴 적용 예

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/e205fee2-3d5d-4974-a399-1e74e64bb0e1)

- 소스코드를 출력하는 기능을 가진 핵심기능이 있다고 가정하자.
- 해당 클래스에 데코레이터 개념을 부여해서 타깃과 같은 인터페이스를 구현하는 프록시를 만들 수 있다.
- 소스코드에 라인넘버를 붙이거나, 문법에 따라 색을 변경하거나, 페이지를 표시해주는 부가적인 기능을 각각 프록시로 만든다.
- 런타임 시에 프록시들과 타깃을 적절한 순서로 조합해서 사용하면 된다.

<br/>

- 프록시로 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃을 위임하는지, 다음 단계의 프록시를 위임하는지 모른다.
- 데코레이터의 다음 위임 대상은 외부에서 런타임 시에 주입받을 수 있다.

<br/>

🔽 데코레이터 패턴을 위한 DI 설정
```xml
<!-- 데코레이터 -->
<bean id="userService" class="springbook.user.service.UserServiceTx">
  <property name="transactionManager" ref="transactionManager" />
  <property name="userService" ref="userServiceImpl" />
</bean>

<!-- 타깃 -->
<bean id="userServiceImpl" class="springbook.user.service.UserServiceImpl>
  <property name="userDao" ref="userDao" />
  <property name="mailSender" ref="mailSender" />
</bean>
```
- 다이내믹한 부가기능의 부여라는 **데코레이터 패턴의 전형적인 예**이다.
- `데코레이터`: UserServiceTx 클래스로 선언된 userService 빈
- UserServiceTx는 UserService 타입의 오브젝트를 DI 받아 기능을 위임하고, 그 과정에서 트랜잭션 경계설정 기능을 부여한다.
- 설정파일을 통해 UserServiceImpl 클래스로 선언된 타깃 빈이 DI를 통해 데코레이터(userService 빈)에 주입된다.

<br/>

> ***프록시 패턴***

- 일반적으로 사용하는 프록시와 디자인 패턴에서 말하는 프록시는 구분된다.
  - `일반적인 프록시`: 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법
  - `디자인 패턴의 프록시`: 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우
- 타깃의 기능을 확장하거나 추가하지 않는다. 대신 **클라이언트가 타깃에 접근하는 방식을 변경**해준다.
- 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨준다. 그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해준다.
- 레퍼런스를 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면, 생성을 최대한 늦춤으로써 얻는 장점이 많다. (Ex. JPA 연관관계 LAZY 호출)
- 원격 오브젝트를 이용하는 경우에도 프록시를 사용하면 편리하다. (다른 서버에 존재하는 오브젝트를 사용해야 할 때, 클라이언트는 마치 로컬에 존재하는 오브젝트를 존재하는 것처럼 프록시 사용)
- 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위해 프록시 패턴을 사용할 수 있다. (특정 레이어로 넘어가서는 읽기전용으로만 사용해야 하는 경우)
- 이렇게 **타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어**할 수 있다.
- 데코레이터와 다르게, 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다. (물론 위임 방식도 존재)

<br/>

🔽 프록시 패턴과 데코레이터 패턴의 혼용

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/29def9d8-ab93-4a67-8c6b-59c9b2516eec)

- 접근 제어를 위한 프록시를 두는 **프록시 패턴**과 컬러, 페이징 기능을 추가하기 위한 프록시를 두는 **데코레이터 패턴**을 함께 적용한 예이다.
- 프록시 패턴에서 인터페이스를 통해 다음 호출 대상으로 접근하게 하면 그 사이에 프록시나 데코레이터가 계속 추가될 수 있다.
- 2가지 패턴 모두 타깃과 같은 인터페이스를 구현해두고 위임하는 방식으로 만들어져 있다.

<br/>

### 6.3.2 다이내믹 프록시

- 자바에는 `java.lang.reflect` 패키지 안에 프록시를 손쉽게 만들 수 있도록 지원해주는 클래스들이 있다.
- 일일이 프록시 클래스를 정의하지 않고도 몇 가지 API를 이용해 프록시처럼 동작하는 오브젝트를 다이내믹하게 생성한다.

<br/>

> ***프록시의 구성과 프록시 작성의 문제점***

🔽 UserServiceTx 프록시의 기능 구분
```java
public class UserServiceTx implements UserService {
  UserService userService; // 타깃 오브젝트
  ...

  public void add(User user) {
    this.userService.add(user); // 메소드 구현과 위임
  }

  public void upgradeLevels() { // 메소드 구현
    TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition()); // 부가기능 수행
    try {
      
      userService.upgradeLevels(); // 위임

      // 부가기능 수행
      this.transactionManager.commit(status);
    } catch(RuntimeException e) {
      this.transactionManager.rollback(status);
      throw e;
    }
  }
}
```
- 프록시의 2가지 기능을 분리했다. (타깃 오브젝트로 기능 위임, 부가기능 수행)
- 프록시를 만들기 번거로운 이유는 아래 2가지와 같다.
  - 1️⃣ 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다.
  - 2️⃣ 부가기능 코드가 중복될 가능성이 많다.
- 이러한 문제를 해결하는 데 유용한 것이 바로 JDK의 다이내믹 프록시다.

<br/>

> ***리플렉션***

- `다이내믹 프록시`는 리플렉션 기능을 이용해서 프록시를 만들어준다.
- `리플렉션`은 **자바의 코드 자체를 추상화해서 접근하도록 만든 것**이다.
- 클래스 오브젝트를 이용하면 클래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다.

<br/>

```java
Method lengthMethod = String.class.getMethod("length");
```
- 리플렉션 API 중에서 메소드에 대한 정의를 담은 Method라는 인터페이스를 이용해 메소드를 호출할 수 있다.
- String 클래스의 정보를 담은 Class 타입의 정보는 `String.class`를 통해 가져올 수 있다.
- 클래스 정보에서 특정 이름을 가진 메소드 정보를 가져올 수 있다. (위 코드는 length() 메소드를 호출)

<br/>

```java
public Object invoke(Object obj, Object... args)
```
- Method 인터페이스에 정의된 `invoke()` 메소드를 사용하면 특정 오브젝트의 메소드를 실행시킬 수 있다.
- `invoke()` 메소드는 메소드를 실행시킬 대상 오브젝트(obj)와 파라미터 목록(args)을 받아 메소드를 호출한 뒤 그 결과를 Object 타입으로 돌려준다.

<br/>

```java
int length = lenghMethod.invoke(name); // int length = name.length();
```
- 이를 이용해 length() 메소드를 위 코드와 같이 실행할 수 있다.

<br/>

🔽 리플렉션 학습 테스트
```java
package springbook.learningtest.jdk;
...
public class ReflectionTest {
  @Test
  public void invokeMethod() throws Exception {
    String name = "Spring";

    // length()
    assertThat(name.length(), is(6));

    Method lengthMethod = String.class.getMethod("length");
    assertThat((Integer)lengthMethod.invoke(name), is(6));

    // charAt()
    assertThat(name.charAt(0), is('S'));

    Method charAtMethod = String.class.getMethod("charAt", int.class);
    assertThat((Character)charAtMethod.invoke(name, 0), is('S'));
  }
}
```
- String 클래스의 length() 메소드와 charAt() 메소드를 코드에서 직접 호출하는 방법과, Method를 이용해 리플렉션 방식으로 호출하는 방법을 비교했다.

<br/>

> ***프록시 클래스***

다이내믹 프록시를 이용한 프록시를 만들어본다.

<br/>

🔽 Hello 인터페이스
```java
interface Hello {
  String sayHello(String name);
  String sayHi(String name);
  String sayThankYou(String name);
}
```
- 프록시를 적용할 간단한 타깃 클래스와 인터페이스를 정의한다.

<br/>

🔽 타깃 클래스
```java
public class HelloTarget implements Hello {
  public String sayHello(String name) {
    return "Hello " + name;
  }

  public String sayHi(String name) {
    return "Hi " + name;
  }

  public String sayThankYou(String name) {
    return "Thank You " + name;
  }
}
```
- 인터페이스를 구현해서 타깃 클래스를 만들었다.

<br/>

🔽 클라이언트 역할의 테스트
```java
@Test
public void simpleProxy() {
  Hello hello = new HelloTarget(); // 타깃은 인터페이스를 통해 접근하는 습관을 들이자.
  assertThat(hello.sayHello("Toby"), is("Hello Toby"));
  assertThat(hello.sayHi("Toby"), is("Hi Toby"));
  assertThat(hello.sayThankYou("Toby"), is("Thank You Toby"));
}
```
- Hello 인터페이스를 통해 HelloTarget 오브젝트를 사용하는 클라이언트 역할을 하는 간단한 테스트이다.

<br/>

🔽 프록시 클래스
```java
public class HelloUppercase implements Hello {
  Hello hello; // 위임할 타깃 오브젝트. 여기서는 타깃 클래스의 오브젝트인 것은 알지만 다른 프록시를 추가할 수 있으므로 인터페이스로 접근한다.

  public HelloUppercase(Hello hello) {
    this.hello = hello;
  }

  public String sayHello(String name) {
    return hello.sayHello(name).toUpperCase(); // 위임과 부가기능 적용
  }

  public String sayHi(String name) {
    return hello.sayHi(name).toUpperCase();
  }

  public String sayThankYou(String name) {
    return hello.sayThankYou(name).toUpperCase();
  }
}
```
- Hello 인터페이스를 구현한 프록시(`HelloUppercase`, 리턴하는 문자를 모두 대문자로 바꿔주는 부가기능 수행)이다.
- 데코레이터 패턴을 적용해서 타깃인 HelloTarget에 부가기능을 추가한다.
- Hello 인터페이스를 구현하고, Hello 타입의 타깃 오브젝트를 받아 저장해둔다.
- 구현 메소드에서는 타깃 오브젝트의 메소드를 호출한 뒤 결과를 대문자로 바꿔주는 부가기능을 적용하고 리턴한다.
- **위임과 기능 부가**라는 2가지 프록시의 기능을 모두 처리하는 전형적인 프록시 클래스이다.

<br/>

🔽 HelloUppercase 프록시 테스트
```java
Hello
```
- 테스트 코드를 추가해서 프록시가 동작하는지 확인한다.
