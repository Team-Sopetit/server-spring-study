# 9.3 애플리케이션 아키텍처
## 9.3.1 계층형 아키텍처
인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.

<br/>

### 아키텍처와 SoC
- 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다.
  - 분리된 각 오브젝트는 독자적으로 개발/테스트가 가능해서 작업이 빨라질 수 있다.
  - 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다.
 
- 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 **계층형 아키텍처(Layered Architecture)** 라고 한다.
  - **멀티 티어 아키텍처**라고도 한다.
  - 일반적으로 3개의 계층을 갖는다고 해서 **3계층(3-tier/layer) 애플리케이션**이라고도 한다.
 
<br/>

### 3계층 아키텍처와 수직 계층

<img alt="image" width="500" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/ab7a4a39-0458-4d9a-9520-97b4b1a5c7f9"/>

🔼 3계층 아키텍처
- **데이터 액세스 계층**
  - DAO 패턴을 보편적으로 사용하기 때문에 DAO 계층이라고도 불린다.
  - EIS(Enterprise Information System) 계층이라고도 한다.
  - 데이터 액세스 계층 안에서 다시 세분화하는 경우는 추상화 수준에 따른 구분이다. (수직적인 계층)

    <img alt="image" width="500" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/114320a5-20eb-44c5-8c91-080d3abee3bc"/>

    🔼 데이터 액세스 계층의 수직 계층 구조
    - JdbcTemplate이 추상화를 위한 계층으로 사용되어 DAO 코드가 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하도록 한다.
   
  - 추상 계층을 도입해서 하위 계층의 종류가 다른 서비스를 일관된 방식으로 접근할 수도 있게 할 수 있다.

    <img alt="image" width="500" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/da3f615d-7fa1-4501-a4ec-94f2ec1df907"/>

    🔼 2개 이상의 서비스를 통합하는 추상 계층의 도입
    - 개발자의 애플리케이션 코드에 큰 영향을 주기 때문에 신중해야 한다.
      - DAO 코드의 사용 패턴을 개발팀 또는 프로젝트 수준에서 잘 분석하고 정리할 수 있ㄷ면 새로운 추상 계층의 도입을 고려해볼만 하다.
      - 추상 계층을 새로 추가하는 것은 부담스럽고 경우에 따라 유연하게 하위 계층의 API를 활용할 필요가 있다면, 공통적인 기능을 분리해서 유틸리티나 헬퍼 메서드 또는 오브젝트로 제공해주는 것도 좋은 방법이다.
     
  - **서비스 계층**
    - 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다.
    - DAO 계층을 호출하고 이를 활용해서 만들어진다.
    - 아래는 기반 서비스 계층이 3계층 어디에서나 접근이 가능한 구조로 설정되었다.

      <img alt="image" width="500" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/20f917f9-de2f-4401-b026-e6e1925174e2"/>
      
      🔼 서비스 계층과 기반 서비스 계층
      - 원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다.
      - 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 종속성을 제거해야 한다.
      - 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.
      - 이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바뀌고, 클라이언트와 연결되는 프리젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다.
     
  - **프레젠테이션 계층**
    - 가장 복잡한 계층이다.
    - 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다.
    - 최근에는 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다.
      - Ex. RIA(Rich Internet Application), SOFEA(Service Oriented Front End Architecture) 아키텍처
     
<br/>

### 계층형 아키텍처 설계의 원칙
- 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.
- 인터페이스를 사용할 때는 다른 계층에서 꼭 필요한 메서드만 노출해야 한다.
- DI는 계층을 구분해주지 않기 때문에 빈 사이의 의존관계를 만들 때 주의해야 한다.
  - 한 계층의 내부에서만 사용되도록 만든 빈 오브젝트를 DI를 통해 다른 계층에서 함부로 가져다 쓰는 일은 피해야 한다.
  - 중간 계층을 건너뛰어 관계를 갖지 않는 계층의 빈을 직접 DI 하지 않도록 주의해야 한다.
 
<br/>

## 9.3.2 애플리케이션 정보 아키텍처
- 데이터 중심 아키텍처
  - 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조다.
  - DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 뷰와 연결해준다.
  - 핵심 비즈니스 로직을 어디에 많이 두는지에 따라 **DB에 무게를 두는 구조**와 **서비스 계층의 코드에 무게를 두는 구조**로 구분할 수 있다.
 
<br/>

### DB/SQL 중심의 로직 구현 방식

<img alt="image" width="500" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/03056eca-3209-4c58-bd4a-772bff03b139"/>

🔼 DB 중심의 아키텍처
- 주요 로직을 클라이언트의 독립 프로그램에 담아두고 DB 처리 로직만 DB에 분리해둔 2계층 구조에서 비슷하게 발견할 수 있다.
- 👍 개발하기 쉽다.
- 👎 자바의 오브젝트는 HTTP 서비스 채널을 만들어주고 JDBC를 이용해 DB 기능을 사용하게 하는 스크립트 정도로 역할이 축소된다.
- 👎 계층 사이를 이동하는 데이터가 일종의 접착제 역할을 해서 강한 결합을 만들게 된다. (변화에 매우 취약함)
- 로직을 DB보다는 애플리케이션으로 가져오는 편이 유리한 점이 많다. (비용 저렴, 안정성 향상, 코드 검증 편리)
- DB에는 부하를 가능한 한 주지 않는 간단한 작업만 하고 복잡한 로직은 오브젝트에 담아 애플리케이션 내에서 처리하도록 만드는 편이 낫다.

<br/>

### 거대한 서비스 계층 방식
비즈니스 로직의 대부분을 서비스 계층에 집중하는 접근 방법은 결국 **거대한 서비스 계층**을 만들게 된다.

<br/>

<img alt="image" width="500" src="https://github.com/Team-Sopetit/server-spring-study/assets/55437339/35916b06-74a6-4bb8-9527-d07cd6ee01f4"/>

🔼 거대 서비스 계층 방식의 아키텍처
- 👍 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 수월하다.
- 👍 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.
- 👍 각 단위 업무별로 독립적인 개발이 가능하므로 초기 개발 속도가 빠르고, 개발자 사이에 간섭 없이 독립적인 개발이 가능하다.
- 👎 본격적인 객체지향적 설계를 적용하기 힘들고, 개발자 개개인의 코딩 습관이나 실력에 따라 비슷한 로직이더라도 전혀 다른 스타일의 코드가 나오기 쉽다.
- 데이터 중심 아키텍처의 특징은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진다. 화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다.

<br/>

## 9.3.3 오브젝트 중심 아키텍처
다음 주차
