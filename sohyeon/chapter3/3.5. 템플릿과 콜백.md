## 3.5 템플릿과 콜백
지금까지 만든 코드는 일종의 전략 패턴이 적용된 것이다. <br/>
복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조이다. <br/>
전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다. 이런 방식을 스프링에서 **템플릿/콜백 패턴**이라고 부른다. <br/>
전략 패턴의 컨텍스트를 **템플릿**, 익명 내부 클래스로 만들어지는 오브젝트를 **콜백**이라고 부른다.

<br/>

### 3.5.1 템플릿/콜백의 동작원리
**템플릿**은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙인 이름이고, <br/>
**콜백**은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 말한다.

<br/>

> ***템플릿/콜백의 특징***

- 보통 **단일 메소드 인터페이스**를 사용한다. (특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문)
- 콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다고 보면 된다.
- 콜백 인터페이스의 메소드에는 보통 **파라미터**가 있는데, 템플릿의 작업 흐름 중 만들어지는 **컨텍스트 정보를 전달받을 때** 사용된다.

<br/>

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/d2cc1306-559f-4ec5-9e23-0ae409ab1abf)

- 위 그림은 템플릿/콜백 패턴의 일반적인 작업 흐름이다.
- 클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백에 참조할 정보를 제공하는 것이다. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다.
- 템플릿은 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에게 돌려준다.
- 템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행한다. 경우에 따라 최종 결과를 클라이언트에게 다시 돌려주기도 한다.
- 템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법으로 이애할 수 있다.
- 다만 이 패턴에 녹아 있는 전략 패턴과 수동 DI를 이해할 수 있어야 한다.

<br/>

> ***JdbcContext에 적용된 템플릿/콜백***

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/39c34452-eccc-41e9-af83-30e5b4fc2dbb)

- 위 그림은 UserDao, JdbcContext를 템플릿/콜백 패턴의 구조에서 살펴본 것이다.
- 템플릿과 클라이언트가 메소드 단위인 것이 특징이다.
- JdbcContext의 workWithStatementStrategy() 템플릿은 리턴 값이 없는 단순한 구조다. 조회 작업에서는 보통 템플릿의 작업 결과를 클라이언트에 리턴해준다.
- 템플릿의 작업 흐름이 좀 더 복잡한 경우에는 한 번 이상 콜백을 호출하기도 하고 여러 개의 콜백을 클라이언트로부터 받아 사용하기도 한다.

<br/>

### 3.5.2 편리한 콜백의 재활용
템플릿/롤백 방식은 클라이언트인 DAO의 메소드는 간결해지고 최소한의 데이터 액세스 로직만 갖고 있게 된다. <br/>
하지만 DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 코드를 작성하고 읽기가 조금 불편하다는 것이 아쉽다.

<br/>

> ***콜백의 분리와 재활용***

🔽 익명 내부 클래스를 사용한 클라이언트 코드
```java
public void deleteAll() throws SQLException {
  this.jdbcContext.workWithStatementStrategy(
    // 변하지 않는 콜백 클래스 정의와 오브젝트 생성
    new StatementStrategy() {
      public PreparedStatement makePreapredStatement(Connection c) throw SQLException {
        return c.preparedStatement("delete from users"); // 변하는 SQL 문장
      }
    }
  );
}
```
- 콜백 오브젝트 코드를 살펴보면, 고정된 SQL 쿼리 하나를 담아서 PreparedStatement를 만드는 것이 전부다.
- deleteAll()과 유사한 내용의 콜백 오브젝트가 반복될 가능성이 높다.

<br/>

🔽 변하지 않는 부분을 분리시킨 deleteAll() 메소드
```java
public void deleteAll() throws SQLException {
  executeSql("delete from users"); // 변하는 SQL 문장
}
/** ** ** 분리 ** ** **/
private void executeSql(final String query) throws SQLException {
  this.jdbcContext.workWithStatementStrategy(
    // 변하지 않는 콜백 클래스 정의와 오브젝트 생성
    new StatementStrategy() {
      public PreapredStatement makePreparedStatement(Connection c) throws SQLException {
        return c.prepareStatement(query);
      }
    }
  );
}
```
- 중복될 가능성이 있는 자주 바뀌지 않는 부분을 분리한다.
- 단순 SQL을 필요로 하는 콜백이라면 나머지 코드는 매번 동일할 것이므로 SQL 문장과 메소드 내용을 분리한다.
- 바뀌지 않는 모든 부분은 executeSql() 메소드로 빼내고, 바뀌는 부분인 SQL 문장만 파라미터로 받아서 사용하도록 만들었다.
- 파라미터는 final로 선언해서 콜백(익명 내부 클래스) 안에서 직접 사용할 수 있게 해주어야 한다.

<br/>

> ***콜백과 템플릿의 결합***

🔽 JdbcContext로 옮긴 executeSql() 메소드
```java
public class JdbcContext {
  ...
  public void executeSql(final String query) throws SQLException {
    workWithStatementStrategy(
      new StatementStrategy() {
        public PreapredStatement makePreparedStatement(Connection c) throws SQLException {
          return c.prepareStatement(query);
        }
      }
    );
  }
  ...
}
```
- 재사용 가능한 콜백을 담고 있는 메소드라면 (UserDao 외에도) DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도 된다.
- 템플릿은 workWithStatementStrategy() 메소드이므로 executeSql() 메소드를 JdbcContext로 옮겨도 문제 없다.
- 메소드 접근자는 public으로 바꿔 외부에서 접근 가능하도록 한다.

<br/>

🔽 JdbcContext로 옮긴 executeSql()을 사용하는 deleteAll() 메소드
```java
public void deleteAll() throws SQLException {
  this.jdbcContext.executeSql("delete from users");
}
```
- UserDao의 메소드에서도 jdbcContext를 통해 executeSql() 메소드르 호출하도록 수정한다.

<br/>

![image](https://github.com/Team-Sopetit/server-spring-study/assets/55437339/84f1c3ca-5a72-4637-a012-93853487798c)

- 결국 JdbcContext 안에 클라이언트와 템플릿, 콜백이 모두 함께 공존하면서 동작하는 구조가 됐다.
- 하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 **응집력이 강한 코드**들이기 때문에 한 군데 모여 있는 게 유리하다.
- 구체적인 구현과 내부의 기술은 최대한 감춰두고, 외부에는 꼭 필요한 기능을 제공하는 단순한 메소드만 노출해주는 것이다.

<br/>

### 3.5.3 템플릿/콜백의 응용
