지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 여러 종류의 기술을 추상화하는지를 알아볼 것이다.

## 5.1 사용자 레벨 관리 기능 추가

- 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다.
- 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
- 가입 후 50회 이상 로그인을 하면 8ASIC에서 SILVER 레벨이 된다.
- SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
- 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

### 5.1.1 필드 추가

**Level 이늄**

각 레벨을 코드화해서 숫자로 넣는 것을 첫번째로 잡아보겠다.

```java
class User {
    private static final int BASIC = 1;
    private static final int SILVER = 2;
    private static final int GOLD = 3;

    private int level;

    public void setLevel(int level) {
        this.level = level;
    }
}
```

문제점

1. 레벨이 엉뚱하게 바뀌는 버그가 만들어질 수 있음
2. 범위를 벗어나는 값을 넣을지도 모름

그래서 자바 5에서 제공하는 이늄을 사용한다.

사용코드

```java
package springbook.user.domain;

public enum Level {
    BASIC(1), SILVER(2), GOLD(3);

    private final int value;

    Level(int value) {
        this.value = value;
    }

    public int intValue() {
        return value;
    }

    public static Level valueOf(int value) {
        switch (value) {
            case 1:
                return BASIC;
            case 2:
                return SILVER;
            case 3:
                return GOLD;
            default:
                throw new AssertionError("Unknown value: " + value);
        }
    }
}
```

이렇게 만들면 Level 이늄은 내부에서 DB에 저장할 값을 가지고 있지만 겉으로는 Level타입의 오브젝트라 안전하게 사용이 가능하며 범위를 넘는 값이 들어오면 컴파일러가 에러를 내면서 걸러줄 것이다.

**UserDaoTest 테스트 수정**

```java
User user1 = new User("gyumee", "박성철", "springno1", Level.BASIC, 1, 0);
User user2 = new User("leegw700", "O|29", "springno2", Level.SILVER, 55, 10);
```

추가된 필드를 파라미터로 포함하는 생성자 코드를 작성하고 검증용 필드를 추가해서 DAO 테스트 기능을 보완한다.

원래는 asserThat을 사용했지만 로직을 일정하게 유지할 수 있도록 수정한다.

수정코드

```java
@Test public void addAndGet() {
    User userget1 = dao.get(user1.getId());
    checkSameUser(userget1, user1);

    User userget2 = dao.get(user2.getId());
    checkSameUser(userget2, user2);
}
```

**UserDaoJdbc 수정**

INSERT 문장이 들어 있는 add() 메소드의 SQL과 각종 조회 작업에 사용되는 User 오브젝트 매핑용 콜백인 userMapper에 추가된 필드를 넣는다.

```java
public class UserDaoJdbc implements UserDao {
    private RowMapper<User> userMapper = new RowMapper<User>() {
        @Override
        public User mapRow(ResultSet rs, int rowNum) throws SQLException {
            User user = new User();
            user.setId(rs.getString("id"));
            user.setName(rs.getString("name"));
            user.setPassword(rs.getString("password"));
            user.setLevel(Level.valueOf(rs.getInt("level")));
            user.setLogin(rs.getInt("login"));
            user.setRecommend(rs.getInt("recommend"));
            return user;
        }
    };

    public void add(User user) {
        this.jdbcTemplate.update(
            "INSERT INTO users(id, name, password, level, login, recommend) VALUES (?, ?, ?, ?, ?, ?)",
            user.getId(), user.getName(), user.getPassword(), user.getLevel().intValue(),
            user.getLogin(), user.getRecommend()
        );
    }
}
```

여기는 DB에 저장 가능한 정수형 값으로 변환해줘야 한다. 그리고 각 Level 이늄의 DB 저장용 값을 얻기 위해서는 Level에 미리 만들어둔 intValue() 메소드를 사용한다.

조회를 했을 경우, ResultSet에서는 DB의 타입인 int로 level 정보를 가져온다. 이 값을 User의 setLevel() 메소드에 전달하면 타입이 일치하지 않는다는 에러가 발생한다.

→ Level의 스태틱 메소드인 valueOf()를 이용해 int 타입의 값을 Level 타입 이늄 오브젝트로 만들어서 setLevel() 메소드에 넣어줘야한다.

```java
org.springframework.jdbc.BadSqlGrammarException:
```

의도적으로 잘못된 필드 이름을 넣은 것으로 인해 발생한 오류이다.

결국 테스트코드를 잘 작성했기 때문에 이런 오류를 바로 찾아낼 수 있었던 것이다.!!

### 5.1.2 사용자 수정 기능 추가

id를 제외하고는 변경될 가능성이 있기 때문에 다른 필드는 수정이 가능하게 DAO 메서드를 만들어야한다.

**수정 기능 테스트 추가**

픽스처에 들어 있는 정보를 변경해서 수정 메소드를 호출한다.

→ 내용을 직접 변경해도 상관없다.

**UserDao와 UserDaoJdbc 수정**

만들고 나면 dao 변수의 타입인 UserDao 인터페이스에 update() 메소드가 없다는 컴파일 에러가 날 것이다. IDE의 자동수정 기능을 이용해 UserDao 인터페이스에 update() 메소드를 추가한다.

자동수정 기능은 컴파일 에러가 발생하면 Ctrl + 1을 사용해 내용 선택이 가능함! 개꿀팁

update() 메소드는 add()와 비슷한 방식으로 만들면 된다.

**수정 테스트 보완**

현재 update() 테스트는 수정할 로우의 내용이 바뀐 것만 확인할 뿐이지, 수정하지 않아야 할 로우의 내용이 그대로 남아있는 지는 확인하지 못하는 문제가 있다.

해결방법

1. JdbcTemplate의 update()가 돌려주는 리턴 값을 확인하는 것이다.
2. 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것이다.

### 5.1.3 UserService.upgradeLevels()

사용자 관리 비즈니스 로직을 담을 클래스를 하나 추가하자 UserService를 만들어서 추가할 것이다.

만들때는 UserService는 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 해야 한다.

레벨 의존관계를 보면

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0da01a99-5a0d-45ba-9b0f-4138668967c6/2e16817f-325b-426d-819f-0e06d9ef5b5e/Untitled.png)

**UserService 클래스와 빈 등록**

UserDao 오브젝트의 DI가 가능하도록 수정자 메소드도 추가한다.

```java
package springbook.user.service;

public class UserService {
    UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

이후 스프링 설정파일에 들어가 userService 아이디로 빈을 추가한다. userDao 빈을 받도록 프로퍼티를 추가해준다.

**UserServiceTest 테스트 클래스**

UserServiceTest 클래스를 추가하고 테스트 대상인 Userservice 빈을 제공받을 수 있도록 @Autowired가 붙은 인스턴스 변수로 선언해준다.

**upgradeLevels() 메소드**

레벨 관리 기능을 먼저 만들고 테스트를 만들어볼 것이다.

```java
public void upgradeLevels() {
    List<User> users = userDao.getAll();
    for (User user : users) {
        boolean changed = false; // 레벨의 변화가 있는지를 확인하는 플래그
        if (user.getLevel() == Level.BASIC && user.getLogin() > 50) {
            user.setLevel(Level.SILVER); // BASIC 레벨 업그레이드 작업
            changed = true; // 레벨 변경 플래그 설정
        } else if (user.getLevel() == Level.SILVER && user.getRecommend() >= 30) {
            user.setLevel(Level.GOLD); // SILVER 레벨 업그레이드 작업
            changed = true; // 레벨 변경 플래그 설정
        }
        // GOLD 레벨은 변경이 일어나지 않는다
        // 레벨의 변경이 있는 경우에만 update() 호출
        if (changed) {
            userDao.update(user);
        }
    }
}
```

오히려 뛰어난 개발자이기 때문에 간단해 보여도 테스트를 만들어 직접 동작하는 것을 확인해야만 한다.

### 5.1.4 UserService.add()

레벨이 이미 설정되어 있다면 그대로 유지해야 하고 아니라면 BASIC으로 설정되게 해야한다.

사용자 관리에 대한 비즈니스 로직을 담고 있는 UserService에 이 로직을 넣는 것이 좋다

어… 페이지가 없구만

### 5.1.5 코드 개선

작성된 코드를 살펴볼 때는 다음과 같은 질문을 해야한다.

- 코드가 중복된 부분은 없는가?
- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

**upgradeLevels() 메소드 코드의 문제점**

**upgradeLevels() 리팩토링**

**UserServiceTest 개선**

**User 테스트**

전반적인 코드 리펙토링에 대한 이야기라 읽고 넘어가긴 했음;;
