## 들어가며

스프링이 개발자에게 제공하는 가장 중요한 가치를 객체지향과 테스트라고 할 수 있다.

애플리케이션은 계속해서 변해간다.

이를 대응하기 위한 전략으로는

1. 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술
2. 만들어진 코드를 확실할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술

2장의 주요 내용은 테스트란 무엇이며 가치와 장점, 활용 전략, 스프링과의 관계를 살펴 본다.

## 2.1 UserDaoTest 다시 보기

### 2.1.1 테스트의 유용성

1장에서 만들었던 초난감 UserDao의 클래스를 책임에 따라 분리하고 인터페이스를 도입하며 오브젝트 팩토리를 통해 생성했다.

분리하기 전과 같은 기능을 제공한다는 것을 확신하는 방법이 바로 테스트 코드의 작성이라고 볼 수 있다.

### 2.1.2 UserDaoTest의 특징

2-1 코드

```java
public class UserDaoTest {
    public static void main(String[] args) throws SQLException { 
        ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

        UserDao dao = context.getBean("userDao", UserDao.class);

        User user = new User();
        user.setId("user");
        user.setName("최승빈");
        user.setPassword("married");

        dao.add(user);

        System.out.println(user.getId() + "등록 성공");

        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());

        System.out.println(user.getId() + "조회 성공");
    }
}
```

정리하면

- 자바에서 가장 손쉽게 실행 가능한 main() 메서드를 이용
- 테스트할 대상인 UserDao의 오브젝트를 가져와 메서드를 호출
- 테스트에 사용할 입력 값을 직접 코드에서 만들어 넣어줌
- 테스트의 결과를 콘솔에 출력한다.
- 각 작업이 에러 없이 끝나면 성공 메시지 출력

웹을 통한 DAO 테스트 방법의 문제점

우리가 흔히 쓰는 방법처럼 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만, 테스트로서는 단점이 많다.

단점

- 모든 레이어의 기능을 다 만들고 나서야 테스트가 가장하다.
- 또한 에러가 발생하면 어디서 문제가 발생했는지를 찾아야 한다.

즉, 어떤 게 문제일지 찾는 과정이 너무 번거롭다는 것이다.

**작은 단위의 테스트**

단위 테스트 (unit test) : 작은 단위의 코드에 대해 테스트를 수행한 것

작은 단위 → 정해진 건 아니지만 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위

DB의 상태가 매번 달라지고, 테스트를 위해 DB를 특정 상태로 만들어줄 수 없다면 단위 테스트로서의 가치가 없어진다.

단위 테스트를 하는 이유 : 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인 받기 위해서

**자동수행 테스트 코드**

장점 : 자주 반복할 수 있음.

번거로운 작업이 없고 테스트를 빠르게 실행할 수 있기 때문에 코드를 수정하고 나서 테스트를 해 볼 수 있다.

**지속적인 개선과 점진적인 개발을 위한 테스트**

단순 무식한 방법으로 정상동작하는 코드를 만들고, 테스트를 만들어뒀기 때문에 매우 작은 단계를 거쳐가면서 계속 코드를 계선한다.

→ 오히려 작은 단계를 거치는 동안 테스트를 수행해서 확신을 가지고 코드를 변경해갔기에 전체적으로 코드를 개선하는 작업에 속도가 붙고 더 쉬워졌다.

→ 테스트를 이용하면 새로운 기능도 확인할 수 있음.

→ 뿐만 아니라 수정한 코드에 영향을 받지 않고 기존 기능이 동작하는 지 테스트할 수 있음.

~~1장에서 한 자신의 코드의 발전과정을 찬양하고 있다.~~

### 2.1.3 UserDaoTest의 문제점

1. 수동 확인 작업의 번거로움
- 테스트의 결과를 수동으로 확인하는 건 사람이기에 완전치 자동으로 테스트되는 방법이라고 말할 수가 없다.
1. 실행 작업의 번거로움
- 지금은 간단해도 main 메서드가 수백 개가 된다면 너무 수고스러워진다.

→ 즉 main메서드를 이용하는 방법보다 조금 더 편리하고 체계적으로 테스트를 실행하고 확인하는 과정이 필요하다.

## 2.2 UserDaoTest 개선

### 2.2.1 테스트 검증의 자동화

테스트의 결과에 대해 생각해보면

성공과 실패 두 가지의 결과를 가질 수 있다. 또한 테스트가 진행하는 동안에 에러가 발생해서 실패한 것과 테스트는 통과했지만 결과가 다르게 나온 것으로 구분할 수 있다.

기존의 코드에서 테스트 코드에서 결과를 직접 확인하고 기대한 결과와 달라서 실패하면 테스트 실패 작업을 통과하면 테스트 성공이라고 출력하게 바꾸었다.

바꾼 코드

```java
if (!user.getName().equals(user2.getName())){
	System.out.println("테스트 실패 (name)");
}
else if(!user.getPassword().equals(user2.getPassword())){
	System.out.println("테스트 실패 (password)");
} 
else{
	System.out.println("조회 테스트 성공");
}
```

이렇게 해서 테스트의 수행 테스트 값 적용, 결과까지 검증을 자동화했다.

→ 새로 도입한 기술의 적용에 문제가 없는지 확인할 수 있는 가장 좋은 방법은 제대로 된 테스트를 만들어두는 것이다.

### 2.2.2 테스트의 효율적인 수행과 결과 관리

main() 메소드만으로 생기는 부담을 해결하기 위해 JUnit을 사용할 것이다.

**JUnit 테스트로 전환**

이 프레임워크에서 동작하는 코드는 main() 메서드도 필요 없고 오브젝트를 만들어서 실행시킬 필요도 없다.

**테스트 메소드 전환**

테스트가 main()메서드로 만들어져 제어권을 가지는 것은 적합하지 않다. 그렇기에 일반 메소드로 옮겨야한다.

새로 만들 테스트 코드에서는

1. 메소드가 public으로 선언돼야 한다.
2. 메소드에 @Test라는 어노테이션을 붙여줘야 한다.

**검증 코드 전환**

if문장의 기능을 JUnit이 제공해주는 asswerThat이라는 스택틱 메소드를 이용해 다음과 같이 변경할 수 있다.

```java
if (!user.getName().equals(user2.getName())) { ... }
```

변경 후 

```java
assertThat(user2.getName(), is(user.getName()));
```

첫 번쨰 파라미터의 값을 뒤에 나오는 매처라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고 아니면 테스트를 실패하게 만들어준다.

**JUnit테스트 실행**

테스트를 실행하면 테스트 결과 , 그리고 몇 개의 테스트 메소드가 실행됐는지를 알려준다.

만약 코드에 이상이 있을 경우 OK 대신 FAILURES를 출력하고 몇 개의 테스트가 실패했는지 보여준다.

또한 기대한 값이 아니면 AssertionError를 던진다.

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

JUnit은 표준 테스팅 프레임워크라고 불릴 만큼 사용하고 있고 여러가지 테스트 지원 기능을 내장하고 있어 알아두면 좋다!

### 2.3.1 JUnit 테스트 실행 방법

가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.

IDE

JUnit은 한 번에 여러 테스트 클래스를 동시에 실행할 수 있다.

또한 테스트의 실행과 그 결과를 확인하는 방법이 매우 간단하고 직관적이며 소스와 긴밀하게 연동돼서 결과를 볼 수 있다.

빌드 툴

만약 여러 개발자들이 만든 코드를 모두 통합해서 테스트를 수행해야 한다면 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과를 메일 등으로 통보받는 방법을 사용하면 된다.

### 2.3.2 테스트 결과의 일관성

지금의 문제는 테스트를 하기 전에 DB의 USER 테이블을 모두 삭제해 줘야 한다.. 아주 불편!

일관성 있는 결과의 테스트를 만들기 위해 첫 번쨰로 deleteAll() 메소드로 USER 테이블의 모든 레코드를 삭제해주는 기능을 적용한다.

```java
public void deleteAll() throws SQLException {
	Connection c = dataSource.getConnection();

	PreparedStatement ps = c.prepareStatement("delete from users");
	
	ps.executeUpdate();

	ps.close();
	c.close();
}
```

두 번째로 getCount() 메소드로 USER 테이블의 레코드 개수를 돌려준다.

```java
public int getCount() throws SQLException {
	Connection c = dataSource.getConnection();

	PreparedStatement ps = c.prepareStatement("select count(*) from users");

	ResultSet rs = ps.executeQuery();
	rs.next();
	int count = rs.getInt(1);

	rs.close();
	ps.close();
	c.close();

	return count;
}    
```

이 두가지를 andAndGet()에 사용하고 싶지만 아직 검증이 안된 상태이다. 그렇기에 이 두 가지를 적용해 add()후에는 0에서 1로 deleteAll()후에는 0이 나온다면 우선 어느정도는 검증이 된 것이다.

**동일한 결과를 보장하는 테스트**

deleteAll()을 코드 앞쪽에 위치하는 것이 좋다. add() 뒤에 넣으면 이미 데이터가 있을 경우 에러가 생길 수도 있기 때문에 앞쪽에 배치한다.

### 2.3.3 포괄적인 테스트

현재의 코드에서 더 바뀔 필요가 있다. getCount()가 잘 되는 지를 테스트를 위해 유저 3명을 넣으면서 값이 add()한 유저 수에 맞춰 올라가는 지 체크한다.

지금은 잘 나오지만 id값을 가져와서 확실하게 가져온 유저가 맞는 지 확인해야 한다.

그렇기에 User를 add()하고 각 User의 id를 파라미터로 전달해서 get()을 실행하도록 만든다.

다음 테스트는 없는 아이디를 조회하면 예외가 나오게 해야한다. 스프링의 예외를 사용했는데 이럴 경우에 예외 발생 여부는 메소드를 실행해서 리턴 값을 비교하는 방법으로 확인할 수 없다는 것이다

그렇기에 사용하는 방법이 있다.

@Test에 expected를 추가한다.

- 정상적으로 테스트 메소드를 마치면 테스트가 실패한다.
- expected에서 지정한 예외가 던져지면 테스트가 성공한다.

예외가 반드시 발생해야 하는 경우를 테스트하고 싶을 때 유용하게 쓸수 있는 어노테이션이다.

테스트를 성공시키기 위한 코드의 수정

```java
public User get(String id) throws SQLException {

...
	ResultSet rs = ps.executeQuery();

	User user = null;
	
	if(rs.next()){
		user = new User();
		user.setId(rs.getString("id"));
		user.setName(rs.getString("name"));
		user.setPassword(rs.getString("password"));
	}

	rs.close();
	ps.close();
	c.close();

	if(user == null) throw new EmptyResultDataAccessException(1);

	return user;
}
```

이 코드는 테스트에 통과된다.

이를 통해 지금까지 설계한 테스트가 전부 성공했고 이것이 기존의 기능에 영향을 주지 않음을 깨달았다.

**포괄적인 테스트**

개발자들이 당연하게 자기 코드가 돌아가는 테스트로 구성하려는 경향이 있다.

스프링의 창시자인 로드 존슨은 “항상 네거티브 테스트를 먼저 만들라”고 말했다.

테스트코드를 작성하기 이전에 부정적인 케이스를 먼저 만드는 습관을 가져야 한다고 합니다

### 2.3.4 테스트가 이끄는 개발

TDD에 대한 설명인 거 같다.

테스트 코드를 먼저 작성하고 개발을 진행하는 개발 전략이 존재한다.!

**기능설계를 위한 테스트**

만들어진 코드를 보고 어떻게 테스트를 할까?보다 추가하고 싶은 기능을 먼저 코드로 표현했기에 지금의 방식이 가능했다.

추가하고 싶은 기능을 일반 언어가 아닌 테스트 코드로 표현해 설계문으로 만들면 기능을 개발하면서 테스트 코드 기능 둘 다 가져갈 수 있다.

**테스트 주도 개발**

테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 방법을 TDD라고 한다.

TDD는 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 기본 원칙이다.

우리의 문제이자 대부분 개발자들이 TDD를 하지 않게 되는 이유..

- 시간이 많이 지나면 테스트를 만들기가 귀찮아진다는 점
- 작성한 코드가 많기 때문에 손을 대기가 힘들다.

TDD는 테스트를 먼저 만들고 그 테스트가 성공하도록 만들어 나아가기 떄문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다

TDD에서는 테스트를 작성하고 성공시키는 코드를 만드는 작업의 주기를 가능 한 한 짧게 가져가도록 권장한다.

TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점이다. → 단위 테스트를 통해

원래는 실제로 테스트 코드 작성이 어렵기도 했지만 지금의 스프링은 괜찮다고 합니다.

스프링이 제공하는 각종 테스트 지원 기능에 대해서는 이 책 전반에 걸쳐 계속 설명해 준다고 합니다. → 어서 빨리 소현이 따라 테스트 코드 시작해야 할듯

### 2.3.5 테스트 코드 개선

원래는 중복되는 코드는 메서드를 추출하여 작업하지만 테스트 코드는 다르다

@Before을 사용하기 때문에~

**JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 순서**

1. 테스트 클래스에서 @Test가 붙은 public이고 vold형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

**생각해 볼 만한 부분**

1. @Before, After가 붙은 메서드와 주고 받을 정보가 있으면 인스턴스 변수를 이용해야 한다.

2. 테스트 메서드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다. (테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장시켜주기 위해서)

테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 한다.


## 2.4 스프링 테스트 적용

현재는 애플리케이션 컨텍스트의 생성에 많은 시간이 쓰일 수도 있고 할당된 리소스를 깔끔하게 정리하지 않는다면 다음 테스트에서 문제가 생길 수도 있다.

### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 이를 적용시키도록 하자.

**스프링 테스트 컨텍스트 프레임워크 적용**

먼저 @Before 메소드에서 애플리케이션 컨텍스트를 생성하는 코드를 제거한다.

이후 ApplicationContext 타입의 인스턴스 변수를 선안한다.

또한 @Autowired 어노테이션을 붙여준다.

마지막으로 클래스 레벨에 @RunWith와 @ContextConfiguration 어노테이션을 추가한다.

이렇게 사용하면 context가 없음에도 테스트는 성공적으로 끝난다.

이미 애플리케이션 컨텍스트가 들어있기 떄문이다.

@RunWith 

- 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 한다.

@ContextConfiguration

- 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한다.

**테스트 메소드의 컨텍스트 공유**

스프링의 JUnit의 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 애플리케이션 자신을 테스트 오브젝트의 특정 필드에 주입해준다.

→ 이를 통해 하나의 테스트 클래스 내의 테스트 메소드는 같은 애플리케이션 컨텍스트를 공유해서 사용할 수 있다고 볼 수 있다.

**테스트 클래스의 컨텍스트 공유**

이 뿐만이 아니라 두 개의 테스트 클래스가 같은 설정파일을 사용하는 경우에도 단 한 개의 애플리케이션 컨텍스트만 만들어지고 공유하게 되는 것이다.

@Autowired가 붙은 인스턴스 변수가 있으면 변수타입과 일치하는 컨텍스트 내의 빈을 찾는다. 또한 타입이 일치한다면 인스턴스 변수에 주입해주기도 한다. 메소드가 없어도 주입이 가능하다. : 자동와이어링

애플리케이션 컨텍스트를 DI 받아서 다시 DL 방식으로 UserDao를 가져올 때보다 → @Autowired을 사용할 때가 훨씬 코드적으로 깔끔해진다.

다만 타입의 빈이 두 개 이상 있으면 어떤 빈을 가져올지 결정할 수는 없다.

즉 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.

DataSource에 정의된 메소드를 테스트에서 사용하고 싶다면 사용하고 클래스의 메소드를 직접 이용해서 테스트를 해야하는 경우에는 SimpleDriverDataSource를 사용한다.

### 2.4.2 DI와 테스트

어쨰서 우리는 SimpleDriverDataSource를 선언해서 사용하는 것이 아닌 DataSource 인터페이스를 사용하고 DI를 통해 주입해주는 방식을 사용하는가?

1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.
    - 클래스 대신 인터페이스를 사용하고 new를 이용해 생성하는 대신 DI를 통해 주입받는 것이 수정에 용이하다.
2. DI를 적용하게 해두면 다른 차원의 서비스 기능의 도입이 가능하다.
    - 1장에서 DB 커넥션의 개수를 카운팅하는 부가기능을 추가했던 것이 그 예다.
3. 테스트를 손쉽게 만들기 위해서도 필요하다.

**테스트 코드에 의한 DI**

테스트 코드에 의한 DI를 이용해서 테스트 중에 DAO가 사용할 DataSource 오브젝트를 바꿔주는 방법을 이용하면 된다. 

1. 가장 빠른 DataSource인 SingleConnectionDataSource를 사용한다.
2. @Before 메소드에서 테스트용 오브젝트를 생성한다.
3. 애플리케이션 컨텍스트에서 가져온 dao오브젝트의 메소드를 통해 Di해준다.

이 방법의 장점은 설정파일을 수정하지 않고도 테스트 코드만으로 오브젝트 관계를 재구성할 수 있다는 것이다.

현재에서의 빈의 의존관계를 변경하는 문제는 @DirtiesContext를 이용하면 당장은 해결이 가능하다.

수동 DI를 적용한 UserDaoTest


```
@DirtiesContext
public class UserDaoTest {

    @Autowired
    private UserDao dao;

    @Before
    public void setUp() {
        DataSource dataSource = new SingleConnectionDataSource(
                "jdbc:mysql://localhost/testdb", "spring", "book", true);
        dao.setDataSource(dataSource);
    }
```

**테스트를 위한 별도의 DI 설정** 

결국 설정파일을 공유해서 쓰는 것이 아닌 테스트용 xml을 만드는 것이 답이다

@DirtiesContext도 필요가 없다.

**컨테이너 없는 DI 테스트**

스프링 컨테이너를 이용해서 IoC 방식으로 생성되고 DI 되도록 하는 대신, 테스트 코드에서 직접 오브젝트를 만들고 DI 해서 사용한다.

@ReunWith를 사용해서 스프링 테스트 컨텍스트 프레임워크를 적용하지도 않았고, @Autowired를 사용해서 애플리케이션 컨텍스트에서 UserDao를 가져오지도 않았다. 대신 Before메소드에서 직접 UserDao의 오브젝트를 생성하고 테스트용 DataSource 오브젝트를 만들어 DI를 해줬다.

침투적 기술: 특정 인터페이스나 클래스를 사용하도록 강제하는 기술

비침투적인 기술: 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능하다.

- 스프링이 대표적인 예시이다.

**DI를 이용한 테스트 방법 선택**

1. 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 우선적으로 고려해야 한다.
2. 복잡한 의존관계를 갖고 있는 오브젝트는 스프링 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다.
3. 테스트에서 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정파일을 만들어 사용하는 편이 좋다.
4. 예외적인 의존관계를 강제로 구성해서 테스트해야 하는 경우는 DI 받은 오브젝트에 다시 수동 DI해서 테스트하는 방법을 사용하면 된다. @DirtiesContext은 꼭 붙이도록 할 것

## 2. 5 학습 테스트로 배우는 스프링

학습 테스트: 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성하는 것

학습테스트의 목적

1. 자신이 테스트를 만들려고 하는 기술이나 기능에 대해 얼마나 제대로 이해하고 있는지, 그 사용 방법을 바로 알고 있는지를 검증하려는 것
2. 테스트 코드를 작성해보면서 빠르고 정확하게 사용법을 익히는 것

→ 학습 테스트는 테스트 대상보다는 테스트 코드 자체에 관심을 갖고 만들어야 한다.

### 2.5.1 학습 테스트의 장점

1. 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
2. 학습 테스트 코드를 개발 중에 참고할 수 있다.
3. 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
4. 테스트 작성에 대한 좋은 훈련이 된다.
5. 새로운 기술을 공부하는 과정이 즐거워진다.

스프링 자신에 대한 테스트 코드를 작성하는 것도 좋은 공부방법이다.

### 2.5.2 학습 테스트 예제

**JUnit 테스트 오브젝트 테스트**

테스트 메소드를 수행할 때마다 새로운 오브젝트를 만든다고 한 것을 검증해보자

테스트 방법 순서

1. 새로운 테스트 클래스를 만든다.
2. 다른 이름으로 세 개의 테스트 메소드를 추가한다.
3. 테스트 클래스 자신의 타입으로 스태틱 변수를 하나 선언한다.
4. 오브젝트와 비교를 하며 같지 않다는 것을 확인한다.

아래는 테스트 방법 순서에 맞춰 작성한 코드이다.

```java
package springbook.learningtest.junit;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.sameInstance;
import static org.junit.Assert.assertThat;

import org.junit.Test;

public class JUnitTest {

    static JUnitTest testObject;

    @Test
    public void test1() {
        assertThat(this, is(not(sameInstance(testObject))));
        testObject = this;
    }

    @Test
    public void test2() {
        assertThat(this, is(not(sameInstance(testObject))));
        testObject = this;
    }

    @Test
    public void test3() {
        assertThat(this, is(not(sameInstance(testObject))));
        testObject = this;
    }
}
```

지금은 직전의 테스트 오브젝트만 비교한다. 이것또한 검증해야 하기에 코드를 수정한다.

모든 테스트 오브젝트를 검증하는 코드이다.

```java
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.MatcherAssert.assertThat;

import java.util.HashSet;
import java.util.Set;

import org.junit.Test;

public class JUnitTest {

    static Set<JUnitTest> testObjects = new HashSet<>();

    @Test
    public void test1() {
        assertThat(testObjects, not(hasItem(this)));
        testObjects.add(this);
    }

    @Test
    public void test2() {
        assertThat(testObjects, not(hasItem(this)));
        testObjects.add(this);
    }

    @Test
    public void test3() {
        assertThat(testObjects, not(hasItem(this)));
        testObjects.add(this);
    }
}
```

**스프링 테스트 컨텍스트 테스트**

JUnit과 반대로 스프링의 테스트용 애플리케이션 컨텍스트는 테스트 개수에 상관없이 한 개만 만들어진다.

1. JUnitTest에 @RunWith와 @ContextConfiguration 애노테이션을 추가한다.
2. @Autowired로 주입된 context 변수가 같은 오브젝트인지 확인하는 코드를 추가한다.

검증 로직을 만드는 방법

1. asserThat()과 is()를 적절히 사용해서 검증하는 방법이다.
2. 조건문을 받아서 그 결과가 true인지 false인지를 확인하도록 만들어진 메소드를 사용한다.
3. awwerThat()과 새롭게 nullValue()를 함께 사용해서 확인한다.

→ 어떤 기술이든 마찬가지지만 스프링은 실전에 적용하기 전에 스프링의 기능을 사용한 테스트를 가능한 한 많이 만들어보는 것이 좋다.

### 2.5.3 버그 테스트

→ 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트

버스 테스트는 일단 실패하게 만든다음 버그 테스트가 성공하도록 애플리케이션 코드를 수정하는 과정을 거친다.

버그 테스트의 장점

1. 테스트의 완성도를 높여준다.
2. 버그의 내용을 명확하게 분석하게 해준다.
3. 기술적인 문제를 해결하는 데 도움이 된다.

동등분할: 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트를 하는 방법을 말한다.

경계값 분석: 에러는 동등분할 범위의 경계에서 주로 많이 발생하다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법이다.

## 2.6 정리

- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- main() 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
- 테스트 결과는 일관성이 있어야 한다.
- 테스트는 포괄적으로 작성해야 한다.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용하다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.
