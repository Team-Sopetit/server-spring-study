# 4주차

## 3장 템플릿

- 템플릿이란?
    - 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법

### 다시 보는 초난감 DAO

- close()를 통해 빌린 책은 반납해줘야 한다.
- 계속 반납안하고 토비스프링 책을 빌리면 빌려줄 수가 없다
    - 장시간 운영되는 다중 사용자를 위한 서버에 심각한 오류 발생

```java
try {
	c = dataSource.getConnection();
	ps = c.prepareStatement("delete from users");
	ps.executeUpdate();
} catch(SQLException e) {
	throw e;
} finally {
	if (ps != null) {
		try {
			ps.close();
		} catch (SQLExecption e) {
		}
}
...
```

- ps.close()에서도 에러가 발생할 수 있기 때문에 잡아줘야 한다는 부분이 인상깊었다.
- 예외가 난 시점에 따라 c, ps가 null일 수도 있기 때문에 NullPointException을 방지하기 위해 null 여부를 확인해야한다.

- 뭔가 예외처리는 다 해줬는데 찝찝하다….?

### 변하는 것과 변하지 않는 것

**JDBC try/catch/finally 코드의 문제점**

- try/catch/finally가 2번 중첩, 모든 메소드마다 반복
    - 복붙? → 실수가 나올 가능성 up
    - 테스트를 통해 예외상황마다 리소스 반납 여부 체크? → 적용이 쉽지 않음
- 이 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.

**분리와 재사용을 위한 디자인 패턴 적용**

- 변하는 부분을 메소드 추출
    - 변하지 않는 부분이 변하는 부분을 감싸고 있어 반대로 생각
    - 쓸모 없는 짓을 했다.
- 템플릿 메소드 패턴의 적용
    - 상속을 통해 기능을 확장해서 사용하는 부분
    - 변하지 않는 부분 → 슈퍼 클래스, 변하는 부분 → 추상 메소드
    - 서브 클래스에서 이를 오버라이드해서 씀
    - 장점
        - 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있음.
        - 상위 DAO 클래스에 불필요한 변화가 생기지 않도록할 수 있으니 객체지향 설계의 핵심 원리인 개방 폐쇄 원칙(OCP)를 지키는 구조를 설계할 수 있다.
    - 단점
        - 접근에 대한 제한이 많다.
        - DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.
        - 확장 구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다.
- 전략 패턴의 적용
    - 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴
    - 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식
    - 변하지 않는 부분은 일정한 구조를 가지고 동작하다가 특정 확장 기능은 인터페이스를 통해 외부의 독립된 전략 클래스에 위임하는 것
    - 단점
        - 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서(OCP의 폐쇄 원칙) 전략을 바꿔 쓸 수 있다(OCP의 개방 원칙)는 것인데, 컨텍스트 안에서 이미 구체적인 전략 클래스를 사용하도록 고정되어 있다면 OCP의 원칙에 어긋난다.
        - 또한 컨텍스트가 인터페이스 뿐만 아니라 특정 구현 클래스(변하는 부분)에 대해 알고 있다는 것도 어색하다.
- DI 적용을 위한 클라이언트/컨텍스트 분리
    - Context가 어떤 전략을 사용하게 할 것인가는 앞단의 Client가 결정하는 게 일반적이다.
    - Client가 구체적인 전략(변하는 부분)의 하나를 선택하고 오브젝트를 만들어서 Context(변하지 않는 부분)에 전달한다. → 1장에서 했던 일과 동일하다.
    - DI가 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만드는 구조이다.

```java
public void deleteAll() throws SQLException {
	StatementStrategy st = new DeleteAllStatement();  // 선정한 전략 클래스의 오브젝트 생성
	jdbcContextWithStatementStrategy(st);  // 컨텍스트 호출, 전략 오브젝트 전달
}
```

- DI는 이렇듯 매우 작은 단위의 코드와 메소드 사이에서 일어나기도 한다.
- DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI라고 한다.
- 또한 코드에 의한 DI라는 의미로 수동 DI라고 부를 수도 있다.