# 25주차

## 자바 엔프라이즈 플랫폼과 스프링 애플리케이션

- 자바 엔터프라이즈 애플리케이션은 서버에서 동작하며 클라이언트를 상대로 서비스를 제공하도록 되어있다.
- 클라이언트의 요청을 받아서 그에 대한 작업을 수행하고 그 결과를 돌려주는 것이 기본적인 동작 방식이다.

### 클라이언트와 백엔드 시스템

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/d41f552b-a297-450d-9351-b047d8931cde/Untitled.png)

- 가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성이다.
- 자바 서버가 받아들일 수 잇는 방식으로 요청을 보내기만 한다면 어떤 종류의 클라이언트이든 상관없다.

### 애플리케이션 서버

- JavaEE 표준을 따르는 애플리케이션 서버
    - WAS
    - 경량급 WAS, 서블릿/JSP 컨테이너

- 경량급 WAS/서블릿 컨테이너
    - 스프링은 기본적으로 톰캣 같은 가벼운 서블릿 컨테이너만 있어도 충분하다.

- WAS
    - 관리 기능이나 모니터링 기능이 뛰어나서 여러 대의 서버를 동시에 운영할 때 유리한 점이 많다.

**스프링소스 tcServer**

- tcServer를 이용하면 기존 톰캣에서는 아쉬웠던 고급 서버 관리 기능, 배포 기능과 진단 기능을 포함해서 톰캣 전문가에게 받는 기술지원도 함께 제공받을 수 있다.

### 스프링 애플리케이션의 배포 단위

- 독립 웹 모듈
    - 스프링은 보통 war로 패키징된 독립 웹 모듈로 배포된다.
    - 톰캣 같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법이다.
- 엔터프라이즈 애플리케이션
    - 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해서 배포하는 것이다.
- 백그라운드 서비스모듈
    - rar 패키징 방법

## 개발도구와 환경

### JavaSE와 JavaEE

**JavaSE/JDK**

- 스프링 3.0은 JavaSE 5 버전에서 추가된 새로운 언어와 문법의 특징을 최대한 활용해서 개발됐기 때문에 기본적으로 JDK 5.0 또는 그 이상을 필요로 한다.

**JavaEE/J2EE**

- 스프링 3.0이 사용될 자바 엔터프라이즈 플랫폼으로는 J2EE 1.4 버전이나 JavaEE 5.0이 필요하다.

### IDE

- 이클립스
- 넷빈즈
- IntellijJ IDEA

# 27주차

### 오브젝트 중심 아키텍처

- 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것
- 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.
- 도메인 모델은 DB의 엔티티 설계에도 반영되기 떄문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다.
    - DB에는 없지만 비즈니스 로직에만 존재하는 모델도 있기 때문에 항상 일치하는 것은 아니다.
- 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것

**데이터와 오브젝트**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/b5534e4f-52d8-416e-8b2e-7bb3748d645c/Untitled.png)

- 카테고리 하나에는 여러 개의 상품이 포함된다.
- 전형적인  1:N의 관계

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/8848acea-3e78-4dcc-98f1-78363ee6df77/Untitled.png)

- 데이터 중심 아키텍처
    - SQL과 DB 관점에서 생각한다.

```sql
select c.categoryid, c.description, p.product.id, p.name, p.price from product p
join category c on p.categoryid = c.categoryid
```

- SQL 실행 코드

- DAO에서는 JDBC로 SQL을 실행하고 받은 결과를 서비스 계층으로 넘겨주는데 이 때 타입은 List<Map<String, Object>> 타입이다.
- 만약 DAO에서 SQL을 변경하거나 필드 개수나 순서, 이름을 바꾼다면 서비스 계층과 프레젠테이션 계층의 코드도 같이 변경돼야 한다.
- 또한 테이블의 관계 또한 알 수도 없다.
- SQL을 통해서 가공된 데이터으 구조를 알고, 이를 활용하는 것이 전부다.
- **데이터 중심의 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존하게 된다.**

- 반면에 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다.
- SQL이나 웹 페이지의 출력 포맷, 입력 폼 등에 종속되지 않는 일관된 형식의 애플리케이션 정보를 다룰 수 있게 된다.
- RDB에서는 테이블 간의 관계를 직접 명시하는 방법은 없고 키의 조합을 통해 그때그때 테이블을 조인해서 의미 있는 관계를 만들어내야 한다.
- 반면에 자바에는 관계하고 있는 다른 오브젝트와 직접 연결하는 방법이 있는데 레퍼런스 변수를 이용해서 다른 오브젝트를 참조하는 것이다.

- DAO는 자신이 DB에서 가져와서 도메인 모델 오브젝트에 담아주는 정보가 어떤 업무 트랜잭션에서 어떻게 사용될지는 신경 쓰지 않아도 된다.
- 서비스 계층 또한 DAO에서 어떤 SQL을 사용했는지는 몰라도 된다.
    - 필요한 정보를 조건에 맞게 조회해서 도메인 모델 오브젝트 형태로 돌려주는 DAO를 이용하기만 하면 된다.

**도메인 오브젝트를 사용하는 코드**

- 도메인 모델을 알고 있다면 특정 메소드가 어떤 작업을 하는지 이해하기 어렵지 않고 테스트를 통한 검증도 간단하고 로직 변경에 의한 코드 수정도 수월하다.
- 데이터 중심은 코드의 중복을 포함해서 복잡한 상황이 발생한다.

**도메인 오브젝트 사용의 문제점**

- 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수도 있다.
    - DAO는 비즈니스 로직의 사용 방식을 알지 못하므로, 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분이다.
    - 하나의 오브젝트에 담긴 필드의 개수가 많아지다 보면 그 중에는 드물게 사용되는 필드도 있을 수 있다.
- 오브젝트 관계에 있어서도 Product 정보만 필요한데 Category 정보가 딸려올 수도 있다.
    - Category를 빼고 가져올 수도 있지만 NPE의 위험도 있다.
    - 최적화를 고려해서 DAO를 작성하려면 DAO는 비즈니스 로직에서 각 오브젝트를 어디까지 사용해야 하는지 어느 정도 알고 있어야 하는데 이는 데이터 중심 접근 방법의 단점이라고 봤던, **DAO와 비즈니스 로직 코드의 결합도가 높아지는 문제**에 해당된다.

- 위 문제의 해결법
    - 지연된 로딩 (lazy loading)
        - 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우만 다이내믹하게 DB에서 다시 읽어올 수 있다.
    - 필드가 너무 많은 테이블이 있다면 자주 사용되는 것들만 모아 별도의 오브젝트로 정의해서 사용할 수 있다.
        - 어느 DAO를 사용할지를 서비스 계층에서 알고있어야 하기 때문에, 약하긴 하지만 계층 사이의 결합이 발생한다.
    - RDB 매핑 기술 (ORM)
        - 기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 번거로운 코드를 만들지 않고도 도메인 오브젝트의 생성을 최적화할 수 있다.
        - 값을 채우는 복잡한 DAO 코드를 만들지 않아도 된다.
        - 자주 변경되지 않으면서 많은 로직에서 참조하는 레퍼런스 테이블이 있다면 이를 ORM이 제공하는 오브젝트 캐시에 담아두고 사용할 수도 있다.
    
- 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용하는 것을 권장한다.
- 그런데 도메인 오브젝트는 자바 오브젝트다.
- 내부의 정보를 이용하는 기능도 함께 갖고 있어야 한다.
    - 클래스는 속성과 행위의 조합이다.
- 필드와 그에 대한 접근자, 수정자만 갖고 있는 오브젝트는 반쪽짜리다.
- 가능하다면 이를 더 적극적으로 활용하게 만들어야 한다.

**빈약한 도메인 오브젝트 방식**

- 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다.
- 도메인 오브젝트에 넣을 수 있는 기능은 어떤 것일까?
    - 도메인 모델을 반영해서 만들어진 것이니 그 기능이라고 하면 도메인의 비즈니스 로직이라고 볼 수 있다.
    - 빈약한 도메인 오브젝트 방식에서는 비즈니스 로직이 서비스 계층에 존재한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/de8d1837-954a-4c85-bfa5-b9dc1c97d296/Untitled.png)

- 도메인 오브젝트는 3개의 계층에는 독립적으로 존재하면서 일관된 구조의 정보를 담아서 계층 간에 전달하는 데 사용된다.

**풍성한 도메인 오브젝트 방식**

- 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것이다.
- 어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다.
    - 이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/b3e46852-9783-45e6-91b1-a2444fd72d26/Untitled.png)

- 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다.
- 서로 다른 비즈니스 로직을 담고 있는 서비스 오브젝트에서 위 기능이 필요하다면 Category 오브젝트만 이용하면 된다.
- 특정 도메인 오브젝트에 종속되는 비즈니스 로직은 서비스 계층의 오브젝트가 아니라 도메인 오브젝트 안에 넣으면 된다.

- 도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하기도 하다.
    - 스프링 컨테이너가 관리하는 오브젝트, 즉 빈이 아니기 때문이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/3a784ce3-00c3-4f1c-bcd6-82247bcb6799/Untitled.png)

- 서비스 계층은 도메인 오브젝트를 DB나 외부 리소스에서 가져오고 변경된 정보나 새로 등록된 정보를 DB에 반영하는 등의 작업과 함께 도메인 오브젝트가 갖고 있는 기능이 있다면 이를 활용해서 비즈니스 로직을 처리해야 한다.

**도메인 계층 방식**

- 도메인 오브젝트가 스스로 더 할 수는 없을까?
- 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 방식이다.
- 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다.
- 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다.
    - 여전히 도메인 오브젝트는 빈이 아니다.
    - DI를 적용한다. → AOP가 필요하다.
    - 스프링 AOP 대신 AspectJ AOP를 사용한다.
- 인터페이스 역할을 담당하거나 트랜잭션 경계를 설정하거나 특정 도메인 로직에 포함되지는 않지만 애플리케이션에서 필요로 하는 기반 서비스를 이용해야 하는 작업을 위해서 서비스 계층은 필요하다.
    - 복잡하지 않은 애플리케이션에서는 아예 서비스 계층을 제거해도 된다.
    - 이 때 트랜잭션 경계는 도메인 오브젝트의 메소드에 설정돼야 한다.

- 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할까?
    - 모든 계층에서 도메인 오브젝트를 사용한다.
        - 너무 위험하다.
        - 개발 정책을 두고 개발한다.
    - 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 한다.
        - DTO를 사용한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/432cf0f2-972f-494c-84b4-f2f19c8ff795/Untitled.png)

- 도메인 오브젝트는 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문에 해당 요청을 처리하고 나면 버려진다.
- 여러 스레드가 공유하는 싱글톤이 될 수가 없다.
- 매우 복잡하고 변경이 잦은 도메인을 가졌을 때 이 방식을 택한다.
- 도메인 계층은 응집도가 매우 높기 때문에 단위 테스트를 작성하기가 편리하다.

**DTO와 리포트 쿼리**

- DB 쿼리의 실행 결과를 담는 경우

### 스프링 애플리케이션을 위한 아키텍처 설계

**계층형 아키텍처**

- 스프링의 주요 모듈과 기술을 살펴보면 3계층 구조에 적합하도록 설계되어 있다.
- 논리적이고 개념적인 구분이므로 3계층에서 두 개의 계층이 통합돼서 하나의 오브젝트에 담기는 일도 얼마든지 가능하다.
    - 2계층으로 만든다면 서비스 계층과 데이터 액세스 계층을 통합하는 편이 낫다.

**상태 관리와 빈 스코프**

- 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하기 위해 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작
- 서버의 자원이 특정 사용자에게 일정하게 할당되지 않는다.
- 애플리케이션의 특징에 따라서 스프링을 이용해서 상태유지 스타일의 애플리케이션을 얼마든지 만들 수 있다.

**서드파티 프레임워크, 라이브러리 적용**

- 해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있다.
    - 프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록할 수 있게 지원해주는 것
    - 스프링 외의 기술을 접목할 때는 가장 먼저 스프링의 빈으로 등록해서 DI 방식을 통해 사용 가능한지 살펴봐야 한다.
- 스프링의 서비스 추상화가 적용됐다.
- 스프링이 지지하는 프로그래밍 모델을 적용했다.
- 템플릿/콜백이 지원된다.