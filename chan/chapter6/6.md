# 9주차

# AOP

- AOP란?
    - IoC/DI, 서비스 추상화와 더불어 스프링의 3개 기반기술의 하나

## 트랜잭션 코드의 분리

- 트랜잭션 경계설정을 위해 넣은 코드 때문에 현재 UserService가 조금 찜찜함.

### 메소드 분리

- 얼핏 보면 트랜잭션 경계설정 코드와 비즈니스로 로직 코드가 복잡하게 얽혀 있는 듯이 보이지만, 자세히 살펴보면 뚜렷하게 두 가지 종류의 코드가 구분되어 있다.
- 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다.
- 따라서 이 두 코드는 완벽하게 독립적인 코드다.
- 따라서 아래와 같이 분리하자.

```java
public void upgradeLevels() throws Exception {
		// 트랜잭션 시작
		upgradeLevlesInternal();
		// 트랜잭션 종료
}

private void upgradeLevelsInternal() {
		// 비즈니스 로직 코드
}
```

### DI를 이용한 클래스의 분리

- 여전히 트랜잭션을 담당하는 기술적인 코드가 버젓이 UserService 안에 자리 잡고 있다.

**DI 적용을 이용한 트랜잭션 분리**

- 구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점
    - 실전에서는 다른 클래스나 모듈에서 UserService를 호출해 사용할 것이다.
        - 이 경우 UserService를 직접 참조하게 된다.
    - 트랜잭션 코드를 UserService 밖으로 빼버리면 위와 같은 상황에서 트랜잭션이 빠진 UserService를 사용하게 된다.
- 직접 사용이 문제라면 간접적으로 사용하면 된다.
- DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것이다.
- 이를 통해 구현 클래스는 얼마든지 외부에서 변경할 수 있다.
- UserService는 인터페이스로, UserServieImpl라는 구현 클래스 추가
- 클라이언트와 결합이 약해지고, 직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능해진다.
- 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI를 통해 적용하는 방법을 쓰는 이유
    - 구현 클래스를 바꿔가면서 사용하기 위해
    - 테스트 → 테스트 구현 클래스
    - 정식 운영 → 정규 구현 클래스
- 한 번에 두개의 UserService 인터페이스 구현 클래스를 동시에 이용한다면?
    - UserServiceTx라는 UserService를 구현한 또 다른 구현 클래스를 만든다.
    - 트랜잭션의 경계설정이라는 책임을 맡고 있음
    - 스스로는 비즈니스 로직을 담고 있지 않기 때문에 또다른 비즈니스 로직을 담고 있는 UserServiceImpl에 실제적인 로직 처리 작업은 위임
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/29334470-6421-47aa-9714-5077913a6b81/Untitled.png)
    

**UserService 인터페이스 도입**

- 기존의 UserService는 UserServiceImpl로 변경

```java
public interface UserService {
		void add(User user);
		void upgradeLevels();
} 
```

- UserService 인터페이스 생성
- UserServiceImpl 코드에서 트랜잭션 관련 코드 모두 삭제

```java
public class UserServiceImpl implements UserService {
		UserDao userDao;
		MailSender mailSender;

		public void upgradeLevels() {
				// 비즈니스 로직 코드
		}
}
```

- 트랜잭션 코드를 모두 삭제한 UserServiceImpl

**분리된 트랜잭션 기능**

- UserServiceTx는 기본적으로 UserService를 구현하게 만든다.
- 같은 인터페이스를 구현한 다른 오브젝트에게 고스란히 작업을 위임하게 만든다.

```java
public class UserServiceTx implements UserService {

		UserService userService;
		
		public void setUserService(UserService userService) {
			this.userService = userService;
		}

		public void add(User user) {
				userService.add(user);
		}

		public void upgradeLevles() {
				userService.upgradeLevels();
		}
}
```

- UserServiceTx의 코드
- 사용자 관리라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기능을 위임한다.
- 이를 위해 UserService 오브젝트를 DI 받을 수 있도록 한다.

```java
public class UserServiceTx implements UserService {

		UserService userService;
		PlatformTransaction transactionManager;

		public void setTransactionManager(PlatformTransaction transactionManager) {
				this.transactionManager = transactionManager
		}
		
		public void setUserService(UserService userService) {
			this.userService = userService;
		}

		public void add(User user) {
				userService.add(user);
		}

		public void upgradeLevles() {
				Transaction status = this.transactionManager
						.getTransaction(new DefaultTransactionDefinition());
				try {
						userService.upgradeLevels();
						this.transactionManager.commit(status);
				} catch (RuntimeEsception e) {
						this.transactionManager.rollback(status);
						throw e;
				}
		}
}
```

- 트랜잭션을 적용하도록 만든 UserServcieTx

**트랜잭션 적용을 위한 DI 설정**

- 스프링의 DI 설정에 의해 결국 만들어질 빈 오브젝트와 그 의존관계는 다음과 같이 구성되어야 한다.
    - Client(UserServiceTest) → UserSerivceTx → UserSerivceImpl

**트랜잭션 분리에 따른 테스트 수정**

- 기존의 UserService 클래스가 인터페이스 두 개의 클래스로 분리된 만큼 테스트에서도 적합한 타입과 빈을 사용하도록 변경해야 한다.
- 기존에는 UserService 클래스 타입의 빈을 @Autowired로 가져다가 사용했다.
- UserService라는 인터페이스 타입을 가진 두 개의 빈이 존재하기 때문에 문제가 발생한다.
- @Autowired는 기본적으로 타입을 이용해 빈을 찾지만 만약 타입으로 하나의 빈을 결정할 수 없는 경우에는 필드 이름을 이용해 빈을 찾는다.

```java
@Autowired UserService userService;
```

- UserServiceTest는 UserServiceImpl로 정의된 빈을 더 가져와야 한다.
    - MailSender는 DI 해줄 대상을 구체적으로 알고 있어야 하기 때문에 UserServiceImpl 클래스의 오브젝트를 가져올 필요가 있다.
- 개발자가 자신이 작성한 코드를 검증하기 위한 테스트인만큼 내부 구조를 속속들이 알고 있는 채로 테스트를 만드는 것에는 문제가 없다.
- 목 오브젝트를 이용해 수동 DI를 적용하는 테스트라면 어떤 클래스의 오브젝트인지 분명하게 알 필요가 있다.

```java
@Autowired UserServiceImpl userServiceImpl;
```

```java
@Test
public void upgradeLevels() throws Exception {
		...
		MockMailSender mockMailSender = new MockMailSender();
		userServiceImpl.setMailSender(mockMailSender);
}
```

- UserService 인터페이스를 통해서 MailSender의 목 오브젝트를 설정해주는 건 불가능하기 때문에 UserServiceImpl에 해줘야 한다.

- upgradeAllOrNothing() 테스트에도 수정할 부분이 있다.
- 트랜잭션 기술이 바르게 적용됐는지 확인하기 위해 만든 일종의 학습테스트이기 때문이다.

```java
@Test
public void upgradeAllOrNothing() throws Exception {
		TestUserService testUserService = new TestUserService(users.get(3).getId());
		testUserService.setUserDao(userDao);
		testUserService.setMailSender(mailSender);

		UserServiceTx txUserService = new UserServiceTx();
		txUserService.setTransactionManager(transactionManager);
		txUserService.setUserService(testUserService);

		userDao.deleteAll();
		for(User user: users) userDao.add(user);
		
		try {
		txUserService.upgradeLevels();
		fail("TestUserServiceException expected");
		}

		...
}
```

- TestUserService 오브젝트를 UserServiceTx 오브젝트에 수동 DI 시킨 후에 트랜잭션 기능까지 포함된 UserServiceTx의 메소드를 호출하면서 테스트를 수행하도록 해야 한다.

```java
static class TestUserService extends UserServiceImpl {
```

- 트랜잭션 테스트용으로 특별히 정의한 TestUserService 클래스를 위와 같이 UserServiceImpl를 상속하도록 바꿔준다.

**트랜잭션 경계설정 코드 분리의 장점**

- 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트래잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
    - 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.
    - 언제든지 트랜잭션을 도입할 수 있다.
- 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

## 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법
    - 가능한 한 작은 단위로 쪼개서 테스트하는 것
- 작은 단위의 테스트가 좋은 이유
    - 테스트가 실패했을 때 그 원인을 찾기 쉽다.
    - 테스트에서 오류가 발견됐을 때 그 테스트가 진행되는 동안 실행된 코드의 양이 많다면 그 원인을 찾기가 매우 힘들어질 수 있다.
    - 테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다.
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

### 복잡한 의존관계 속의 테스트

- UserService는 간단한 기능만을 가지고 있지만 세 가지 타입의 의존 오브젝트가 필요하다.
    - UserDaoJdbc
    - DSTransactionManager
    - JavaMailSenderImpl
- 심지어 세 가지 의존 오브젝트도 자신의 코드만 실행하고 마는 게 아니라 다른 부분에 의존한다.
- UserService라는 테스트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는 오브젝트와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것이다.

### 테스트 대상 오브젝트 고립시키기

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.

**테스트를 위한 UserServiceImpl 고립**

- UserServiceImpl의 upgradeLevels() 메소드는 리턴 값이 없는 void형이다.
- 따라서 메소드를 실행하고 그 결과를 받아서 검증하는 것은 아예 불가능하다.
- 코드의 동작이 바르게 됐는지 확인하려면 결과가 남아 있는 DB를 직접 확인할 수 밖에 없다.
- 그런데 의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든 UserServiceImpl은 아무리 그 기능이 수행돼도 그 결과가 DB 등을 통해서 남지 않으니, 기존의 방법으로는 작업 결과를 검증하기 힘들다.
- 이럴 땐 테스트 대상인 UserServiceImpl과 그 협력 오브젝트인 UserDao에게 어떤 요청을 했는지를 확인하는 작업이 필요하다.
- UserDao의 update() 메소드를 호출하는 것을 확인할 수 있다면, 결국 DB에 그 결과가 반영될 것이라고 결론을 내릴 수 있기 때문이다.
- UserDao와 같은 역할을 하면서 UserServiceImpl과의 사이에서 주고받은 정보를 저장해뒀다가, 테스트의 검증에 사용할 수 있게 하는 목 오브젝트를 만들 필요가 있다.

**고립된 단위 테스트 활용**

- UserServiceTest의 upgradeLevels() 테스트는 다섯 단계의 작업으로 구성된다.
1. 테스트 실행 중에 UserDao를 통해 가져올 테스트용 정보를 DB에 넣는다.
2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트를 DI 해준다.
3. 실제 테스트 대상인 userService의 메소드를 실행한다.
4. 결과가 DB에 반영됐는지 확인한다.
5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지를 확인한다.

1. 의존관계를 따라 마지막에 등장하는 DB를 준비하는 것
2. 테스트를 의존 오브젝트와 서버 등에서 고립시키도록 테스트만을 위한 목 오브젝트를 준비하는 것

  4. 의존관계를 따라 결국 최종 결과가 반영된 DB의 내용을 확인하는 것

  5. 메일 서버까지 갈 필요 없이 목 오브젝트를 통해 upgradeLevels() 메소드가 실행되는 중에 메일 발송 요청이 나간 적이 있는지만 확인하는 것

**UserDao 목 오브젝트**

- UserServiceImpl의 코드를 살펴보면 upgradeLevels() 메소드와 그 사용 메소드에서 UserDao를 사용하는 경우는 두 가지다.

```java
List<User> users = userDao.getAll(); // 업그레이드 후보 사용자 목록을 가져온다.
userDao.update(user); // 수정된 사용자 정보를 DB에 반영한다.
```

- 테스트용 UserDao에는 DB에서 읽어온 것처럼 미리 준비된 사용자 목록을 제공해줘야 한다.
- update() 메소드의 사용은 upgradeLevels()의 핵심 로직인 ‘전체 사용자 중에서 업그레이드 대상자는 레벨을 변경해준다’에서 ‘변경’에 해당하는 부분을 검증할 수 있는 중요한 기능이다.
- getAll()에 대해서는 스텁으로서, update()에 대해서는 목 오브젝트로서 동작하는 UserDao 타입의 테스트 대역이 필요하다.
- 이 클래스의 이름을 MockUserDao라고 하자.

```java
static class MockUserDao implements UserDao {
		private List<User> users;
		private List<User> updated = new ArrayList();

		private MockUserDao(List<User> users) {
				this.users = users;
		}

		public List<User> getUpdated() {
				return this.updated;
		}

		public List<User> getAll() {
				return this.users;
		}

		public void update(User user) {
				updated.add(user);
		}

		public void add(User user) { throw new UnsupportedOperationException(); 
		...
}
```

- MockUserDao는 UserDao 구현 클래스를 대신해야 하니 당연히 UserDao 인터페이스를 구현해야 한다.
- 사용하지 않을 메소드도 구현해줘야 한다면 예외를 던지도록 만드는 편이 좋다.
- MockUserDao에는 두 개의 User 타입 리스트를 정의해둔다.
    - 생성자를 통해 전달받은 사용자 목록을 저장해뒀다가, getAll() 메소드가 호출되면 DB에서 가져온 것처럼 돌려주는 용도
    - update() 메소드를 실행하면서 넘겨준 업그레이드 대상 User 오브젝트를 저장해뒀다가 검증을 위해 돌려주기 위한 것

```java
@Test
public void upgradeLevels() throws Exception {
		UserServiceImpl userServiceImpl = new UserServiceImpl();

		MockUserDao mockUserDao = new MockUserDao(this.users);
		userServiceImpl.setUserDao(mockUserDao);

		...

		List<User> updated = mockUserDao.getUpdated();
		assertThat(updated.size(), is(2));
		checkUserAndLevel(updated.get(0), "joytouch", Level.SILVER);
		checkUserAndLevel(updated.get(1), "madnite1", Level.GOLD);

		...
}

private void checkUserAndLevel(User updated, String expectedId, Level expectedLevel) {
		assertThat(updated.getId(), is(expectedId));
		assertThat(updated.getLevel(), is(expectedLevel));
}
```

- 완전히 고립돼서 테스트만을 위해 독립적으로 동작하는 테스트 대상을 사용할 것이기 때문에 스프링 컨테이너에서 빈을 가져올 필요가 없다.

**테스트 수행 성능의 향상**

- UserServiceImpl와 테스트를 도와주는 두 개의 목 오브젝트 외에는 사용자 관리 로직을 검증하는 데 직접적으로 필요하지 않은 의존 오브젝트와 서비스를 모두 제거했기 때문에 매우 빠르게 테스트가 가능하다.
- 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없다
- 테스트 수행 성능도 크게 향상된다.

### 단위 테스트와 통합 테스트

- 책에서의 테스트 정의
- 단위 테스트
    - 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트
- 통합 테스트
    - 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트
- 단위 테스트와 통합 테스트 간의 가이드라인 → 책 참고, 인간적으로 너무 길다 ㅋㅋㅋ

### 목 프레임워크

- MockUserDao처럼 목 오브젝트를 만드는 것은 매우 귀찮은 작업이다.

**Mockito 프레임워크**

```java
UserDao mockUserDao = mock(UserDao.class);
when(mockUserDao.getAll()).thenReturn(this.users);
verify(mockUserDao, times(2)).update(any(User.class));
```

- mockUserDao.getAll()이 호출될 때 users 리스트를 리턴해준다.
- User 타입의 오브젝트를 파라미터로 받으며 update() 메소드가 두 번 호출됐는지 확인하라.
- Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용한다
    - 인터페이스를 이용해 목 오브젝트를 만든다.
    - 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
    - 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
    - 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.

```java
@Test
public void mockUpgradeLevels() throws Exception() {
		UserServiceImpl userServiceImpl = new UserServiceImpl();

		UserDao mockUserDao = mock(UserDao.class);
		when(mockUserDao.getAll()).thenReturn(this.users);
		userServiceImpl.setUserDao(mockUserDao);

		MailSender mockMailSender = mock(MailSender.class);
		userServiceImpl.setMailSender(mockMailSender);

		userServiceImpl.upgradeLevles();

		verify(mockUserDao, times(2)).update(any(User.class));
		verify(mockUserDao, times(2)).update(any(User.class));
		verify(mockUserDao).update(users.get(1));
		assertThat(users.get(1).getLevel(), is(Level.SILVER));
		verify(mockUserDao).update(users.get(3));
		assertThat(users.get(3).getLevel(), is(Level.GOLD));
		
		...
}
```

- any() → 파라미터의 내용은 무시하고 호출 횟수만 확인할 수 있다.
- verify(mockUserDao).update(users.get(1)) → users.get(1)을 파라미터로 update()가 호출된 적이 있는지를 확인해준다.
- 레벨의 변화는 파라미터의 직접 비교로는 확인이 되지 않으므로 User 목록의 내용을 가지고 직접 확인해봐야한다.

# 10주차

## 다이내믹 프록시와 팩토리 빈

### 프록시와 프록시 패턴, 데코레이터 패턴

- 전략 패턴으로는 트랜잭션 기능의 구현 내용을 분리해냈을 뿐 트랜잭션을 적용한다는 사실은 코드에 그대로 남아있음
- 트랜잭션이라는 기능은 사용자 관리 비즈니스 로직과는 성격이 다르기 때문에 아예 그 적용 사실 자체를 밖으로 분리할 수 있음
- 이 방법을 통해 UserServiceTx를 만들었고, UserServiceImpl에는 트랜잭션 관련 코드가 하나도 남지 않게 됨.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/754a6723-1a6e-466b-91a5-711a2ccfcc4c/Untitled.png)
    
- 분리된 부가기능을 담은 클래스의 중요한 특징
    - 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다.
    - 핵심기능은 부가기능을 가진 클래스의 존재 자체를 모른다. (ex. UserServiceImpl은 UserServiceTx를 모른다.)
    - 따라서 부가기능이 핵심기능을 사용하는 구조가 되는 것이다.
- 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능이 적용될 기회가 없다.
- 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야 함.
- 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고, 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다. (UserService)
- 클라이언트는 핵심기능을 사용한다 생각하지만, 부가기능을 통해 핵심기능을 이용하게 된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/978fb7dd-a72d-41dc-bb99-8c4c5aff22f6/Untitled.png)

- 부가기능 → 핵심기능 연결과정에서 부가기능 적용 가능 (ex. 비즈니스 로직 코드에 트랜잭션 적용)
- 프록시
    - 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트 요청을 받아주는 것
- 타깃, 실체
    - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/3485e37e-df47-4388-a7c5-a6f09c119efb/Untitled.png)
    
- 프록시의 특징
    - 타깃과 같은 인터페이스를 구현 (UserServiceImpl과 UserService를 구현한 UserServiceTx)
    - 프록시가 타깃을 제어할 수 있는 위치에 있다.
- 프록시의 구분 (사용 목적에 따라 구분됨)
    - 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서
    - 타깃에 부가적인 기능을 부여해주기 위해서

**데코레이터 패턴**

- 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
- 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있다 → 데코레이터
- 프록시가 꼭 한 개로 제한되지 않는다. (포장은 포장지, 리본, 스티커 등 다양하게 데코할 수 있음)
    - 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없다.
    - 같은 인터페이스를 구현한 타겟과 여러개의 프록시를 사용할 수 있다.
    - 단계적으로 위임하는 구조
- 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자기가 어디로 위임하는지 모름.
- 따라서 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.
- 인터페이스를 통해 위임하는 방식이기 때문에 어느 데코레이터에서 타깃으로 연결될지 코드 레벨에선 미리 알 수 없다.
- 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

**프록시 패턴**

- 디자인 패턴에서의 프록시 패턴
    - 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우
- 타깃의 기능을 확장하거나 추가하지 않는다.
- 클라이언트가 타깃에 접근하는 방식을 변경해준다.
- 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.
    - 하지만 타깃 오브젝트에 대한 레퍼런스가 미리 필요할 수 있다.
    - 이럴 때 프록시 패턴을 적용~!
- 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨준다.
- 프록시의 메소드를 통해 타깃을 사용하려고 하면, 그 때 본체를 넘겨준다.
- 이점은?
    - 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면, 프록시를 통해 생성을 최대한 늦추는게 장점이 많다.
- 원격 오브젝트를 이용하는 경우에도 편리하다.
    - 다양한 기술을 이용해 다른 서버에 존재하는 오브젝트를 사용해야 한다면, 프록시를 통해 클라이언트가 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼 프록시를 사용하게 할 수 있다.
    - 요청이 들어오면 프록시는 네트워크를 통해 원격의 오브젝트를 실행하고 결과를 반환해준다.
- 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위해
    - if) 수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 Read만 동작
    - 오브젝트의 프록시를 만들어서 특정 메소드를 사용하려고 하면 예외 발생
    - Collections의 unmodifiableCollection()이 한 예
        - 파라미터로 전달된 Collection 오브젝트의 프록시를 만들어서, add()나 remove() 같은 메소드를 호출할 때 UnsupportedOperationException 예외 발생
- 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용
- 데코레어터와 구조적으로 유사하나 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.
    - 물론 인터페이스를 통해 위임하도록 만들 수 있다.
- 앞으로는 타깃과 동일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서 기능의 부가 또는 접근 제어를 담당하는 오브젝트를 모두 프록시라고 하겠다. (UserServiceTx)

### 다이내믹 프록시

- 프록시
    - 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법
    - 근데 귀찮음 → 할 일이 많아짐 (새로운 클래스, 인터페이스 메소드 구현, 단위 테스트 등)
- 목처럼 뚝딱은 안되나?
- java.lang.reflect 패키지 안에 프록시를 손쉽게 만들 수 있돌록 지원해주는 클래스들이 있다.

**프록시의 구성과 프록시 작성의 문제점**

- 프록시는 다음의 두 가지 기능으로 구성된다.
    - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.
    - 지정된 요청에 대해서는 부가기능을 수행한다.

```java
public class UserServiceTx implements UserService {
		UserService userService;
		...
		
		public void add(User user) {
				this.userServcie.add(user);  // 메소드 구현과 위임
		}
		
		public void upgardeLevels() {
		  // 부가 기능 수행
		  TransactionStatus status = this.transactionManager.getTransaction
				  (new DefaultTransactionDefinition()); 
		  try {
				  userService.upgradeLevels(); // 위임
				  
				  // 부가 기능 수행
				  this.transactionManager.commit(status);
			} catch (RuntimeException e) {
					this.transactionManager.rollback(status);
					throw e;
			}
	}
}
```

- 프록시의 역할은 위임과 부가작업으로 구분 가능
- 프록시를 만들기가 번거로운 이유?
    - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다.
        - 부가기능이 필요 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
        - 타깃 인터페이스의 변경 때마다 같이 수정해줘야 함
    - 부가기능 코드가 중복될 가능성이 많다.
        - 트랜잭션은 DB를 사용하는 대부분의 로직에 적용될 필요가 있다.
- 이런 문제를 해결하는 데 유용한 것이 바로 JDK의 다이내믹 프록시다.

**리플렉션**

- 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
- 리플렉션
    - 자바의 코드 자체를 추상화해서 접근하도록 만든 것
    - 리플렉션 API 중에서 메소드에 대한 정의를 담은 Method라는 인터페이스를 이용해 메소드를 호출하는 방법

```java
Method lengthMethod = String.class.getMethod("length");
```

- String이 가진 메소드 중에서 “length”라는 이름을 갖고 있고, 파라미터는 없는 메소드의 정보를 가져오는 것
- 특정 오브젝트의 메소드를 실행시킬 수도 있다. → invoke() 사용
    - invoke() 메소드는 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려준다.

```java
public Object invoke(Object obj, Object... args)
int length = lengthMethod.invoke(name); // int length = name.length();
```

```java
public class ReflectionTest {
		@Test
		public void invokeMethod() throws Exception {
				String name = "Spring";
				
				// length()
				assertThat(name.length(), is(6));
				
				Method lengthMethod = String.class.getMethod("length");
				assertThat((Integer)lengthMethod.invoke(name), is(6));
				
				// charAt()
				assertThat(name.charAt(0), is('S'));
				
				Method charAtMethod = String.class.getMethod("charAt", int.class);
				assertThat((Character)charAtMethod.invoke(name, 0).is('S'));
		}
}
```

- charAtMethod.invoke(name, 0) → 오브젝트와 파라미터를 받아주는 모습

**프록시 클래스**

- 다이내믹 프록시를 이용한 프록시를 만들기 위한 예제

```java
interface Hello {
		String sayHello(String name);
		String sayHi(String name);
		String sayThankYou(String name);
}
```

- 인터페이스

```java
public class HelloTarget implements Hello {
		...
}
```

- 타깃

```java
@Test
public void simpleProxsy() {
		Hello hello = new HelloTarget();
		assertThat(hello.sayHello("Toby"), is("Hello Toby"));
		...
}
```

- 클라이언트

```java
public class HelloUppercase implements Hello {
		
		Hello hello; // 다른 프록시를 추가할 수 있으므로 인터페이스로 접근
		
		public HelloUppercase(Hello hello) {
				this.hello = hello;
		}
		
		public String sayHello(String name) {
				return hello.sayHello(name).toUppercase();
		}
		
		public String sayHi(String name) {
				return hello.sayHi(name).toUpperCase();
		}
		
		public String sayThankYou(String name) {
				return hello.sayThankYou(name).toUpperCase();
		}
}
```

- 프록시
- 데코레이터 패턴을 적용해서 타깃인 HelloTarget에 부가기능을 추가
    - 리턴하는 문자를 모두 대문자로 바꿔주는 것
- 위 프록시의 문제점
    - 인터페이스의 모든 메소드를 구현해 위임하도록 코드를 만들어야한다.
    - 부가기능인 리턴 값을 대문자로 바꾸는 기능이 모든 메소드에 중복돼서 나타난다.

**다이내믹 프록시 적용**

- HelloUppercase를 다이내믹 프록시를 이용해 만들어보자.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/5a3d131d-06f9-498e-85a4-d6f265209e50/Untitled.png)

- 다이내믹 프록시
    - 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트
    - 타깃의 인터페이스와 같은 타입으로 만들어진다.
    - 클라이언트는 타깃 인터페이스를 통해 다이내믹 프록시 오브젝트 사용 가능
        - 프록시를 만들 때 인터페이스를 모두 구현해가면서 클래스를 정의하는 수고를 덜 수 있다.
        - 프록시 팩토리가 인터페이스 정보를 제공받고 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어주기 때문
        - 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야 한다.
    - 부가 기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다.

```java
public Object invoke(Object proxy, Method method, Object[] args)
```

- InvocationHandler 인터페이스의 구성
- 다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 invoke() 메소드로 넘김
- 타깃 인터페이스의 모든 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.
- InvocationHandler 구현 오브젝트가 타깃 오브젝트 레퍼런스를 갖고 있다면 리플렉션을 이용해 간단히 위임 코드를 만들어낼 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/81504972-1561-444e-b6a6-e85151fc0e7e/Untitled.png)

```java
public class UppercaseHandler implements InvocationHandler {
		Hello target;
		
		public UppercaseHandler(Hello target) {
				this.target = target;  
				// 다이내믹 프록시로부터 전달받은 요청을 다시 타깃 오브젝트에 위임해야하기 때문에
				// 타깃 오브젝트를 주입해둔다.
		}
		
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				String ret = (String)method.invoke(target, args); // 타깃으로 위임
				return ret.toUppercase(); // 부가기능 제공
		}
}
```

- 다이내믹 프록시로부터 메소드 호출 정보를 받아서 처리하는 InvoicationHandler

```java
Hello proxiedHello = (Hello)Proxy.newProxyInstance(
					getClass().getClassLoader(),
					new Class[] { Hello.class }, // 구현할 인터페이스
					new UppercaseHandler(new HelloTarget())); // 부가기능과 위임 코드를 담은 InvocationHandler
```

- 다이내믹 프록시를 생성하는 코드
- 다이내믹 프록시의 생성에는 Proxy 클래스의 newProxyInstance() 스태틱 팩토리 메소드를 이용한다.
- 다이내믹 프록시는 한 번에 하나 이상의 인터페이스를 구현할 수도 있기 때문에 Class[]를 사용한다.

**다이내믹 프록시의 확장**

- 다이내믹 프록시 방식이 직접 정의해서 만든 프록시보다 훨씬 유연하고 많은 장점이 있다.
    - 인터페이스의 메소드가 늘어나도 전혀 손댈 게 없다.
    - 메소드의 리턴 타입이 달라진다면 코드를 조금만 수정하면 된다.
    - 어차피 리플렉션의 Method 인터페이스를 이용해 타깃의 메소드를 호출하기 때문에 타깃의 종류에 상관없이 적용이 가능하다.
    

### 다이내믹 프록시를 이용한 트랜잭션 부가기능

- UserServiceTx의 문제점
    - 서비스 인터페이스의 메소드를 모두 구현해야 함
    - 트랜잭션이 필요한 메소드마다 코드가 중복돼서 나타남
- 트랜잭션 부가기능을 제공하는 다이내믹 프록시를 만들어 적용하는 방법이 효율적이다.

**트랜잭션 InvocationHandler**

```java
public class TransactionHandler implements InvoactionHandler {
		private Object target;
		private PlatformTransactionManager transactionManager;
		prviate String pattern;
		
		public void setTarget(Object target) {
				this.target = target;
		}
		
		...
		
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				if (method.getName().startsWith(pattern) {
						return invokeInTransaction(method, args);
				} else {
						return method.invoke(target, args);
				}
		}
		
		private Object invokeInTransaction(Method method, Object[] args) throws Throwable {
				TransactionStatus status = this.transactionManager.getTransaction(
						new DefaultTransactionDefinition));
				try {
					  Object ret = method.invoke(target, args);
					  this.transactionManager.commit(status);
						return ret;
				} catch (InvocationTargetException e) {
						this.transactionManager.rollback(status);
						throw e.getTargetException();
				}
		}
}
```

- 타깃을 저장할 변수를 Object로 선언 → UserServiceImpl 외에 트랜잭션 적용이 필요한 어떤 타깃 오브젝트에도 적용 가능
- 타깃 오브젝트의 모든 메소드에 무조건 트랜잭션이 적용되지 않도록 트랜잭션을 적용할 메소드 이름의 패턴을 DI받는다.
    - pattern을 “get”으로 주면 get으로 시작하는 모든 메소드에 트랜잭션이 적용된다.
- 롤백을 적용하기 위한 예외는 RuntimeException 대신 InvocationTargetException으 랒ㅂ도록 해야 한다.
    - Method.invoke()를 이용해 타깃 오브젝트의 메소드를 호출할 때는 타깃 오브젝트에서 발생하는 예외가 InvocationTargetException으로 한 번 포장돼서 전달된다.

**TransactionHandler와 다이내믹 프록시를 이용하는 테스트**

```java
@Test
public void upgradeAllOrNothing() throws Exception {
		...
		TransactionHandler txHandler = new TransactionHandler();
		txHandler.setTarget(testUserService);
		txHandler.setTransactionManager(transactionManager);
		txHandler.setPattern("upgradeLevels");
		UserService txUserService = (UserService)Proxy.newProxyInstance(
				getClass().getClassLoader(),new Class[] { UserService.class }, txHandler);
		...
}
```

- UserServiceTx 대신 TransactionHandler를 이용하는 다이내믹 프록시를 사용하도록 테스트 수정

### 다이내믹 프록시를 위한 팩토리 빈

- TransactionHandler와 다이내믹 프록시를 스프링의 DI를 통해 사용할 수 있도록 만들고자 함.
- DI의 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 방법이 없는 것이 문제다.
- 스프링의 빈은 기본적으로 클래스 이름과 프로퍼티로 정의된다.
- 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해서 해당 클래스의 오브젝트를 만든다.
- 다이내믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다.
- 클래스 자체도 내부적으로 다이내믹하게 새로 정의해서 사용하기 때문에 다이내믹 프록시 오브젝트의 클래스가 어떤 것인지 알 수 없다
- 따라서 스프링 빈에 정의할 방법이 없다.
- 다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.

**팩토리 빈**

- 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈
- 스프링의 FactoryBean이라는 인터페이스를 구현하는 방법으로 만들 수 있다.

```java
public interface FactoryBean<T> {
		T getObject() throws Exception; // 빈 오브젝트를 생성해서 돌려준다.
		Class<? extends T> getObjectType(); // 생성되는 오브젝트의 타입을 알려준다.
		boolean isSingleton(); // getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려준다.
```

- FactoryBean 인터페이스
- 위를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.

- Message는 생성자가 private으로 되어있어 오브젝트를 만들려면 반드시 스태틱 메소드를 사용해야 한다.
- 따라서 이 클래스를 직접 스프링 빈으로 등록해서 사용할 수 없다.
- 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트를 만들어준다.
- 리플렉션은 private으로 선언된 접근 규약을 위반할 수 있는 강력한 기능이 있기 때문이다.
- 하지만 생성자를 private으로 만들었다는 것은 스태틱 메소드를 통해 오브젝트가 만들어져야 하는 중요한 이유가 있기 때문이므로 이를 무시하고 오브젝트를 강제로 생성하면 위험하다.

```java
public class MessageFactoryBean implements FactoryBean<Message> {
		
		// 오브젝트를 생성할 때 필요한 정보를 팩토리 빈의
		// 프로퍼티로 설정해서 대신 DI 받을 수 있게 한다.
		// 주입된 정보는 오브젝트 생성 중에 사용된다.
		String text;
		
		public void setText(String text) {
				this.text = text;
		}
		
		// 실제 빈으로 사용될 오브젝트를 직접 생성한다.
		// 코드를 이용하기 때문에 복잡한 방식의 오브젝트 생성과 초기화 작업도 가능하다.
		public Message getObject() throws Exception {
				return Message.newMessage(this.text);
		}
		
		public Class<? extends Message> getObjectType() {
				return Message.class;
		}
		
		// getObject() 메소드가 돌려주는 오브젝트가 싱글톤인지를 알려준다.
		// 이 팩토리 빈은 매번 요청할 때마다 새로운 오브젝트를 만들므로 false로 설정한다.
		// 이것은 팩토리 빈의 동작방식에 관한 설정이고 만들어진 빈 오브젝트는
		// 싱글톤으로 스프링이 관리해줄 수 있다.
		public boolean isSingleton() {
				return false;
		}
}
```

- Message의 팩토리 빈 클래스
- 팩토리 빈은 전형적인 팩토리 메소드를 가진 오브젝트다.
- 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면, 팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용한다.
- 빈의 클래스로 등록된 팩토리 빈은 빈 오브젝트를 생성하는 과정에서만 사용될 뿐이다.

**팩토리 빈의 설정 방법**

- 팩토리 빈의 설정은 일반 빈과 다르지 않다.
- 여타 빈 설정과 다른 점은 message 빈 오브젝트의 타입이 class 애트리뷰트에 정의된 MessageFactoryBean이 아니라 Message 타입이라는 것이다.
- getObjectType() 메소드가 돌려주는 타입이 빈의 타입이 된다.
- getObject() 메소드가 생성해주는 오브젝트가 빈의 오브젝트가 된다.

```java
@Test
public void getFactoryBean() throws Exception {
		Object factory = context.getBean("&message");
		assertThat(factory, is(MessageFactoryBean.class));
```

- 스프링은 ‘&’를 빈 이름 앞에 붙여주면 팩토리 빈 자체를 돌려준다.

**다이내믹 프록시를 만들어주는 팩토리 빈**

- 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다.
- 팩토리 빈을 사용하면 가능하다.
    - 팩토리 빈의 getObject() 메소드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 되기 때문이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/56f8674c-b7f8-431b-959d-039c2adc7429/Untitled.png)

- 스프링 빈 : 팩토리 빈, UserServiceImpl
- 팩토리 빈은 다이내믹 프록시의 타깃 오브젝트 UserServiceImpl에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둬야 한다.
    - 다이내믹 프록시와 함께 생성할 TransactionHandler에게 타깃 오브젝트를 전달해줘야 하기 때문

**트랜잭션 프록시 팩토리 빈**

```java
public class TxProxyFactoryBean implements FactoryBean<Object> {
		// TransactionHandler를 생성할 때 필요
		Object target;
		PlatformTransactionManager transactionManager;
		String pattern;
		Class<?> serviceInterface; // UserService 외의 인터페이스를 가진 타깃에도 적용
		
		public void setTarget(Object target) {
				this.target = target;
		}
		
		public void setTransactionManager(PlatformTransactionManager transactionManager) {
				this.transactionManager = transactionManager;
		}
		
		public void setPattern(String pattern) {
				this.pattern = pattern;
		}
		
		public void setServiceInterface(Class<?> serviceInterface) {
				this.serviceInterface = serviceInterface;
		}
		
		// FactoryBean 인터페이스 구현 메소드
		// DI 받은 정보를 이용해서 TransactionHandler를 사용하는 다이내믹 프록시를 생성
		public Object getObject() throws Exception {
				TransactionHandler txHandler = new TransactionHandler();
				txHandler.setTarget(target);
				txHandler.setTransactionManager(transactionManager);
				txHandler.setPattern(pattern);
				return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]
						 { serviceInterface }, txHandler);
				}
				
		public Class<?> getObjectType() {
				return serviceInterface;
		}
		
		public boolean isSingleton() {
				return false;
		}
}
```

- UserServiceTx를 대체하는 TxProxyFactoryBean
- Class 타입은 value를 이용해 클래스 또는 인터페이스의 이름을 넣어주면 빈 설정이 가능하다.

```java
<property name="serviceInterface" value="springboot.user.service.UserService"/>
```

**트랜잭션 프록시 팩토리 빈 테스트**

- add() 메소드를 제외한 나머지 메소드가 현재 팩토리 빈이 적용되지 않는 상황
- upgradeAllOrNothing() 테스트에서 타깃 오브젝트로 TestUserService가 동작하도록 해야 함.
- 스프링 빈에서 생성되는 프록시 오브젝트에 대해 테스트를 해야 하기 때문에 간단하지 않음
- 타깃 오브젝트에 대한 레퍼런스는 TransactionHandler 오브젝트가 가지고 있는데, 이는 TxProxyFactoryBean 내부에서 만들어져서 별도로 참조할 방법이 없음.
- 빈으로 등록된 TxProxyFactoryBean을 직접 가져와서 프록시를 만들자.
- “&”를 붙여 팩토리 빈 자체를 가져올 수 있다.

```java
TxProxyFactoryBean txProxyFactoryBean =
		context.getBean("&userService", TxProxyFactoryBean.class);
txProxyFactoryBean.setTarget(testUserService);
UserService txUserService = (UserService) txProxyFactoryBean.getObject();
```

- 매번 트랜젹션 기능을 담은 UserServiceTx와 같은 프록시 클래스를 작성하는 번거로움을 완벽하게 제거했다.

### 프록시 팩토리 빈 방식의 장점과 한계

**프록시 팩토리 빈의 재사용**

- 인터페이스는 CoreService라고 하고 이에 정의된 수십여개의 메소드에 트랜잭션을 모두 적용해야 하는 상황을 가정해보자.