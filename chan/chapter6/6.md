# 9주차

# AOP

- AOP란?
    - IoC/DI, 서비스 추상화와 더불어 스프링의 3개 기반기술의 하나

## 트랜잭션 코드의 분리

- 트랜잭션 경계설정을 위해 넣은 코드 때문에 현재 UserService가 조금 찜찜함.

### 메소드 분리

- 얼핏 보면 트랜잭션 경계설정 코드와 비즈니스로 로직 코드가 복잡하게 얽혀 있는 듯이 보이지만, 자세히 살펴보면 뚜렷하게 두 가지 종류의 코드가 구분되어 있다.
- 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다.
- 따라서 이 두 코드는 완벽하게 독립적인 코드다.
- 따라서 아래와 같이 분리하자.

```java
public void upgradeLevels() throws Exception {
		// 트랜잭션 시작
		upgradeLevlesInternal();
		// 트랜잭션 종료
}

private void upgradeLevelsInternal() {
		// 비즈니스 로직 코드
}
```

### DI를 이용한 클래스의 분리

- 여전히 트랜잭션을 담당하는 기술적인 코드가 버젓이 UserService 안에 자리 잡고 있다.

**DI 적용을 이용한 트랜잭션 분리**

- 구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점
    - 실전에서는 다른 클래스나 모듈에서 UserService를 호출해 사용할 것이다.
        - 이 경우 UserService를 직접 참조하게 된다.
    - 트랜잭션 코드를 UserService 밖으로 빼버리면 위와 같은 상황에서 트랜잭션이 빠진 UserService를 사용하게 된다.
- 직접 사용이 문제라면 간접적으로 사용하면 된다.
- DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것이다.
- 이를 통해 구현 클래스는 얼마든지 외부에서 변경할 수 있다.
- UserService는 인터페이스로, UserServieImpl라는 구현 클래스 추가
- 클라이언트와 결합이 약해지고, 직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능해진다.
- 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI를 통해 적용하는 방법을 쓰는 이유
    - 구현 클래스를 바꿔가면서 사용하기 위해
    - 테스트 → 테스트 구현 클래스
    - 정식 운영 → 정규 구현 클래스
- 한 번에 두개의 UserService 인터페이스 구현 클래스를 동시에 이용한다면?
    - UserServiceTx라는 UserService를 구현한 또 다른 구현 클래스를 만든다.
    - 트랜잭션의 경계설정이라는 책임을 맡고 있음
    - 스스로는 비즈니스 로직을 담고 있지 않기 때문에 또다른 비즈니스 로직을 담고 있는 UserServiceImpl에 실제적인 로직 처리 작업은 위임
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/29334470-6421-47aa-9714-5077913a6b81/Untitled.png)
    

**UserService 인터페이스 도입**

- 기존의 UserService는 UserServiceImpl로 변경

```java
public interface UserService {
		void add(User user);
		void upgradeLevels();
} 
```

- UserService 인터페이스 생성
- UserServiceImpl 코드에서 트랜잭션 관련 코드 모두 삭제

```java
public class UserServiceImpl implements UserService {
		UserDao userDao;
		MailSender mailSender;

		public void upgradeLevels() {
				// 비즈니스 로직 코드
		}
}
```

- 트랜잭션 코드를 모두 삭제한 UserServiceImpl

**분리된 트랜잭션 기능**

- UserServiceTx는 기본적으로 UserService를 구현하게 만든다.
- 같은 인터페이스를 구현한 다른 오브젝트에게 고스란히 작업을 위임하게 만든다.

```java
public class UserServiceTx implements UserService {

		UserService userService;
		
		public void setUserService(UserService userService) {
			this.userService = userService;
		}

		public void add(User user) {
				userService.add(user);
		}

		public void upgradeLevles() {
				userService.upgradeLevels();
		}
}
```

- UserServiceTx의 코드
- 사용자 관리라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기능을 위임한다.
- 이를 위해 UserService 오브젝트를 DI 받을 수 있도록 한다.

```java
public class UserServiceTx implements UserService {

		UserService userService;
		PlatformTransaction transactionManager;

		public void setTransactionManager(PlatformTransaction transactionManager) {
				this.transactionManager = transactionManager
		}
		
		public void setUserService(UserService userService) {
			this.userService = userService;
		}

		public void add(User user) {
				userService.add(user);
		}

		public void upgradeLevles() {
				Transaction status = this.transactionManager
						.getTransaction(new DefaultTransactionDefinition());
				try {
						userService.upgradeLevels();
						this.transactionManager.commit(status);
				} catch (RuntimeEsception e) {
						this.transactionManager.rollback(status);
						throw e;
				}
		}
}
```

- 트랜잭션을 적용하도록 만든 UserServcieTx

**트랜잭션 적용을 위한 DI 설정**

- 스프링의 DI 설정에 의해 결국 만들어질 빈 오브젝트와 그 의존관계는 다음과 같이 구성되어야 한다.
    - Client(UserServiceTest) → UserSerivceTx → UserSerivceImpl

**트랜잭션 분리에 따른 테스트 수정**

- 기존의 UserService 클래스가 인터페이스 두 개의 클래스로 분리된 만큼 테스트에서도 적합한 타입과 빈을 사용하도록 변경해야 한다.
- 기존에는 UserService 클래스 타입의 빈을 @Autowired로 가져다가 사용했다.
- UserService라는 인터페이스 타입을 가진 두 개의 빈이 존재하기 때문에 문제가 발생한다.
- @Autowired는 기본적으로 타입을 이용해 빈을 찾지만 만약 타입으로 하나의 빈을 결정할 수 없는 경우에는 필드 이름을 이용해 빈을 찾는다.

```java
@Autowired UserService userService;
```

- UserServiceTest는 UserServiceImpl로 정의된 빈을 더 가져와야 한다.
    - MailSender는 DI 해줄 대상을 구체적으로 알고 있어야 하기 때문에 UserServiceImpl 클래스의 오브젝트를 가져올 필요가 있다.
- 개발자가 자신이 작성한 코드를 검증하기 위한 테스트인만큼 내부 구조를 속속들이 알고 있는 채로 테스트를 만드는 것에는 문제가 없다.
- 목 오브젝트를 이용해 수동 DI를 적용하는 테스트라면 어떤 클래스의 오브젝트인지 분명하게 알 필요가 있다.

```java
@Autowired UserServiceImpl userServiceImpl;
```

```java
@Test
public void upgradeLevels() throws Exception {
		...
		MockMailSender mockMailSender = new MockMailSender();
		userServiceImpl.setMailSender(mockMailSender);
}
```

- UserService 인터페이스를 통해서 MailSender의 목 오브젝트를 설정해주는 건 불가능하기 때문에 UserServiceImpl에 해줘야 한다.

- upgradeAllOrNothing() 테스트에도 수정할 부분이 있다.
- 트랜잭션 기술이 바르게 적용됐는지 확인하기 위해 만든 일종의 학습테스트이기 때문이다.

```java
@Test
public void upgradeAllOrNothing() throws Exception {
		TestUserService testUserService = new TestUserService(users.get(3).getId());
		testUserService.setUserDao(userDao);
		testUserService.setMailSender(mailSender);

		UserServiceTx txUserService = new UserServiceTx();
		txUserService.setTransactionManager(transactionManager);
		txUserService.setUserService(testUserService);

		userDao.deleteAll();
		for(User user: users) userDao.add(user);
		
		try {
		txUserService.upgradeLevels();
		fail("TestUserServiceException expected");
		}

		...
}
```

- TestUserService 오브젝트를 UserServiceTx 오브젝트에 수동 DI 시킨 후에 트랜잭션 기능까지 포함된 UserServiceTx의 메소드를 호출하면서 테스트를 수행하도록 해야 한다.

```java
static class TestUserService extends UserServiceImpl {
```

- 트랜잭션 테스트용으로 특별히 정의한 TestUserService 클래스를 위와 같이 UserServiceImpl를 상속하도록 바꿔준다.

**트랜잭션 경계설정 코드 분리의 장점**

- 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트래잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
    - 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.
    - 언제든지 트랜잭션을 도입할 수 있다.
- 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

## 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법
    - 가능한 한 작은 단위로 쪼개서 테스트하는 것
- 작은 단위의 테스트가 좋은 이유
    - 테스트가 실패했을 때 그 원인을 찾기 쉽다.
    - 테스트에서 오류가 발견됐을 때 그 테스트가 진행되는 동안 실행된 코드의 양이 많다면 그 원인을 찾기가 매우 힘들어질 수 있다.
    - 테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다.
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

### 복잡한 의존관계 속의 테스트

- UserService는 간단한 기능만을 가지고 있지만 세 가지 타입의 의존 오브젝트가 필요하다.
    - UserDaoJdbc
    - DSTransactionManager
    - JavaMailSenderImpl
- 심지어 세 가지 의존 오브젝트도 자신의 코드만 실행하고 마는 게 아니라 다른 부분에 의존한다.
- UserService라는 테스트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는 오브젝트와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것이다.

### 테스트 대상 오브젝트 고립시키기

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.

**테스트를 위한 UserServiceImpl 고립**

- UserServiceImpl의 upgradeLevels() 메소드는 리턴 값이 없는 void형이다.
- 따라서 메소드를 실행하고 그 결과를 받아서 검증하는 것은 아예 불가능하다.
- 코드의 동작이 바르게 됐는지 확인하려면 결과가 남아 있는 DB를 직접 확인할 수 밖에 없다.
- 그런데 의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든 UserServiceImpl은 아무리 그 기능이 수행돼도 그 결과가 DB 등을 통해서 남지 않으니, 기존의 방법으로는 작업 결과를 검증하기 힘들다.
- 이럴 땐 테스트 대상인 UserServiceImpl과 그 협력 오브젝트인 UserDao에게 어떤 요청을 했는지를 확인하는 작업이 필요하다.
- UserDao의 update() 메소드를 호출하는 것을 확인할 수 있다면, 결국 DB에 그 결과가 반영될 것이라고 결론을 내릴 수 있기 때문이다.
- UserDao와 같은 역할을 하면서 UserServiceImpl과의 사이에서 주고받은 정보를 저장해뒀다가, 테스트의 검증에 사용할 수 있게 하는 목 오브젝트를 만들 필요가 있다.

**고립된 단위 테스트 활용**

- UserServiceTest의 upgradeLevels() 테스트는 다섯 단계의 작업으로 구성된다.
1. 테스트 실행 중에 UserDao를 통해 가져올 테스트용 정보를 DB에 넣는다.
2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트를 DI 해준다.
3. 실제 테스트 대상인 userService의 메소드를 실행한다.
4. 결과가 DB에 반영됐는지 확인한다.
5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지를 확인한다.

1. 의존관계를 따라 마지막에 등장하는 DB를 준비하는 것
2. 테스트를 의존 오브젝트와 서버 등에서 고립시키도록 테스트만을 위한 목 오브젝트를 준비하는 것

  4. 의존관계를 따라 결국 최종 결과가 반영된 DB의 내용을 확인하는 것

  5. 메일 서버까지 갈 필요 없이 목 오브젝트를 통해 upgradeLevels() 메소드가 실행되는 중에 메일 발송 요청이 나간 적이 있는지만 확인하는 것

**UserDao 목 오브젝트**

- UserServiceImpl의 코드를 살펴보면 upgradeLevels() 메소드와 그 사용 메소드에서 UserDao를 사용하는 경우는 두 가지다.

```java
List<User> users = userDao.getAll(); // 업그레이드 후보 사용자 목록을 가져온다.
userDao.update(user); // 수정된 사용자 정보를 DB에 반영한다.
```

- 테스트용 UserDao에는 DB에서 읽어온 것처럼 미리 준비된 사용자 목록을 제공해줘야 한다.
- update() 메소드의 사용은 upgradeLevels()의 핵심 로직인 ‘전체 사용자 중에서 업그레이드 대상자는 레벨을 변경해준다’에서 ‘변경’에 해당하는 부분을 검증할 수 있는 중요한 기능이다.
- getAll()에 대해서는 스텁으로서, update()에 대해서는 목 오브젝트로서 동작하는 UserDao 타입의 테스트 대역이 필요하다.
- 이 클래스의 이름을 MockUserDao라고 하자.

```java
static class MockUserDao implements UserDao {
		private List<User> users;
		private List<User> updated = new ArrayList();

		private MockUserDao(List<User> users) {
				this.users = users;
		}

		public List<User> getUpdated() {
				return this.updated;
		}

		public List<User> getAll() {
				return this.users;
		}

		public void update(User user) {
				updated.add(user);
		}

		public void add(User user) { throw new UnsupportedOperationException(); 
		...
}
```

- MockUserDao는 UserDao 구현 클래스를 대신해야 하니 당연히 UserDao 인터페이스를 구현해야 한다.
- 사용하지 않을 메소드도 구현해줘야 한다면 예외를 던지도록 만드는 편이 좋다.
- MockUserDao에는 두 개의 User 타입 리스트를 정의해둔다.
    - 생성자를 통해 전달받은 사용자 목록을 저장해뒀다가, getAll() 메소드가 호출되면 DB에서 가져온 것처럼 돌려주는 용도
    - update() 메소드를 실행하면서 넘겨준 업그레이드 대상 User 오브젝트를 저장해뒀다가 검증을 위해 돌려주기 위한 것

```java
@Test
public void upgradeLevels() throws Exception {
		UserServiceImpl userServiceImpl = new UserServiceImpl();

		MockUserDao mockUserDao = new MockUserDao(this.users);
		userServiceImpl.setUserDao(mockUserDao);

		...

		List<User> updated = mockUserDao.getUpdated();
		assertThat(updated.size(), is(2));
		checkUserAndLevel(updated.get(0), "joytouch", Level.SILVER);
		checkUserAndLevel(updated.get(1), "madnite1", Level.GOLD);

		...
}

private void checkUserAndLevel(User updated, String expectedId, Level expectedLevel) {
		assertThat(updated.getId(), is(expectedId));
		assertThat(updated.getLevel(), is(expectedLevel));
}
```

- 완전히 고립돼서 테스트만을 위해 독립적으로 동작하는 테스트 대상을 사용할 것이기 때문에 스프링 컨테이너에서 빈을 가져올 필요가 없다.

**테스트 수행 성능의 향상**

- UserServiceImpl와 테스트를 도와주는 두 개의 목 오브젝트 외에는 사용자 관리 로직을 검증하는 데 직접적으로 필요하지 않은 의존 오브젝트와 서비스를 모두 제거했기 때문에 매우 빠르게 테스트가 가능하다.
- 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없다
- 테스트 수행 성능도 크게 향상된다.

### 단위 테스트와 통합 테스트

- 책에서의 테스트 정의
- 단위 테스트
    - 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트
- 통합 테스트
    - 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트
- 단위 테스트와 통합 테스트 간의 가이드라인 → 책 참고, 인간적으로 너무 길다 ㅋㅋㅋ

### 목 프레임워크

- MockUserDao처럼 목 오브젝트를 만드는 것은 매우 귀찮은 작업이다.

**Mockito 프레임워크**

```java
UserDao mockUserDao = mock(UserDao.class);
when(mockUserDao.getAll()).thenReturn(this.users);
verify(mockUserDao, times(2)).update(any(User.class));
```

- mockUserDao.getAll()이 호출될 때 users 리스트를 리턴해준다.
- User 타입의 오브젝트를 파라미터로 받으며 update() 메소드가 두 번 호출됐는지 확인하라.
- Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용한다
    - 인터페이스를 이용해 목 오브젝트를 만든다.
    - 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
    - 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
    - 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.

```java
@Test
public void mockUpgradeLevels() throws Exception() {
		UserServiceImpl userServiceImpl = new UserServiceImpl();

		UserDao mockUserDao = mock(UserDao.class);
		when(mockUserDao.getAll()).thenReturn(this.users);
		userServiceImpl.setUserDao(mockUserDao);

		MailSender mockMailSender = mock(MailSender.class);
		userServiceImpl.setMailSender(mockMailSender);

		userServiceImpl.upgradeLevles();

		verify(mockUserDao, times(2)).update(any(User.class));
		verify(mockUserDao, times(2)).update(any(User.class));
		verify(mockUserDao).update(users.get(1));
		assertThat(users.get(1).getLevel(), is(Level.SILVER));
		verify(mockUserDao).update(users.get(3));
		assertThat(users.get(3).getLevel(), is(Level.GOLD));
		
		...
}
```

- any() → 파라미터의 내용은 무시하고 호출 횟수만 확인할 수 있다.
- verify(mockUserDao).update(users.get(1)) → users.get(1)을 파라미터로 update()가 호출된 적이 있는지를 확인해준다.
- 레벨의 변화는 파라미터의 직접 비교로는 확인이 되지 않으므로 User 목록의 내용을 가지고 직접 확인해봐야한다.

# 10주차

## 다이내믹 프록시와 팩토리 빈

### 프록시와 프록시 패턴, 데코레이터 패턴

- 전략 패턴으로는 트랜잭션 기능의 구현 내용을 분리해냈을 뿐 트랜잭션을 적용한다는 사실은 코드에 그대로 남아있음
- 트랜잭션이라는 기능은 사용자 관리 비즈니스 로직과는 성격이 다르기 때문에 아예 그 적용 사실 자체를 밖으로 분리할 수 있음
- 이 방법을 통해 UserServiceTx를 만들었고, UserServiceImpl에는 트랜잭션 관련 코드가 하나도 남지 않게 됨.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/754a6723-1a6e-466b-91a5-711a2ccfcc4c/Untitled.png)
    
- 분리된 부가기능을 담은 클래스의 중요한 특징
    - 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다.
    - 핵심기능은 부가기능을 가진 클래스의 존재 자체를 모른다. (ex. UserServiceImpl은 UserServiceTx를 모른다.)
    - 따라서 부가기능이 핵심기능을 사용하는 구조가 되는 것이다.
- 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능이 적용될 기회가 없다.
- 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야 함.
- 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고, 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다. (UserService)
- 클라이언트는 핵심기능을 사용한다 생각하지만, 부가기능을 통해 핵심기능을 이용하게 된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/978fb7dd-a72d-41dc-bb99-8c4c5aff22f6/Untitled.png)

- 부가기능 → 핵심기능 연결과정에서 부가기능 적용 가능 (ex. 비즈니스 로직 코드에 트랜잭션 적용)
- 프록시
    - 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트 요청을 받아주는 것
- 타깃, 실체
    - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/3485e37e-df47-4388-a7c5-a6f09c119efb/Untitled.png)
    
- 프록시의 특징
    - 타깃과 같은 인터페이스를 구현 (UserServiceImpl과 UserService를 구현한 UserServiceTx)
    - 프록시가 타깃을 제어할 수 있는 위치에 있다.
- 프록시의 구분 (사용 목적에 따라 구분됨)
    - 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서
    - 타깃에 부가적인 기능을 부여해주기 위해서

**데코레이터 패턴**

- 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴
- 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있다 → 데코레이터
- 프록시가 꼭 한 개로 제한되지 않는다. (포장은 포장지, 리본, 스티커 등 다양하게 데코할 수 있음)
    - 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없다.
    - 같은 인터페이스를 구현한 타겟과 여러개의 프록시를 사용할 수 있다.
    - 단계적으로 위임하는 구조
- 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자기가 어디로 위임하는지 모름.
- 따라서 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.
- 인터페이스를 통해 위임하는 방식이기 때문에 어느 데코레이터에서 타깃으로 연결될지 코드 레벨에선 미리 알 수 없다.
- 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

**프록시 패턴**

- 디자인 패턴에서의 프록시 패턴
    - 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우
- 타깃의 기능을 확장하거나 추가하지 않는다.
- 클라이언트가 타깃에 접근하는 방식을 변경해준다.
- 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.
    - 하지만 타깃 오브젝트에 대한 레퍼런스가 미리 필요할 수 있다.
    - 이럴 때 프록시 패턴을 적용~!
- 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨준다.
- 프록시의 메소드를 통해 타깃을 사용하려고 하면, 그 때 본체를 넘겨준다.
- 이점은?
    - 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면, 프록시를 통해 생성을 최대한 늦추는게 장점이 많다.
- 원격 오브젝트를 이용하는 경우에도 편리하다.
    - 다양한 기술을 이용해 다른 서버에 존재하는 오브젝트를 사용해야 한다면, 프록시를 통해 클라이언트가 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼 프록시를 사용하게 할 수 있다.
    - 요청이 들어오면 프록시는 네트워크를 통해 원격의 오브젝트를 실행하고 결과를 반환해준다.
- 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위해
    - if) 수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 Read만 동작
    - 오브젝트의 프록시를 만들어서 특정 메소드를 사용하려고 하면 예외 발생
    - Collections의 unmodifiableCollection()이 한 예
        - 파라미터로 전달된 Collection 오브젝트의 프록시를 만들어서, add()나 remove() 같은 메소드를 호출할 때 UnsupportedOperationException 예외 발생
- 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용
- 데코레어터와 구조적으로 유사하나 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.
    - 물론 인터페이스를 통해 위임하도록 만들 수 있다.
- 앞으로는 타깃과 동일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서 기능의 부가 또는 접근 제어를 담당하는 오브젝트를 모두 프록시라고 하겠다. (UserServiceTx)

### 다이내믹 프록시

- 프록시
    - 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법
    - 근데 귀찮음 → 할 일이 많아짐 (새로운 클래스, 인터페이스 메소드 구현, 단위 테스트 등)
- 목처럼 뚝딱은 안되나?
- java.lang.reflect 패키지 안에 프록시를 손쉽게 만들 수 있돌록 지원해주는 클래스들이 있다.

**프록시의 구성과 프록시 작성의 문제점**

- 프록시는 다음의 두 가지 기능으로 구성된다.
    - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.
    - 지정된 요청에 대해서는 부가기능을 수행한다.

```java
public class UserServiceTx implements UserService {
		UserService userService;
		...
		
		public void add(User user) {
				this.userServcie.add(user);  // 메소드 구현과 위임
		}
		
		public void upgardeLevels() {
		  // 부가 기능 수행
		  TransactionStatus status = this.transactionManager.getTransaction
				  (new DefaultTransactionDefinition()); 
		  try {
				  userService.upgradeLevels(); // 위임
				  
				  // 부가 기능 수행
				  this.transactionManager.commit(status);
			} catch (RuntimeException e) {
					this.transactionManager.rollback(status);
					throw e;
			}
	}
}
```

- 프록시의 역할은 위임과 부가작업으로 구분 가능
- 프록시를 만들기가 번거로운 이유?
    - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다.
        - 부가기능이 필요 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
        - 타깃 인터페이스의 변경 때마다 같이 수정해줘야 함
    - 부가기능 코드가 중복될 가능성이 많다.
        - 트랜잭션은 DB를 사용하는 대부분의 로직에 적용될 필요가 있다.
- 이런 문제를 해결하는 데 유용한 것이 바로 JDK의 다이내믹 프록시다.

**리플렉션**

- 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
- 리플렉션
    - 자바의 코드 자체를 추상화해서 접근하도록 만든 것
    - 리플렉션 API 중에서 메소드에 대한 정의를 담은 Method라는 인터페이스를 이용해 메소드를 호출하는 방법

```java
Method lengthMethod = String.class.getMethod("length");
```

- String이 가진 메소드 중에서 “length”라는 이름을 갖고 있고, 파라미터는 없는 메소드의 정보를 가져오는 것
- 특정 오브젝트의 메소드를 실행시킬 수도 있다. → invoke() 사용
    - invoke() 메소드는 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려준다.

```java
public Object invoke(Object obj, Object... args)
int length = lengthMethod.invoke(name); // int length = name.length();
```

```java
public class ReflectionTest {
		@Test
		public void invokeMethod() throws Exception {
				String name = "Spring";
				
				// length()
				assertThat(name.length(), is(6));
				
				Method lengthMethod = String.class.getMethod("length");
				assertThat((Integer)lengthMethod.invoke(name), is(6));
				
				// charAt()
				assertThat(name.charAt(0), is('S'));
				
				Method charAtMethod = String.class.getMethod("charAt", int.class);
				assertThat((Character)charAtMethod.invoke(name, 0).is('S'));
		}
}
```

- charAtMethod.invoke(name, 0) → 오브젝트와 파라미터를 받아주는 모습

**프록시 클래스**

- 다이내믹 프록시를 이용한 프록시를 만들기 위한 예제

```java
interface Hello {
		String sayHello(String name);
		String sayHi(String name);
		String sayThankYou(String name);
}
```

- 인터페이스

```java
public class HelloTarget implements Hello {
		...
}
```

- 타깃

```java
@Test
public void simpleProxsy() {
		Hello hello = new HelloTarget();
		assertThat(hello.sayHello("Toby"), is("Hello Toby"));
		...
}
```

- 클라이언트

```java
public class HelloUppercase implements Hello {
		
		Hello hello; // 다른 프록시를 추가할 수 있으므로 인터페이스로 접근
		
		public HelloUppercase(Hello hello) {
				this.hello = hello;
		}
		
		public String sayHello(String name) {
				return hello.sayHello(name).toUppercase();
		}
		
		public String sayHi(String name) {
				return hello.sayHi(name).toUpperCase();
		}
		
		public String sayThankYou(String name) {
				return hello.sayThankYou(name).toUpperCase();
		}
}
```

- 프록시
- 데코레이터 패턴을 적용해서 타깃인 HelloTarget에 부가기능을 추가
    - 리턴하는 문자를 모두 대문자로 바꿔주는 것
- 위 프록시의 문제점
    - 인터페이스의 모든 메소드를 구현해 위임하도록 코드를 만들어야한다.
    - 부가기능인 리턴 값을 대문자로 바꾸는 기능이 모든 메소드에 중복돼서 나타난다.

**다이내믹 프록시 적용**

- HelloUppercase를 다이내믹 프록시를 이용해 만들어보자.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/5a3d131d-06f9-498e-85a4-d6f265209e50/Untitled.png)

- 다이내믹 프록시
    - 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트
    - 타깃의 인터페이스와 같은 타입으로 만들어진다.
    - 클라이언트는 타깃 인터페이스를 통해 다이내믹 프록시 오브젝트 사용 가능
        - 프록시를 만들 때 인터페이스를 모두 구현해가면서 클래스를 정의하는 수고를 덜 수 있다.
        - 프록시 팩토리가 인터페이스 정보를 제공받고 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어주기 때문
        - 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야 한다.
    - 부가 기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다.

```java
public Object invoke(Object proxy, Method method, Object[] args)
```

- InvocationHandler 인터페이스의 구성
- 다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 invoke() 메소드로 넘김
- 타깃 인터페이스의 모든 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.
- InvocationHandler 구현 오브젝트가 타깃 오브젝트 레퍼런스를 갖고 있다면 리플렉션을 이용해 간단히 위임 코드를 만들어낼 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/81504972-1561-444e-b6a6-e85151fc0e7e/Untitled.png)

```java
public class UppercaseHandler implements InvocationHandler {
		Hello target;
		
		public UppercaseHandler(Hello target) {
				this.target = target;  
				// 다이내믹 프록시로부터 전달받은 요청을 다시 타깃 오브젝트에 위임해야하기 때문에
				// 타깃 오브젝트를 주입해둔다.
		}
		
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				String ret = (String)method.invoke(target, args); // 타깃으로 위임
				return ret.toUppercase(); // 부가기능 제공
		}
}
```

- 다이내믹 프록시로부터 메소드 호출 정보를 받아서 처리하는 InvoicationHandler

```java
Hello proxiedHello = (Hello)Proxy.newProxyInstance(
					getClass().getClassLoader(),
					new Class[] { Hello.class }, // 구현할 인터페이스
					new UppercaseHandler(new HelloTarget())); // 부가기능과 위임 코드를 담은 InvocationHandler
```

- 다이내믹 프록시를 생성하는 코드
- 다이내믹 프록시의 생성에는 Proxy 클래스의 newProxyInstance() 스태틱 팩토리 메소드를 이용한다.
- 다이내믹 프록시는 한 번에 하나 이상의 인터페이스를 구현할 수도 있기 때문에 Class[]를 사용한다.

**다이내믹 프록시의 확장**

- 다이내믹 프록시 방식이 직접 정의해서 만든 프록시보다 훨씬 유연하고 많은 장점이 있다.
    - 인터페이스의 메소드가 늘어나도 전혀 손댈 게 없다.
    - 메소드의 리턴 타입이 달라진다면 코드를 조금만 수정하면 된다.
    - 어차피 리플렉션의 Method 인터페이스를 이용해 타깃의 메소드를 호출하기 때문에 타깃의 종류에 상관없이 적용이 가능하다.
    

### 다이내믹 프록시를 이용한 트랜잭션 부가기능

- UserServiceTx의 문제점
    - 서비스 인터페이스의 메소드를 모두 구현해야 함
    - 트랜잭션이 필요한 메소드마다 코드가 중복돼서 나타남
- 트랜잭션 부가기능을 제공하는 다이내믹 프록시를 만들어 적용하는 방법이 효율적이다.

**트랜잭션 InvocationHandler**

```java
public class TransactionHandler implements InvoactionHandler {
		private Object target;
		private PlatformTransactionManager transactionManager;
		prviate String pattern;
		
		public void setTarget(Object target) {
				this.target = target;
		}
		
		...
		
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				if (method.getName().startsWith(pattern) {
						return invokeInTransaction(method, args);
				} else {
						return method.invoke(target, args);
				}
		}
		
		private Object invokeInTransaction(Method method, Object[] args) throws Throwable {
				TransactionStatus status = this.transactionManager.getTransaction(
						new DefaultTransactionDefinition));
				try {
					  Object ret = method.invoke(target, args);
					  this.transactionManager.commit(status);
						return ret;
				} catch (InvocationTargetException e) {
						this.transactionManager.rollback(status);
						throw e.getTargetException();
				}
		}
}
```

- 타깃을 저장할 변수를 Object로 선언 → UserServiceImpl 외에 트랜잭션 적용이 필요한 어떤 타깃 오브젝트에도 적용 가능
- 타깃 오브젝트의 모든 메소드에 무조건 트랜잭션이 적용되지 않도록 트랜잭션을 적용할 메소드 이름의 패턴을 DI받는다.
    - pattern을 “get”으로 주면 get으로 시작하는 모든 메소드에 트랜잭션이 적용된다.
- 롤백을 적용하기 위한 예외는 RuntimeException 대신 InvocationTargetException으 랒ㅂ도록 해야 한다.
    - Method.invoke()를 이용해 타깃 오브젝트의 메소드를 호출할 때는 타깃 오브젝트에서 발생하는 예외가 InvocationTargetException으로 한 번 포장돼서 전달된다.

**TransactionHandler와 다이내믹 프록시를 이용하는 테스트**

```java
@Test
public void upgradeAllOrNothing() throws Exception {
		...
		TransactionHandler txHandler = new TransactionHandler();
		txHandler.setTarget(testUserService);
		txHandler.setTransactionManager(transactionManager);
		txHandler.setPattern("upgradeLevels");
		UserService txUserService = (UserService)Proxy.newProxyInstance(
				getClass().getClassLoader(),new Class[] { UserService.class }, txHandler);
		...
}
```

- UserServiceTx 대신 TransactionHandler를 이용하는 다이내믹 프록시를 사용하도록 테스트 수정

### 다이내믹 프록시를 위한 팩토리 빈

- TransactionHandler와 다이내믹 프록시를 스프링의 DI를 통해 사용할 수 있도록 만들고자 함.
- DI의 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 방법이 없는 것이 문제다.
- 스프링의 빈은 기본적으로 클래스 이름과 프로퍼티로 정의된다.
- 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해서 해당 클래스의 오브젝트를 만든다.
- 다이내믹 프록시 오브젝트는 이런 식으로 프록시 오브젝트가 생성되지 않는다.
- 클래스 자체도 내부적으로 다이내믹하게 새로 정의해서 사용하기 때문에 다이내믹 프록시 오브젝트의 클래스가 어떤 것인지 알 수 없다
- 따라서 스프링 빈에 정의할 방법이 없다.
- 다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.

**팩토리 빈**

- 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈
- 스프링의 FactoryBean이라는 인터페이스를 구현하는 방법으로 만들 수 있다.

```java
public interface FactoryBean<T> {
		T getObject() throws Exception; // 빈 오브젝트를 생성해서 돌려준다.
		Class<? extends T> getObjectType(); // 생성되는 오브젝트의 타입을 알려준다.
		boolean isSingleton(); // getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려준다.
```

- FactoryBean 인터페이스
- 위를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.

- Message는 생성자가 private으로 되어있어 오브젝트를 만들려면 반드시 스태틱 메소드를 사용해야 한다.
- 따라서 이 클래스를 직접 스프링 빈으로 등록해서 사용할 수 없다.
- 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트를 만들어준다.
- 리플렉션은 private으로 선언된 접근 규약을 위반할 수 있는 강력한 기능이 있기 때문이다.
- 하지만 생성자를 private으로 만들었다는 것은 스태틱 메소드를 통해 오브젝트가 만들어져야 하는 중요한 이유가 있기 때문이므로 이를 무시하고 오브젝트를 강제로 생성하면 위험하다.

```java
public class MessageFactoryBean implements FactoryBean<Message> {
		
		// 오브젝트를 생성할 때 필요한 정보를 팩토리 빈의
		// 프로퍼티로 설정해서 대신 DI 받을 수 있게 한다.
		// 주입된 정보는 오브젝트 생성 중에 사용된다.
		String text;
		
		public void setText(String text) {
				this.text = text;
		}
		
		// 실제 빈으로 사용될 오브젝트를 직접 생성한다.
		// 코드를 이용하기 때문에 복잡한 방식의 오브젝트 생성과 초기화 작업도 가능하다.
		public Message getObject() throws Exception {
				return Message.newMessage(this.text);
		}
		
		public Class<? extends Message> getObjectType() {
				return Message.class;
		}
		
		// getObject() 메소드가 돌려주는 오브젝트가 싱글톤인지를 알려준다.
		// 이 팩토리 빈은 매번 요청할 때마다 새로운 오브젝트를 만들므로 false로 설정한다.
		// 이것은 팩토리 빈의 동작방식에 관한 설정이고 만들어진 빈 오브젝트는
		// 싱글톤으로 스프링이 관리해줄 수 있다.
		public boolean isSingleton() {
				return false;
		}
}
```

- Message의 팩토리 빈 클래스
- 팩토리 빈은 전형적인 팩토리 메소드를 가진 오브젝트다.
- 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면, 팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용한다.
- 빈의 클래스로 등록된 팩토리 빈은 빈 오브젝트를 생성하는 과정에서만 사용될 뿐이다.

**팩토리 빈의 설정 방법**

- 팩토리 빈의 설정은 일반 빈과 다르지 않다.
- 여타 빈 설정과 다른 점은 message 빈 오브젝트의 타입이 class 애트리뷰트에 정의된 MessageFactoryBean이 아니라 Message 타입이라는 것이다.
- getObjectType() 메소드가 돌려주는 타입이 빈의 타입이 된다.
- getObject() 메소드가 생성해주는 오브젝트가 빈의 오브젝트가 된다.

```java
@Test
public void getFactoryBean() throws Exception {
		Object factory = context.getBean("&message");
		assertThat(factory, is(MessageFactoryBean.class));
```

- 스프링은 ‘&’를 빈 이름 앞에 붙여주면 팩토리 빈 자체를 돌려준다.

**다이내믹 프록시를 만들어주는 팩토리 빈**

- 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다.
- 팩토리 빈을 사용하면 가능하다.
    - 팩토리 빈의 getObject() 메소드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 되기 때문이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/56f8674c-b7f8-431b-959d-039c2adc7429/Untitled.png)

- 스프링 빈 : 팩토리 빈, UserServiceImpl
- 팩토리 빈은 다이내믹 프록시의 타깃 오브젝트 UserServiceImpl에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둬야 한다.
    - 다이내믹 프록시와 함께 생성할 TransactionHandler에게 타깃 오브젝트를 전달해줘야 하기 때문

**트랜잭션 프록시 팩토리 빈**

```java
public class TxProxyFactoryBean implements FactoryBean<Object> {
		// TransactionHandler를 생성할 때 필요
		Object target;
		PlatformTransactionManager transactionManager;
		String pattern;
		Class<?> serviceInterface; // UserService 외의 인터페이스를 가진 타깃에도 적용
		
		public void setTarget(Object target) {
				this.target = target;
		}
		
		public void setTransactionManager(PlatformTransactionManager transactionManager) {
				this.transactionManager = transactionManager;
		}
		
		public void setPattern(String pattern) {
				this.pattern = pattern;
		}
		
		public void setServiceInterface(Class<?> serviceInterface) {
				this.serviceInterface = serviceInterface;
		}
		
		// FactoryBean 인터페이스 구현 메소드
		// DI 받은 정보를 이용해서 TransactionHandler를 사용하는 다이내믹 프록시를 생성
		public Object getObject() throws Exception {
				TransactionHandler txHandler = new TransactionHandler();
				txHandler.setTarget(target);
				txHandler.setTransactionManager(transactionManager);
				txHandler.setPattern(pattern);
				return Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]
						 { serviceInterface }, txHandler);
				}
				
		public Class<?> getObjectType() {
				return serviceInterface;
		}
		
		public boolean isSingleton() {
				return false;
		}
}
```

- UserServiceTx를 대체하는 TxProxyFactoryBean
- Class 타입은 value를 이용해 클래스 또는 인터페이스의 이름을 넣어주면 빈 설정이 가능하다.

```java
<property name="serviceInterface" value="springboot.user.service.UserService"/>
```

**트랜잭션 프록시 팩토리 빈 테스트**

- add() 메소드를 제외한 나머지 메소드가 현재 팩토리 빈이 적용되지 않는 상황
- upgradeAllOrNothing() 테스트에서 타깃 오브젝트로 TestUserService가 동작하도록 해야 함.
- 스프링 빈에서 생성되는 프록시 오브젝트에 대해 테스트를 해야 하기 때문에 간단하지 않음
- 타깃 오브젝트에 대한 레퍼런스는 TransactionHandler 오브젝트가 가지고 있는데, 이는 TxProxyFactoryBean 내부에서 만들어져서 별도로 참조할 방법이 없음.
- 빈으로 등록된 TxProxyFactoryBean을 직접 가져와서 프록시를 만들자.
- “&”를 붙여 팩토리 빈 자체를 가져올 수 있다.

```java
TxProxyFactoryBean txProxyFactoryBean =
		context.getBean("&userService", TxProxyFactoryBean.class);
txProxyFactoryBean.setTarget(testUserService);
UserService txUserService = (UserService) txProxyFactoryBean.getObject();
```

- 매번 트랜젹션 기능을 담은 UserServiceTx와 같은 프록시 클래스를 작성하는 번거로움을 완벽하게 제거했다.

### 프록시 팩토리 빈 방식의 장점과 한계

**프록시 팩토리 빈의 재사용**

- 인터페이스는 CoreService라고 하고 이에 정의된 수십여개의 메소드에 트랜잭션을 모두 적용해야 하는 상황을 가정해보자.

## 스프링의 프록시 팩토리 빈

### ProxyFactoryBean

- 스프링은 프록시 기술에 서비스 추상화를 적용한다.
- 생성된 프록시는 스프링의 빈으로 등록돼야 한다.
- 스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다.
- 스프링의 ProxyFactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.
- ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 부가기능은 별도의 빈에 둘 수 있다.
- ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.
- MethodInterceptor vs InvocationHandler
    - InvocationHandler의 invoke() 메소드는 타깃 오브젝트에 대한 정보를 제공하지 않는다.
    - InvocationHandler를 구현한 클래스가 타깃을 직접 알아야 한다.
    - MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보도 함께 제공받는다.
- MethodInterceptor는 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.
- 타깃이 다른 여러 프록시에 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능하다.

```java
public class DynamicProxyTest {
		
		@Test
		public void simpleProxy() {
				Hello proxiedHello = (Hello)Proxy.newProxyInstance(
						getClass().getClassLoader(),
						new Class[] { Hello.class },
						new UppercaseHandler(new HelloTarget()));
				...
		}
		
		@Test
		public void proxyFactoryBean() {
				ProxyFactoryBean pfBean = new ProxyFactoryBean();
				pfBean.setTarget(new HelloTarget()); // 타깃 설정
				prfBean.addAdvice(new UppercaseAdvice()); // 부가기능 설정
				
				Hello proxiedHello = (Hello) pfBean.getObject(); // 생성된 프록시 가져오기
				assertThat(proxiedHello.sayHello("Toby"), is("HELLO TOBY"));
				assertThat(proxiedHello.sayHi("Toby"), is("HI TOBY"));
				assertThat(proxiedHello.sayThankYou("Toby"), is("THANK YOU TOBY"));
		}
		
		static class UppercaseAdvice implements MethodInterceptor {
		    // MethodInvocation은 메소드 정보와 함 타깃 오브젝트를 알고 있음
				public Object invoke(MethodInvocation invocation) throws Throwable {
						String ret = (String)invocation.proceed();
						return ret.toUpperCase();
				}
		}
		
		static interface Hello { // 타깃과 프록시가 구현할 인터페이스
				String sayHello(String name);
				String sayHi(String name);
				String sayThankYou(String name);
		}
		
		static class HelloTarget implements Hello { // 타깃
				public String sayHello(String name) { return "Hello " + name; }
				public String sayHi(String name) { return "Hi " = name; }
				public String sayThankYou(String name) { return "Thank You " + name; }
		}
}
```

**어드바이스: 타깃이 필요 없는 순수한 부가기능**

- JDK 다이내믹 프록시와의 차이점
- MethodInterceptor를 구현한 UppercaseAdvice에는 타깃 오브젝트가 등장하지 않는다.
- MethodInvocation은 메소드 정보와 함께 타깃 오브젝트를 가지고 있기 때문에 MethodInterceptor는 부가기능을 제공하는 데만 집중할 수 있다.
- proceed() : 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있다.
- MethodInvocation 구현 클래스는 일종의 공유 가능한 템플릿처럼 동작하는 것이다.

→ ProxyFactoryBean의 장점

- ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있다.
- ProxyFactoryBean에 이 MethodInterceptor를 설정해 줄 때는 DI 대신 addAdvice()를 사용한다.
    - 여러 개 추가 가능
    - ProxyFactoryBean 하나만으로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다.
    - 프록시 팩토리 빈의 단점인 새로운 부가기능 추가할 때마다 프록시와 프록시 팩토리 빈도 추가해줘야 한다는 문제 해결
- 왜 addMethod~가 아니라 addAdvice()?
    - MethodInterceptor가 Advice 인터페이스를 상속하고 있는 서브 인터페이스이기 때문
- 어드바이스
    - MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트
- 또한 프록시가 구현해야 하는 Hello라는 인터페이스를 제공해주는 부분이 없다.
    - ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아냄.
    - 알아낸 인터페이스를 모두 구현하는 프록시를 만들어준다.
    - 일부만 프록시에 적용하기를 원한다면 인터페이스 정보를 직접 제공해줘도 된다.

**포인트컷: 부가기능 적용 대상 메소드 선정 방법**

- 기존에는 메소드의 이름을 가지고 부가기능을 적용할 대상 메소드를 선정했다.
    - ex. TxProxyFactoryBean → pattern
- ProxyFactoryBean과 MethodInterceptor에서도 가능?
    - 불가능
    - MethodInterceptor은 여러 프록시가 공유해서 사용할 수 있음
    - 타깃 정보를 갖고 있지 않도록 만들어짐
    - 그 덕분에 스프링의 싱글톤 빈으로 등록 가능
    - 그래서 메소드 이름 패턴 넣는 것은 곤란.
- MethodInterceptor는 InvocationHandler와는 다르게 프록시가 클라이언트로부터 받는 요청을 일일이 전달받을 필요는 없다.
- MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남겨주는 것이다.
- 대신 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣자.
- 물론 메소드 선별하는 기능은 프록시로부터 다시 분리하는 편이 낫다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/cea472f5-2bc9-46cc-9971-81027aeb6733/Untitled.png)

- 기존 방식도 다이내믹 프록시와 부가기능을 분리할 수 있고, 부가기능 적용 대상 메소드를 선정할 수 있게 되어있다.
- 문제는 부가기능을 가진 InvocationHandler가 타깃과 메소드 선정 알고리즘 코드에 의존하고 있다는 점이다.
- 타깃과 메소드 선정 방식이 다르다면 여러 프록시가 InvocationHandler 오브젝트를 공유할 수 없다.
- 그래서 TxProxyFactoryBean 내부에서 매번 InvocationHandler를 생성하도록 만들었던 것이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/5672cea4-206e-4874-bec4-5aba6b37bfde/Untitled.png)

- 스프링의 ProxyFactoryBean 방식은 두 가지 확장 기능인 부가기능(Advice)과 메소드 선정 알고리즘(PointCut)을 활용하는 유연한 구조를 제공한다.
- 어드바이스와 포인트컷은 모두 프록시에 DI로 주입돼서 사용된다.
    - 포인트컷은 PointCut 인터페이스를 구현해서 만든다.
- 두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.
- 프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메소드인지를 확인해달라고 요청한다.
- 프록시는 이를 확인받으면, MethodInterceptor 타입의 어드바이스를 호출한다.
- 어드바이스는 직접 타깃을 호출하지 않는다.
- 자신이 공유돼야하므로 타깃 정보라는 상태를 가질 수 없다.
- 따라서 타깃에 직접 의존하지 않도록 일종의 템플릿 구조로 설계되어있다.
- 어드바이스가 부가기능을 부여하는 중에 타깃 메소드의 호출이 필요하면 프록시부터 전달받은 methodInvocation 타입 콜백 오브젝트의 proceed() 메소드를 호출해주기만 하면 된다.
- 실제 위임 대상인 타깃 오브젝트의 레퍼런스를 갖고 있고, 이를 이용해 타깃 메소드를 직접 호출하는 것은 프록시가 메소드 호출에 따라 만드는 Invocation 콜백의 역할이다.
- 재사용 가능한 기능을 만들어두고 바뀌는 부분(콜백 오브젝트와 메소드 호출정보)만 외부에서 주입해서 이를 작업 흐름(부가기능 부여) 중에 사용하도록 하는 전형적인 템플릿/콜백 구조다.
- 어드바이스가 일종의 템플릿이 되고 타깃을 호출하는 기능을 갖고 있는 MethodInvocation 오브젝트가 콜백이 되는 것이다.
- 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조다.
    - 템플릿은 한 번 만들면 재사용이 가능하고 여러 빈이 공유해서 사용할 수 있듯이, 어드바이스도 독립적인 싱글톤 빈으로 등록하고 DI를 주입해서 여러 프록시가 사용하도록 만들 수 있다.

```java
@Test
public void pointcutAdvisor() {
		ProxyFactoryBean pfBean = new ProxyFactoryBean();
		pfBean.setTarget(new HelloTarget());
		
		NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
		pointcut.setMappedName("sayH*");
		
		// 포인트컷과 어드바이스를 Advisor로 묶어서 한 번에 추가
		pfBean.addAdvisor(new DefaultPointcutAdvisor(pointcut, new UppercaseAdvice()));
		
		Hello proxiedHello = (Hello) pfBean.getObject();
		
		assertThat(proxiedHello.sayHello("Toby"), is("HELLO TOBY"));
		assertThat(proxiedHello.sayHi("Toby"), is("HI TOBY"));
		assertThat(proxiedHello.sayThankYou("Toby"), is("Thank You TOBY"));
}
```

- 포인트컷을 함께 등록할 때는 addAdvice() 대신 어드바이스와 포인트컷을 Advisor 타입으로 묶어서 addAdvisor() 메소드를 호출해야 한다.
- 왜 별개의 오브젝트를 묶어서 등록?
    - ProxyFactoryBean에는 여러 개의 어드바이스와 포인트컷이 추가될 수 있기 때문
    - 따로 등록하면 어떤 어드바이스(부가기능)가 어떤 포인트컷(메소드)에 적용되는지 애매
- 어드바이저
    - 어드바이스 + 포인트컷

### ProxyFactoryBean 적용

**TransactionAdvice**

```java
public class TransactionAdvice implements MethodInterceptor {
		PlatformTransactionManager transactionManager;
		
		public void setTransactionManager(PlatformTransactionManager transactionManager) {
				this.transactionManager = transactionManager;
		}
		
		public Object invoke(MethodInvocation invocation) throws Throwable {
				TransactionStatus status =
						this.transactionManager.getTransaction(new DefaultTransactionDefinition());
				try {
						Object ret = invoaction.proceed();
						this.transactionManager.commit(status);
						return ret;
				} catch (RuntimeException e) {
						this.transactionManager.rollback(status);
						throw e;
				}
		}
}
```

- JDK 다이내믹 프록시 방식으로 만든 TransactionHandler의 코드에서 타깃과 메소드 선정 부분을 제거해줌.
- 리플렉션을 통한 타깃 메소드 호출 작업의 번거로움은 MethodInvocation 타입의 콜백을 이용한 덕분에 대부분 제거할 수 있다.

**스프링 XML 설정파일**

```xml
<bean id="transactionAdvice" class="springbook.user.service.TransactionAdvice">
		<property name="transactionManager" ref="transactionManager" />
</bean>
```

- 어드바이스 등록
- 트랜잭션 기능 적용을 위해 transactionManager DI

```xml
<bean id="transactionPointcut"
			class="org.springframework.aop.support.NameMatchMethodPointcut">
		<property name="mappedName" value="upgrade*" />
</bean>
```

- 트랜잭션 적용 메소드 선정을 위한 포인트컷 빈 등록

```xml
<bean id="transactionAdvisor"
			class="org.springframework.aop.support.DefaultPoincutAdvisor">
		<property name="advice" ref="transactionAdvice" />
		<property name="pointcut" ref="transactionPoincut" />
</bean>
```

- 어드바이저 빈 등록

```xml
<bean id="userService" 
      class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target" ref="userServiceImpl" />
    <property name="interceptorNames">
		    <list>
				    <value>transactionAdvisor</value>
				</list>
		</property>
</bean>
```

- ProxyFactoryBean 등록
- 여러 개를 넣기 위해 list와 value 태그 이용

**테스트**

- 다른 테스트는 괜찮 → 트랜잭션 신경 안 써서
- upgradeAllOrNothing()이 문제
- 스프링의 ProxyFactoryBean도 팩토리 빈이므로 기존의 TxProxyFactoryBean과 같은 방법을 테스트할 수 있음.

```java
@Test
@DirtiesContext
public void upgradeAllOrNothing() {
		TestUserService testUserService = new TestUserService(users.get(3).getId());
		testUserService.setUserDao(userDao);
		testUserService.setMailSender(mailSender);
		
		ProxyFactoryBean txProxyFactoryBean = 
				context.getBean("&userService", ProxyFactoryBean.class); // userService의 빈 변경
		txProxyFactoryBean.setTarget(testUserService);
		UserService txUserService = (UserService) txProxyFactoryBean.getObject();
		...
}
```

**어드바이스와 포인트컷의 재사용**

- ProxyFactoryBean은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다.
- 그 덕분에 독립적이며, 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있었다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/30edeede-ca4b-42dc-a672-545ff6a80b98/Untitled.png)

- ProxyFactoryBean을 이용해서 많은 수의 서비스 빈에게 트랜잭션 부가기능을 적용했을 때의 구조다.
- TransactionAdvice는 하나만 만들어서 싱글톤 빈으로 등록해주면, DI를 통해 모든 서비스에 적용이 가능하다.
- 메소드 선정 방식이 달라지는 경우만 포인트컷의 설정을 따로 등록하고 어드바이저로 조합해서 적용해주면 된다.

## 스프링 AOP

- 투명하다
    - 부가기능을 적용한 후에도 기존 설계와 코드에는 영향을 주지 않는다.
    - 언제든지 자유롭게 추가하거나 제거할 수 있고, 기존 코드는 항상 원래의 상태를 유지할 수 있다.

### 자동 프록시 생성

- 프록시 팩토리 빈 방식의 접근 방법의 한계라고 생각했던 두 가지 문제가 있었다.
- 한 가지는 해결.
- 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해주는 부분이다.
- 새로운 타깃이 등장했다고 해서 코드를 손댈 필요는 없어졌지만, 설정은 매번 복사해서 붙이고 target 프로퍼티의 내용을 수정해줘야 한다.
- 이런 류의 중복은 더 이상 제거할 방법은 없는 것일까?

**중복 문제의 접근 방법**

- JDBC API를 사용하는 DAO 코드에서 try/catch/finally 블록이 반복되는 구조
    - 바뀌지 않는 부분과 바뀌는 부분을 구분해서 분리
    - 템플릿과 콜백, 클라이언트로 나누는 방법을 통해 해결
    - 전략 패턴과 DI를 적용
- 반복적인 위임 코드가 필요한 프록시 클래스 코드
    - 다이내믹 프록시라는 런타임 코드 자동생성 기법을 이용해서 해결
    - 의미 있는 부가기능 로직인 트랜잭션 경계설정은 코드로 만들고 기계적인 코드인 타깃 인터페이스 구현과 위임, 부가기능 연동 부분은 자동생성하게 함

**빈 후처리기를 이용한 자동 프록시 생성기**

- 스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 확장 포인트를 제공해준다.
- BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기
- 이름 그대로 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.
- DefaultAdvisorAutoProxyCreator
    - 어드바이저를 이용한 자동 프록시 생성기
    - 빈 후처리기 자체를 빈으로 등록함으로써 스프링에 적용 가능
    - 빈 오브젝트의 프로퍼티를 강제로 수정할 수 있고 별도의 초기화 작업을 수행할 수도 있다.
    - 심지어 만들어진 빈 오브젝트 자체를 바꿔치기할 수도 있다.
- 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다.
- 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수도 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/1588eac2-2b1c-456b-b897-9e709dfd00a6/Untitled.png)

- DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.
- DefaultAdvisorAutoProxyCreator은 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용대상인지 확인한다.
- 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해준다.
- 빈 후처리기는 프록시가 생성되면 원래 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려준다.
- 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.
- 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있다.

**확장된 포인트컷**

- 포인트컷
    - 어떤 메소드에 부가기능을 적용할지 선정해주는 역할
- 위에서는 어떤 빈에 프록시를 적용할지를 선택한다는 식으로 설명하고 있음
- 사실 두 가지 기능을 모두 갖고 있음

```java
public interface Poincut {
		ClassFilter getClassFilter(); // 프록시를 적용할 클래스인지 확인
		MethodMatcher getMethodMatcher(); // 어드바이스를 적용할 메소드인지 확인
}
```

- 어차피 ProxyFactoryBean에서 포인트컷을 사용할 때는 이미 타깃에 정해져 있기 때문에 포인트컷은 메소드 선별만 해주면 그만이었다.
- 이 두 가지 조건이 모두 충족되는 타깃의 메소드에 어드바이스가 적용됨.
- DefaultAdvisorAutoProxyCreator는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트컷이 필요하다.

**포인트컷 테스트**

- 앞에서 사용한 NameMatchMethodPointcut은 클래스 필터 기능이 아예 없다. (있으나 마나한)
- 이 클래스를 확장해서 클래스도 고를 수 있도록 하겠다.
- 프록시 적용 후보 클래스를 여러 개 만들어두고 이 포인트컷을 적용한 ProxyFactoryBean으로 프록시를 만들도록 해서 어드바이스가 적용되는지 여부를 확인하겠다.

```java
@Test
void classNamePointcutAdvisor() {
		// 포인트컷 준비
    NameMatchMethodPointcut classMethodPointcut = new NameMatchMethodPointcut() {
        public ClassFilter getClassFilter() {
            return new ClassFilter() {
                @Override
                public boolean matches(Class<?> clazz) {
                    return clazz.getSimpleName().startsWith("HelloT");
                }
            };
        }
    };
    classMethodPointcut.setMappedName("sayH*");

    checkAdviced(new HelloTarget(), classMethodPointcut, true);

    class HelloWorld extends HelloTarget{
    };
    checkAdviced(new HelloWorld(), classMethodPointcut, false);

    class HelloToby extends HelloTarget{};
    checkAdviced(new HelloToby(), classMethodPointcut, true);

}

private void checkAdviced(Object target, Pointcut pointcut, boolean adviced) {
    ProxyFactoryBean pfBean = new ProxyFactoryBean();
    pfBean.setTarget(target);
    pfBean.addAdvisor(new DefaultPointcutAdvisor(pointcut, new UppercaseAdvice()));
    Hello proxiedHello = (Hello)pfBean.getObject();

    if (adviced) {
        assertThat(proxiedHello.sayHello("Toby")).isEqualTo("HELLO TOBY");
        assertThat(proxiedHello.sayHi("Toby")).isEqualTo("HI TOBY");
        assertThat(proxiedHello.sayThankYou("Toby")).isEqualTo("Thank you Toby");
    } else {
        assertThat(proxiedHello.sayHello("Toby")).isEqualTo("Hello Toby");
        assertThat(proxiedHello.sayHi("Toby")).isEqualTo("Hi Toby");
        assertThat(proxiedHello.sayThankYou("Toby")).isEqualTo("Thank you Toby");
    }
}
```

- 원래 모든 클래스를 다 받아주는 클래스 필터를 리턴하던 getClassFilter()를 오버라이드해서 이름이 HelloT로 시작하는 클래스만을 선정해주는 필터로 만들었다.
- 포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면 아무리 프록시를 ㅓㄱ용했다고 해도 부가기능은 전혀 제공되지 않는다는 점에 주의해야 한다.

# 12주차

### DefaultAdvisorAutoProxyCreator의 적용

- 프록시 자동생성 방식에서 사용할 포인트컷을 만드는 방법을 살펴봤으니 실제로 적용할 차례다.

**클래스 필터를 적용한 포인트컷 작성**

- 메소드 이름만 비교하던 포인트컷인 NameMatchMethodPointcut을 상속해서 프로퍼티로 주어진 이름 패턴을 가지고 클래스 이름을 비교하는 ClassFilter를 추가하도록 만들 것이다.

```java
public class NameMatchClassMethodPointcut extends NameMatchMethodPointcut {
		public void setMappedClassName(String mappedClassName) {
				this.setClassFilter(new SimpleClassFilter(mappedClassName));
		}
		
		static class SimpleClassFilter implements ClassFilter {
				String mappedName;
				
				private SimpleClassFilter(String mappedName) {
						this.mappedName = mappedName;
				}
				
				public boolean matches(Class<?> clazz) {
						return PatternMatchUtils.simpleMatch(mappedName, clazz.getSimpleName());
				}
		}
}
```

- 클래스 필터 기능이 추가된 포인트컷

**어드바이저를 이용하는 자동 프록시 생성기 등록**

- 적용할 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다.
- 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 적용 대상을 선정한다.
- 선정 대상이라면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기한다.
    - 원래 빈 오브젝트는 프록시 뒤에 연결돼서 프록시를 통해서만 접근 가능하게 바뀌는 것이다.
    - 타깃 빈에 의존한다고 정의한 다른 빈들은 프록시 오브젝트를 대신 DI 받게 될 것이다.

```xml
<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorProxyCreator" />
```

- DefaultAdvisorAutoProxyCreator 등록

**포인트컷 등록**

```xml
<bean id="transactionPointcut"
			class="springbook.service.NameMatchMethodPointcut">
		<property name="mappedClassName" value="*ServiceImpl" />
		<property name="mappedName" value="upgrade*" />
</bean>
```

- ServiceImpl로 끝나는 클래스 선정
- upgrade로 시작하는 메소드 선정

**어드바이스와 어드바이저**

- 어디바이스와 어드바이저는 수정할 게 없다.
- 하지만 어드바이저로서 사용되는 방법이 바뀌었다.
- 명시적으로 DI 하는 빈은 존재하지 않고, 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator에 의해 자동수집되고, 프록시 대상 선정 과정에 참여하며, 자동생성된 프록시에 다이내믹하게 DI돼서 동작하는 어드바이저가 된다.

**ProxyFactoryBean 제거와 서비스 빈의 원상 복구**

- 기존 p.432에서 데코래이터 패턴을 위한 DI 설정 과정에서 bean id를 userServiceImpl로 설정함
- 더 이상 명시적인 프록시 팩토리 빈을 등록하지 않기 때문에 이를 다시 userService로 고쳐줌

```xml
<bean id="userService" class="springbook.service.UserServiceImpl">
			<property name="userDao" ref="userDao" />
			<property name="mailSender" ref="mailSender" />
</bean>
```

**자동 프록시 생성기를 사용하는 테스트**

- @Autowired를 통해 컨텍스트에서 가져오는 UserServie 타입 오브젝트는 UserServiceImpl 오브젝트가 아니라 트랜잭션이 적용된 프록시여야 한다.
- 지금까지 사용한 방법
    - ProxyFactoryBean이 빈으로 등록되어 있었으므로 이를 가져와 타깃을 테스트용 클래스로 바꿔치기
- 자동 프록시 생성기를 적용한 후에는 가져올 팩토리 빈이 존재하지 않음.
- 자동 프록시 생성기가 알아서 프록시를 만들어줬기 때문에 프록시 오브젝트만 남아 있을 뿐이다.
- 예외상황을 위한 테스트 대상도 빈으로 등록하자
    - 타깃을 코드에서 바꿔치기할 수 없다.
    - 자동 프록시 생성기의 적용이 되는지도 빈을 통해 확인할 필요가 있다.

```java
static class TestUserServiceImpl extends UserServiceImpl {
		private String id = "madnite1";
		
		protected void upgradeLevel(User user) {
				if (user.getId().equals(this.id)) throw new TestUserServiceException();
				super.upgradeLevel(user);
		}
}
```

- 수정한 테스트용 UserService 구현 클래스
    - 클래스 이름을 포인트컷이 선정해줄 수 있도록 ServiceImpl로 끝나게 한다.
    - 테스트 코드에서 생성하는 것이 아니기 때문에 테스트 픽스처로 만든 users 리스트에서 예외를 발생시킬 기준 id를 가져와 사용할 방법이 없으므로 아예 클래스에 넣어버리자.

```xml
<bean id="testUserService"
			class="springbook.user.service.UserServiceTest$TestUserServiceImpl"
			parent="userService" />
```

- 테스트용 UserService의 등록
    - $ : 스태틱 멤버 클래스를 지정할 때 사용하는 것이다.
    - parent 애트리뷰트 : 다른 빈 설정 내용을 상속받을 수 있다. (클래스 + 프로퍼티 설정 상속)
        - 별도로 userDao나 mailSender 프로퍼티를 지정해줄 필요가 없다.

```java
public class UserServiceTest {
		@Autowired UserService userService;
		@Autowired UserService testUserService;
		...
		
		@Test
		public void upgradeAllOrNothing() {
				userDao.deleteAll();
				for(User user : users) userDao.add(user);
				
				try {
						this.testUserServie.upgradeLevels();
						fail("TestUserServiceExcpetion expected");
				} catch (TestUserServiceException e) {
				}
				
				checkLevelUpgraded(users.get(1), false);
		}
}
```

- userService 빈과 타입이 중복되므로 변수 이름을 빈 이름과 일치시켜주었다. (testUserService)
- upgradeAllOrNothing() 테스트도 테스트 코드에서 예외상황을 적용하기 위한 DI 작업이 제거됐기 때문에 코드가 단순해졌다.

**자동 생성 프록시 확인**

- 무슨 기술이든 자동으로 무엇을 해준다고 하면 정말 그런지 한 번쯤은 직접 확인해보는 습관을 들이는 편이 좋다.
- 지금까지 트랜잭션 어드바이스를 적용한 프록시 자동생성기를 빈 후처리기 메커니즘을 통해 적용했다.
    - 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가?
        - upgradeAllOrNothing() 테스트를 통해 검증했다.
    - 아무 빈에나 트랜잭션 부가기능이 적용된 것은 아닌가?
        - 클래스 필터가 제대로 동작해서 프록시 생성 대상을 선별하고 있는지 여부를 확인하자.
        - 포인트컷 빈의 클래스 이름 패턴을 변경해서 이번엔 testUserService 빈에 트랜잭션이 적용되지 않게 해보자.
- DefaultAdvisorAutoProxyCreator에 의해 userService 빈이 프록시로 바꿔치기됐다면 getBean(”userService”)로 가져온 오브젝트는 TestUserService 타입이 아니라 JDK의 Proxy 타입일 것이다.

```java
@Test
public void advisorAutoProxyCreator() {
		assertThat(testUserService, is(java.lang.reflect.Proxy.class));
}
```

- 자동생성된 프록시 확인

### 포인트컷 표현식을 이용한 포인트컷

- 지금까지 사용햇던 포인트컷
    - 메소드의 이름과 클래스의 이름 패턴을 각각 클래스 필터와 메소드 매처 오브젝트로 비교해서 선정하는 방식
    - 일일이 클래스 필터와 메소드 매처를 구현하거나, 스프링이 제공하는 필터나 매처 클래스를 가져와 프로퍼티를 설정하는 방식을 사용해야 했다.
    - 단순한 이름을 비교하는 일이 전부
- 필터나 매처에서 클래스와 메소드의 메타정보를 제공받으니 어떤 식이든 불가능할 것은 없다.
- 리플렉션 API를 통해서 클래스와 메소드의 이름, 정의된 패키지, 파라미터, 리턴 값은 물론이고 부여된 애노테이션이나 구현한 인터페이스, 상속한 클래스 등의 정보까지도 알아낼 수 있기 때문이다.
    - ~~프라이버시가 없는 편인가…?~~
- 하지만 리플렉션 API는 코드를 작성하기가 제법 번거롭다는 단점이 있다.
- 또한 리플렉션 API를 이용해 메타정보를 비교하는 방법은 조건이 달라질 때마다 포인트컷 구현 코드를 수정해야 하는 번거로움도 있다.

**포인트컷 표현식**

- 스프링이 아주 간단하고 효과적인 방법으로 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 작성할 수 있는 방법을 제공
- 정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 하는 방법
    - ~~또 당신입니까 스프링…~~
- AspectJExpressionPointcut 클래스 사용
- 기존
    - 클래스 필터와 메소드 매처 두 가지를 제공해줌
    - ex. NameMatchClassMethodPointcut
- AspectJExpressionPointcut
    - 포인트컷 표현식을 이용해 클래스와 메소드의 선정 알고리즘을 한 번에 지정
    - 자바의 RegEx 처럼 지원해줌
    - AspectJ라는 유명한 프레임워크에서 제공하는 것을 가져와 사용하는 거라 AspectJ 포인트컷 표현식이라고도 한다.

```java
public class Target implements TargetInterface {
		public void hello() {}
		public void hello(String a) {}
		public int minus(int a, int b) throws RuntimeExcpeption { return 0; }
		public int plus(int a, int b) { return 0; }
		public void method() {}
}
```

- 포인트컷 테스트용 클래스
- hello() ~ plus()
    - TargetInterface에 정의된 메소드 구현
- method()
    - Target 클래스에서 정의한 것

```java
public class Bean {
		public void method() throws RuntimeException {
		}
}
```

- 포인트컷 테스트용 추가 클래스

**포인트컷 표현식 문법**

- AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다.
    - 대표적인 지시자로 execution()이 있다.

```java
execution([접근 제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...)
[throws 예외 패턴])
```

- [] → 생략 가능
- | → OR 조건
- [접근 제한자 패턴] → public, private 같은 접근제한자, 생략 가능하다.
- 타입패턴 → 리턴 값의 타입 패턴
- [타입패턴.] → 패키지와 클래스 이름에 대한 패턴. 생략 가능하다. 사용할 때는 ‘.’을 두어서 연결해야 한다.
- 이름패턴 → 메소드 이름 패턴
- 타입패턴 | “..”, … → 파라미터으 ㅣ타입 패턴을 순서대로 넣을 수 있다. 와일드카드를 이용해 파라미터 개수에 상관없는 패턴을 만들 수 있다.
- [throws 예외 패턴] → 예외 이름 패턴

```java
// 1
Target.class.getMethod("minus", int.class, int.class);

// 2
pubic int springbook.learningtest.spring.pointcut.Target.minus(int,int) throws 
java.lang.RuntimeException
```

- 1을 출력하면 2 같이 나옴
- public
    - 접근제한자다.
- int
    - 리턴 값의 타입을 나타내는 패턴이다.
    - 필수 타입이다. → 생략은 불가능
    - * 를 써서 모든 타입을 다 선택하겠다고 해도 된다.
- springbook.learningtest.spring.pointcut.Target
    - 패키지와 타입 이름을 포함한 클래스의 타입 패턴
    - 생략 가능하다.
        - 생략하면 모든 타입을 다 허용하겠다는 뜻이다.
    - 패키지 이름과 클래스 또는 인터페이스 이름에 *를 사용할 수 있다.
    - ‘..’를 사용하면 한 번에 여러 개의 패키지를 선택할 수 있다.
- minus
    - 메소드 이름 패턴이다.
    - 필수 항목이다.
    - 모든 메소드를 다 선택하겠다면 *를 넣으면 된다.
- (int,int)
    - 메소드 파라미터의 타입 패턴이다.
    - 메소드 파라미터의 타입을 ‘.’로 구분하면서 순서대로 적으면 된다.
    - 파라미터가 없는 메소드를 지정하고 싶다면 ()로 적는다.
    - 파라미터의 타입과 개수에 상관없이 모두 다 허용하는 패턴으로 만들려면 ‘..’을 넣으면 된다.
    - ‘…’을 이용해서 뒷부분의 파라미터 조건만 생략할 수도 있다.
    - 필수 항목이다.
- throws java.lang.RuntimeException
    - 예외 이름에 대한 타입 패턴이다.
    - 생략 가능하다.

```java
@Test
public void methodSignaturePointcut() throws SecurityException,
				NoSuchMethodException {
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression("execution(public int " +
				"springbook.learningtest.spring.pointcut.Target.minus(int,int) " + 
						"throws java.lang.RuntimeException)");
						
		// Target.minus()
		assertThat(pointcut.getClassFilter().matches(Target.class) &&
					pointcut.getMethodMatcher().matches(
							Target.class.getMethod("minus", int.class, int.class), null), is(true));
							
		// Target.plus()
		assertThat(pointcut.getClassFilter().matches(Target.class) &&
					pointcut.getMethodMatcher().matches(
							Target.class.getMethod("plus", int.class, int.class), null), is(false));
							
		// Bean.method()
		assertThat(pointcut.getClassFilter().matches(Bean.class) &&
					pointcut.getMethodMatcher().matches(
							Target.class.getMethod("method"), null), is(false));
}
```

- 메소드 시그니처를 이용한 포인트컷 표현식 테스트

- AspectJExpressionPointcut 클래스의 오브젝트를 만들고 포인트컷 표현식을 expression 프로퍼티에 넣어주면 포인트컷을 사용할 준비가 된다.
- 포인트컷 표현식은 메소드 시그니처를 execution() 안에 넣어서 작성한다.
- execution()은 메소드를 실행에 대한 포인트컷이라는 의미다.
- 포인트컷의 선정 방식은 클래스 필터와 메소드 매처를 각각 비교해보는 것이다.
- minus()
    - 두 가지 조건을 모두 만족
- plus()
    - 클래스, 파라미터 등은 모두 통과
    - 메소드 이름과 예외 패턴에서 탈락
- Bean.class의 메소드
    - 당연히 클래스부터 맞지 않으니 탈락

**포인트컷 표현식 테스트**

- 필수가 아닌 항목을 생략하면 다음과 같이 간단하게 만들 수 있다.

```java
execution(int minus(int,int))
```

- 단, 생략한 부분은 모든 경우를 다 허용하도록 되어 있기 때문에 이 포인트컷 표현식은 어떤 **접근제한자**를 가졌든, 어떤 **클래스**에 정의됐든, 어떤 **예외**를 던지든 상관없이 정수 값을 리턴하고 두 개의 정수형 파라미터를 갖는 minus라는 이름의 모든 메소드를 선정하는 좀 더 느슨한 포인트컷이 됐다는 점에 주의하자.

```java
execution(* minus(int,int))
```

- 리턴 타입 제한 해제

```java
execution(* minus(..))
```

- 파라미터의 개수와 타입 무시

```java
execution(* *(..))
```

- 모든 오브젝트의 모든 메소드를 다 선택

```java
public void pointcutMatches(String expression, Boolean expected, Class<?> clazz,
				String methodName, Class<?>... args) throws Exception {
		AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
		pointcut.setExpression(expression);
		
		assertThat(pointcut.getClassFilter().matches(clazz)
					&& pointcut.getMethodMatcher().matches(clazz.getMethod(methodName,
					args), null), is(expected));
}
```

- 포인트컷과 메소드를 비교해주는 테스트 헬퍼 메소드

```java
public void targetClassPointcutMatches(String expression, boolean... expected)
				throws Exception {
		pointcutMatches(expression, expected[0], Target.class, "hello");
		pointcutMatches(expression, expected[1], Target.class, "hello", String.class);
		pointcutMatches(expression, expected[2], Target.class, "plus", int.class, int.class);
		pointcutMatches(expression, expected[3], Target.class, "minus", int.class, int.class);
		pointcutMatches(expression, expected[4], Target.class, "method");
		pointcutMatches(expression, expected[5], Bean.class, "method");
```

- 타깃 클래스의 메소드 6개에 대해 포인트컷 선정 여부를 검사하는 헬퍼 메소드
- target이라 안하고 왜 taget이라 하지

```java
@Test
public void pointcut() throws Exception {
		targetClassPointcutMatches("execution(* *(..))", true, true, true, true, true, true);
		// 나머지는 생략 - 표 6-1의 내용과 동일하다.
```

- 모든 메소드를 다 허용하는 표현식

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/a7ca1118-f572-4b79-b4a8-0c96c90b9f4e/Untitled.png)

- 4번
    - meth로 시작하는 모든 클래스의 메소드가 다 허용
- 5번
    - 메소드 이름에는 상관없이 두 개의 정수 파라미터를 가진 메소드가 선정
- 8번
    - springbook.learningtest.spring.pointcut 패키지의 모든 클래스에 적용
    - 서브 패키지의 클래스는 포함되지 않는다.
- 9번
    - 8번과 달리 서브 패키지의 모든 클래스까지 포함
- 10번
    - springboot으로 시작하는 모든 패키지의 모든 클래스를 선정
- 11번
    - com으로 시작하는 패키지 선정
    - 어떤 메소드도 적용되지 않는다.
- 12번
    - Target이라는 이름의 모든 클래스에 적용
    - 클래스 필터와 같은 결과를 냄
- 13, 14, 15번
    - 모든 패키지 이름, 클래스 이름, 메소드 이름에는 와일드카드를 사용할 수 있다.
- 16번
    - Target 클래스가 구현한 TargetInterface 인터페이스를 선정조건으로 한 것
    - Target 클래스의 메소드 중에서 이 인터페이스를 구현한 메소드에만 포인트컷이 적용된다.
    - method() 메소드는 제외된다.
- 17번
    - Runtime으로 시작하는 어떤 에외라도 던진다면 이 포인트컷의 조건을 만족한다.

**포인트컷 표현식을 이용하는 포인트컷 적용**

- AspectJ 포인트컷 표현식은 메소드를 선정하는 데 편리하게 쓸 수 있는 강력한 표현식 언어다.
- 대표적으로 bean()이 있다.
    - bean(*Service)라고 쓰면 아이디가 Service로 끝나는 모든 빈을 선택한다.

```java
@annotation(org.springframework.transaction.annotation.Transactional)
```

- @Transactional이라는 애노테이션이 적용된 메소드 선정

```xml
<property name="mappedClassName" value="*ServiceImpl" />
<property name="mappedName" value="upgrade*" />
```

- NameMatchClassMethodPointcut과 같이 직접 만든 포인트컷 구현 클래스를 사용할 일이 없다.
- 새로운 포인트컷 표현식은 AspectJExpressionPointcut 빈을 등록하고 expression 프로퍼티에 넣어주면 된다.

```xml
<bean id="transactionPointcut"
			class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
		<property name="expression" value="exection(* *..*ServiceImpl.upgrade*(..))" />
</bean>
```

- 클래스 이름은 ServiceImpl로 끝나고 메소드 이름은 upgrade로 시작하는 모든 클래스에 적용되도록 하는 표현식
- 포인트컷 표현식을 사용하면 로직이 짧은 문자열에 담기기 때문에 클래스나 코드를 추가할 필요가 없어서 코드와 설정이 모두 단순해진다.
- 반면에 문자열로 된 표현식이므로 런타임 시점까지 문법의 검증이나 기능 확인이 되지 않는다는 단점도 있다.
- 정확히 원하는 빈만 선정헀는지를 확인하는 일도 만만치 않다.
- 근데 한눈에 확인하는 방법이 있다.
- 궁금하면 돈 주고 Vol. 2를 사도록.

**타입 패턴과 클래스 이름 패턴**

- UserService를 구현한 UserServiceImpl 클래스와 테스트를 위한 강제로 예외를 발생시키는 TestUserServiceImpl 클래스 두 개를 모두 빈으로 등록하고 이 두 개의 빈에 모두 트랜잭션을 적용하기 위해 ServiceImpl로 끝나는 클래스 이름을 가진 빈을 선정하도록 포인트컷을 구성했다.
- 포인트컷 표현식도 이를 만족해준다.
- 근데 TestUserService로 바꿔도 테스트가 성공한다.
- 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴이기 때문이다.
- TestUserService의 클래스 이름은 TestUserService일 뿐이지만, 타입을 따져보면 TestUserService 클래스이자, 슈퍼클래스인 UserServiceImpl, 구현 인터페이스인 UserService 세 가지가 모두 적용된다.
- 즉, TestUserService 클래스로 정의된 빈은 UserServiceImpl 타입이기도 하고, 그 때문에 ServiceImpl로 끝나는 타입 패턴의 조건을 충족하는 것이다.
    - 16번과 비슷하다.
    - TargetInterface 인터페이스를 표현식에 사용했을 때 Target 클래스의 오브젝트가 포인트컷에 의해 선정된 것과 마찬가지다.
    - Target은 TargetInterface를 구현했기 때문에 Target 클래스의 오브젝트는 TargetInterface 타입이기도 하다.
- *..UserService라고 직접 인터페이스 이름을 명시해도 두 개의 빈이 모두 선정된다.

# 13주차

### AOP란 무엇인가?

**트랜잭션 서비스 추상화**

- 트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣으면서 생긴 문제
    - 특정 트랜잭션 기술에 종속되는 코드가 돼버린다.
- JDBC의 로컬 트랜잭션 방식 → JTA를 이용한 글로벌/분산 트랜잭션 방식
    - 모든 트랜잭션 적용 코드를 수정해야 한다.
- 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법을 적용했다.
    - 비즈니스 로직 코드는 트랜잭션을 어떻게 처리해야 한다는 구체적인 방법과 서버환경에서 종속되지 않는다.
    - 구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시에 다이내믹하게 연결해준다는 DI를 활용한 전형적인 접근 방법이었다.
- 트랜잭션 추상화란
    - 인터페이스와 DI를 통해 무엇을 하는지는 남긴다.
    - 그것을 어떻게 하는지를 분리한다.
        - 어떻게 할지는 더 이상 비즈니스 로직 코드에는 영향을 주지 않고 독립적으로 변경할 수 있게 됐다.

**프록시와 데코레이터 패턴**

- 트랜잭션을 어떻게 다룰 것인가는 추상화를 통해 코드에서 제거
- 트랜잭션 적용하고 있다는 사실은 비즈니스 로직 코드에 여전히 드러나고 있음.
- 트랜잭션은 거의 대부분의 비즈니스 로직을 담은 메소드에 필요하다.
- 트랜잭션의 경계 설정을 담당하는 코드의 특성 때문에 단순한 추상화와 메소드 추출 방법으로는 더 이상 제거할 방법이 없었다.
- DI를 이용해 데코레이터 패턴을 적용하는 방법
    - 데코레이터 패턴은 투명한 부가기능 부여를 가능하게 함.
    - 비즈니스 로직을 담당하는 클래스도 자신을 사용하는 클라이언트와 DI 관계를 맺을 이유를 찾게 됨.
    - 클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고, 데코레이터 패턴을 적용해서, 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않으면서 트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조를 만들었다.
    - 트랜잭션을 처리하는 코드는 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만들었다.
    - 클라이언트가 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근할 수 있게 됐다.
- 결국 비즈니스 로직 코드는 트랜잭션과 같은 성격이 다른 코드로부터 자유로워졌고, 독립적으로 로직을 검증하는 고립된 단위 테스트를 만들 수도 있게 됐다.

**다이내믹 프록시와 프록시 팩토리 빈**

- 프록시를 이용해서 비즈니스 로직 코드에서 트랜잭션 코드는 모두 제거할 수 있었다.
- 하지만 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업이 오히려 큰 짐이 됐다.
- 트랜잭션 기능을 부여하지 않아도 되는 메소드조차 프록시로서 위임 기능이 필요하기 때문에 일일이 다 구현을 해줘야 했다.
- JDK 다이내믹 프록시 기술을 적용한 후, 프록시 클래스 코드 작성의 부담도 덜고, 부가기능 부여 코드가 여기저기 중복돼서 나타나는 문제도 일부 해결할 수 잇었다.
- 일부 메소드에만 트랜잭션을 적용해야하는 경우에는 메소드를 선저하는 패턴 등을 이용할 수도 있었다.
- 하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어나는 문제는 해결하지 못했다.
- 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입했다.
- 내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공유해서 사용할수 있게 됐다.

**자동 프록시 생성 방법과 포인트컷**

- 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 한다는 부담이 남아있었다.
- 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다.
- 일일이 지정하지 않고 패턴을 이용해 자동으로 선정할 수 있도록, 확장된 포인트컷을 사용했다.
- 포인트컷 표현식을 활용해서 부가기능 적용 정보를 분리할 수 있었고 간단한 설정만으로 적용 대상을 손쉽게 선택할 수 있게 됐다.

**부가기능의 모듈화**

- 관심사가 같은 코드를 분리해 한데 모으는 것은 소프트웨어 개발의 가장 기본이 되는 원칙이다.
- 지금까지 해온 작업이 그러하다.
- 하지만 트랜잭션 같은 부가기능은 핵심기능과 같은 방식으로는 모듈화하기가 매우 힘들다.
- 많은 개발자들의 고민 덕분에 부가기능인 트랜잭션 경계설정 기능은 TransactionAdvice라는 이름으로 모듈화될 수 있었다.
- 결국 지금까지 해온 모든 작업은 핵심기능에 부여되는 부가기능을 효과적으로 모듈화하는 방법을 찾는 것이었고, 어드바이스와 포인트컷을 결합한 어드바이저가 단순하지만 이런 특성을 가진 모듈의 원시적인 형태로 만들어지게 됐다.

**AOP: 애스펙트 지향 프로그래밍**

- 부가기능 모듈화 작업은 기존의 객체지향 설계 패러다임과는 구분되는 새로운 특성이 있다.
- 애스펙트
    - 부가기능 모듈
    - 객체지향 기술에서 주로 사용하는 오브젝트와는 다름
    - 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가르킨다.
    - 어드바이스 + 포인트컷
- 어드바이저는 단순한 형태의 애스펙트라 볼 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/0669f012-cd63-45f2-aeaf-8b586a04f7b4/Untitled.png)

- 왼쪽과 오른쪽을 비교해보자.

- 왼쪽
    - 애스펙트로 부가기능을 분리하기 전의 상태
    - 핵심기능은 깔끔한 설계를 통해서 모듈화되어 있고, 객체지향적인 장점을 잘 살릴 수 있도록 만들었다.
    - 하지만 부가기능이 핵심기능의 모듈에 침투해 들어가면서 설계와 코드가 모두 지저분해졌다.
    - 코드의 유지보수, 핵심기능 로직 파악, 수정, 테스트, 코드 중복 등 많은 문제가 야기된다.

- 오른쪽
    - 부가기능을 독립적인 모듈인 애스펙트로 구분해낸 것
    - 2차원적인 평면 구조에서는 어떤 설계 기법을 동원해도 해결할 수 없었던 것을, 3차원의 다면체 구조로 가져가면서 각각 성격이 다른 부가기능은 다른 면에 존재하도록 만들었다.
    - 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴볼 수 있도록 구분된 면에 존재하게 된 것이다.
    - 물론 동작할 때는 왼쪽의 그림처럼 동작하지만 각 부가기능 애그펙트는 자기가 필요한 위치에 다이내믹하게 참여하게 될 것이다.

- AOP (애스펙트 지향 프로그래밍)
    - 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법
    - OOP를 돕는 보조적인 기술
    - 애스펙트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것
    - 애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것
    - 애플리케이션을 사용자 관리라는 핵심 로직 대신 트랜잭션 경계설정이라는 관점에서 바라보고 그 부분에 집중해서 설계하고 개발할 수 있게 된다.
    - 이렇게 애플리케이션을 특정한 관점을 기준으로 바라볼 수 있게 해준다는 의미에서 AOP를 관점 지향 프로그래밍이라고도 한다.

### AOP 적용기술

**프록시를 이용한 AOP**

- 스프링은 다양한 기술을 조합해 AOP를 지원하고 있다.
- 그 중 가장 핵심은 프록시를 이용했다는 것이다.
- 프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공하도록 만들었다.
    - 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구하지 않는다.
    - 스프링 컨테이너인 애플리케이션 컨텍스트는 특별한 환경이나 JVM 설정 등을 요구하지 않는다.
- 스프링 AOP의 부가기능을 담은 어드바이스가 적용되는 대상은 오브젝트의 메소드다.
- 어드바이스가 구현하는 MethodInterceptor 인터페이스는 다이내믹 프록시의 InvocationHandler와 마찬가지로 프록시로부터 메소드 요청정보를 전달받아서 타깃 오브젝트의 메소드를 호출한다.
- 타깃의 메소드를 호출하는 전후에 다양한 부가기능을 제공할 수 있다.
- 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고 있는게 바로 프록시다.
- 그래서 스프링의 AOP는 프록시 방식의 AOP라고 할 수 있다.

**바이트코드 생성과 조작을 통한 AOP**

- 프록시 방식이 아닌 AOP도 있나? → 있다.
- AspectJ는 프록시를 사용하지 않는 대표적인 AOP 기술이다.
- 스프링도 AspectJ의 뛰어난 포인트컷 표현식을 차용해서 사용할 만큼 매우 성숙하고 발전한 AOP 기술이다.
- AspectJ는 다이내믹 프록시 방식을 사용하지 않는다. 그럼 어떻게?
- 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용한다.
- 타깃 오브젝트의 소스코드를 수정할 수는 없으니, 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.
- AspectJ는 프록시를 안 쓰고 왜 이렇게 하나?
    - 바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있기 때문이다.
        - 스프링과 같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP의 적용이 가능해진다.
    - 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문이다.
        - 프록시 → 부가기능을 부여할 대상이 클라이언트가 호출할  사용하는 메소드로 제한된다.
        - AspectJ → 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가기능을 부여해줄 수 있다.
- 물론 대부분의 부가기능은 프록시 방식을 사용해 메소드의 호출 시점에 부여하는 것으로도 충분하다.
- 게다가 AspectJ 같은 고급 AOP 기술은 번거로운 작업이 필요하다.
- 따라서 일반적인 AOP를 적용하는 데는 프록시 방식의 스프링 AOP로도 충분하다.

### AOP의 용어

- 타깃
    - 부가기능을 부여할 대상 (핵심기능을 담은 클래스)
    - 경우에 따라 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.
- 어드바이스
    - 타깃에게 제공할 부가기능을 담은 모듈
- 조인 포인트
    - 어드바이스가 적용될 수 있는 위치
    - 스프링의 프록시 AOP에서는 메소드의 실행 단계 뿐
- 포인트컷
    - 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈
    - 스프링 AOP의 조인 포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있다.
- 프록시
    - 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트
    - DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임해주면서, 그 과정에서 부가기능을 부여한다.
- 어드바이저
    - 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트
    - 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈
    - 일반적인 AOP에서는 사용되지 않는 용어
- 애스펙트
    - AOP의 기본 모듈
    - 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다.

### AOP 네임스페이스

- 스프링 AOP를 적용하기 위해 추가했던 어드바이저, 포인트컷, 자동 프록시 생성기 같은 빈들은 애플리케이션의 로직을 담은 UserDao나 UserService 빈과는 성격이 다르다.
- 이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다.
- 스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.

- 자동 프록시 생성기
    - 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다.
    - DI 하거나 되지 않고 독립적으로 존재한다.
    - 애플리케이션 컨텍스트가 빈 오브젝트를 생성하는 과정에 빈 후처리기로 참여한다.
    - 빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기능을 담당한다.
- 어드바이스
    - 부가기능을 구현한 클래스를 빈으로 등록한다.
    - TransactionAdvice는 AOP 관련 빈 중에서 유일하게 직접 구현한 클래스를 사용한다.
- 포인트컷
    - 스프링의 AspectJExpressionPointcut을 빈으로 등록한다.
- 어드바이저
    - 스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다.
    - 어드바이스와 포인트컷을 프로퍼티로 참조하는 것 외에는 기능은 없다.
    - 자동 프록시 생성기에 의해 자동 검색되어 사용된다.

**AOP 네임스페이스**

- 스프링에서는 이렇게 AOP를 위해 기계적으로 적용하는 빈들을 간편한 방법으로 등록할 수 있다.
- AOP와 관련된 태그를 정의해둔 aop 스키마를 제공한다.
- 정의된 태그는 별도의 네임스페이스를 지정해서 디폴트 네임스페이스의 <bean> 태그와 구분해서 사용할 수 있다.

```xml
<?xml version="1.0" encoding="UTF-8?>
<beans xmlns="http://www.springframework.org/schema/beans"
		xmnls:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmnls:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
												http://www.springframework.org/schema/beans/spring-beans.xsd
												http://www.springframework.org/schema/aop
												http://www.springframework.org/schema/aop/spring-aop-3.0.xsd">
		...
</beans>
```

- aop 네임스페이스 선언

```xml
<aop:config>
		<aop:pointcut id="transactionPointcut"
									expression="execution(* *..*ServiceImpl.upgrade*(..))" />
		<aop:advisor advice-ref="transactionAdvice" pointcut-ref="transactionPointcut" />
</aop:config>
```

- aop 네임스페이스를 적용한 AOP 설정 빈
- 꼭 필요한 핵심 정보만 가지고 위와 같이 간단하게 바꿀 수 있다.

- <aop: {}> 태그를 정의해두면 그에 따라 세 개의 빈이 자동으로 등록된다.
- 포인트컷이나 어드바이저, 자동 포인트컷 생성기 같은 특별한 기능을 가진 빈들은 별도의 스키마에 정의된 전용 태그를 사용해 정의해주면 편리하다.
- 애플리케이션을 구성하는 컴포넌트 빈과 컨테이너에 의해 사용되는 기반 기능을 지원하는빈은 구분이 되는 것이 좋다.
- 직접 구현한 클래스로 등록한 빈인 transactionAdvice를 제외한 AOP 관련 빈들은 의미를 잘 드러내는 독립된 전용 태그를 사용하도록 권장된다.
- <bean> 태그를 사용했을 때와 비교해보면 이해하기도 쉬울뿐더러 코드의 양도 대폭 줄었음을 알 수 있다.

**어드바이저 내장 포인트컷**

```xml
<aop:config>
		<aop:advisor advice-ref="transactionAdvice"
					pointcut="execution(* *..*ServiceImpl.upgrade*(..))*" />
</aop:config>
```

- 포인트컷을 내장한 어드바이저 태그
- 포인트컷 표현식을 직접 <aop:advisor> 태그에 담아서 위와 같이 만들 수도 있다.
- 태그가 하나 줄었으니 포인트컷을 독립적으로 정의하는 것보다 간결해서 보기 좋다.
- 하지만 하나의 포인트컷을 여러 개의 어드바이저에서 공유하려고 하는 경우에는 포인트컷을 독립적인 <aop:pointcut> 태그로 등록해야 한다.
- 포인트컷을 내장하는 경우에는 <aop:advisor> 태그 하나로 두 개의 빈이 등록된다.
- 전용 스키마를 갖는 태그는 한 번에 하나 이상의 빈을 등록할 수 있다.
- 애트리뷰트 설정에 따라 등록되는 빈의 개수와 종류가 달라질 수도 있다.