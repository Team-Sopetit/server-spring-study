# 9주차

# AOP

- AOP란?
    - IoC/DI, 서비스 추상화와 더불어 스프링의 3개 기반기술의 하나

## 트랜잭션 코드의 분리

- 트랜잭션 경계설정을 위해 넣은 코드 때문에 현재 UserService가 조금 찜찜함.

### 메소드 분리

- 얼핏 보면 트랜잭션 경계설정 코드와 비즈니스로 로직 코드가 복잡하게 얽혀 있는 듯이 보이지만, 자세히 살펴보면 뚜렷하게 두 가지 종류의 코드가 구분되어 있다.
- 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다.
- 따라서 이 두 코드는 완벽하게 독립적인 코드다.
- 따라서 아래와 같이 분리하자.

```java
public void upgradeLevels() throws Exception {
		// 트랜잭션 시작
		upgradeLevlesInternal();
		// 트랜잭션 종료
}

private void upgradeLevelsInternal() {
		// 비즈니스 로직 코드
}
```

### DI를 이용한 클래스의 분리

- 여전히 트랜잭션을 담당하는 기술적인 코드가 버젓이 UserService 안에 자리 잡고 있다.

**DI 적용을 이용한 트랜잭션 분리**

- 구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점
    - 실전에서는 다른 클래스나 모듈에서 UserService를 호출해 사용할 것이다.
        - 이 경우 UserService를 직접 참조하게 된다.
    - 트랜잭션 코드를 UserService 밖으로 빼버리면 위와 같은 상황에서 트랜잭션이 빠진 UserService를 사용하게 된다.
- 직접 사용이 문제라면 간접적으로 사용하면 된다.
- DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것이다.
- 이를 통해 구현 클래스는 얼마든지 외부에서 변경할 수 있다.
- UserService는 인터페이스로, UserServieImpl라는 구현 클래스 추가
- 클라이언트와 결합이 약해지고, 직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능해진다.
- 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI를 통해 적용하는 방법을 쓰는 이유
    - 구현 클래스를 바꿔가면서 사용하기 위해
    - 테스트 → 테스트 구현 클래스
    - 정식 운영 → 정규 구현 클래스
- 한 번에 두개의 UserService 인터페이스 구현 클래스를 동시에 이용한다면?
    - UserServiceTx라는 UserService를 구현한 또 다른 구현 클래스를 만든다.
    - 트랜잭션의 경계설정이라는 책임을 맡고 있음
    - 스스로는 비즈니스 로직을 담고 있지 않기 때문에 또다른 비즈니스 로직을 담고 있는 UserServiceImpl에 실제적인 로직 처리 작업은 위임
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/29334470-6421-47aa-9714-5077913a6b81/Untitled.png)
    

**UserService 인터페이스 도입**

- 기존의 UserService는 UserServiceImpl로 변경

```java
public interface UserService {
		void add(User user);
		void upgradeLevels();
} 
```

- UserService 인터페이스 생성
- UserServiceImpl 코드에서 트랜잭션 관련 코드 모두 삭제

```java
public class UserServiceImpl implements UserService {
		UserDao userDao;
		MailSender mailSender;

		public void upgradeLevels() {
				// 비즈니스 로직 코드
		}
}
```

- 트랜잭션 코드를 모두 삭제한 UserServiceImpl

**분리된 트랜잭션 기능**

- UserServiceTx는 기본적으로 UserService를 구현하게 만든다.
- 같은 인터페이스를 구현한 다른 오브젝트에게 고스란히 작업을 위임하게 만든다.

```java
public class UserServiceTx implements UserService {

		UserService userService;
		
		public void setUserService(UserService userService) {
			this.userService = userService;
		}

		public void add(User user) {
				userService.add(user);
		}

		public void upgradeLevles() {
				userService.upgradeLevels();
		}
}
```

- UserServiceTx의 코드
- 사용자 관리라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기능을 위임한다.
- 이를 위해 UserService 오브젝트를 DI 받을 수 있도록 한다.

```java
public class UserServiceTx implements UserService {

		UserService userService;
		PlatformTransaction transactionManager;

		public void setTransactionManager(PlatformTransaction transactionManager) {
				this.transactionManager = transactionManager
		}
		
		public void setUserService(UserService userService) {
			this.userService = userService;
		}

		public void add(User user) {
				userService.add(user);
		}

		public void upgradeLevles() {
				Transaction status = this.transactionManager
						.getTransaction(new DefaultTransactionDefinition());
				try {
						userService.upgradeLevels();
						this.transactionManager.commit(status);
				} catch (RuntimeEsception e) {
						this.transactionManager.rollback(status);
						throw e;
				}
		}
}
```

- 트랜잭션을 적용하도록 만든 UserServcieTx

**트랜잭션 적용을 위한 DI 설정**

- 스프링의 DI 설정에 의해 결국 만들어질 빈 오브젝트와 그 의존관계는 다음과 같이 구성되어야 한다.
    - Client(UserServiceTest) → UserSerivceTx → UserSerivceImpl

**트랜잭션 분리에 따른 테스트 수정**

- 기존의 UserService 클래스가 인터페이스 두 개의 클래스로 분리된 만큼 테스트에서도 적합한 타입과 빈을 사용하도록 변경해야 한다.
- 기존에는 UserService 클래스 타입의 빈을 @Autowired로 가져다가 사용했다.
- UserService라는 인터페이스 타입을 가진 두 개의 빈이 존재하기 때문에 문제가 발생한다.
- @Autowired는 기본적으로 타입을 이용해 빈을 찾지만 만약 타입으로 하나의 빈을 결정할 수 없는 경우에는 필드 이름을 이용해 빈을 찾는다.

```java
@Autowired UserService userService;
```

- UserServiceTest는 UserServiceImpl로 정의된 빈을 더 가져와야 한다.
    - MailSender는 DI 해줄 대상을 구체적으로 알고 있어야 하기 때문에 UserServiceImpl 클래스의 오브젝트를 가져올 필요가 있다.
- 개발자가 자신이 작성한 코드를 검증하기 위한 테스트인만큼 내부 구조를 속속들이 알고 있는 채로 테스트를 만드는 것에는 문제가 없다.
- 목 오브젝트를 이용해 수동 DI를 적용하는 테스트라면 어떤 클래스의 오브젝트인지 분명하게 알 필요가 있다.

```java
@Autowired UserServiceImpl userServiceImpl;
```

```java
@Test
public void upgradeLevels() throws Exception {
		...
		MockMailSender mockMailSender = new MockMailSender();
		userServiceImpl.setMailSender(mockMailSender);
}
```

- UserService 인터페이스를 통해서 MailSender의 목 오브젝트를 설정해주는 건 불가능하기 때문에 UserServiceImpl에 해줘야 한다.

- upgradeAllOrNothing() 테스트에도 수정할 부분이 있다.
- 트랜잭션 기술이 바르게 적용됐는지 확인하기 위해 만든 일종의 학습테스트이기 때문이다.

```java
@Test
public void upgradeAllOrNothing() throws Exception {
		TestUserService testUserService = new TestUserService(users.get(3).getId());
		testUserService.setUserDao(userDao);
		testUserService.setMailSender(mailSender);

		UserServiceTx txUserService = new UserServiceTx();
		txUserService.setTransactionManager(transactionManager);
		txUserService.setUserService(testUserService);

		userDao.deleteAll();
		for(User user: users) userDao.add(user);
		
		try {
		txUserService.upgradeLevels();
		fail("TestUserServiceException expected");
		}

		...
}
```

- TestUserService 오브젝트를 UserServiceTx 오브젝트에 수동 DI 시킨 후에 트랜잭션 기능까지 포함된 UserServiceTx의 메소드를 호출하면서 테스트를 수행하도록 해야 한다.

```java
static class TestUserService extends UserServiceImpl {
```

- 트랜잭션 테스트용으로 특별히 정의한 TestUserService 클래스를 위와 같이 UserServiceImpl를 상속하도록 바꿔준다.

**트랜잭션 경계설정 코드 분리의 장점**

- 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트래잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
    - 트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다.
    - 언제든지 트랜잭션을 도입할 수 있다.
- 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.

## 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법
    - 가능한 한 작은 단위로 쪼개서 테스트하는 것
- 작은 단위의 테스트가 좋은 이유
    - 테스트가 실패했을 때 그 원인을 찾기 쉽다.
    - 테스트에서 오류가 발견됐을 때 그 테스트가 진행되는 동안 실행된 코드의 양이 많다면 그 원인을 찾기가 매우 힘들어질 수 있다.
    - 테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다.
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

### 복잡한 의존관계 속의 테스트

- UserService는 간단한 기능만을 가지고 있지만 세 가지 타입의 의존 오브젝트가 필요하다.
    - UserDaoJdbc
    - DSTransactionManager
    - JavaMailSenderImpl
- 심지어 세 가지 의존 오브젝트도 자신의 코드만 실행하고 마는 게 아니라 다른 부분에 의존한다.
- UserService라는 테스트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는 오브젝트와 서비스, 환경 등이 모두 합쳐져 테스트 대상이 되는 것이다.

### 테스트 대상 오브젝트 고립시키기

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.

**테스트를 위한 UserServiceImpl 고립**

- UserServiceImpl의 upgradeLevels() 메소드는 리턴 값이 없는 void형이다.
- 따라서 메소드를 실행하고 그 결과를 받아서 검증하는 것은 아예 불가능하다.
- 코드의 동작이 바르게 됐는지 확인하려면 결과가 남아 있는 DB를 직접 확인할 수 밖에 없다.
- 그런데 의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든 UserServiceImpl은 아무리 그 기능이 수행돼도 그 결과가 DB 등을 통해서 남지 않으니, 기존의 방법으로는 작업 결과를 검증하기 힘들다.
- 이럴 땐 테스트 대상인 UserServiceImpl과 그 협력 오브젝트인 UserDao에게 어떤 요청을 했는지를 확인하는 작업이 필요하다.
- UserDao의 update() 메소드를 호출하는 것을 확인할 수 있다면, 결국 DB에 그 결과가 반영될 것이라고 결론을 내릴 수 있기 때문이다.
- UserDao와 같은 역할을 하면서 UserServiceImpl과의 사이에서 주고받은 정보를 저장해뒀다가, 테스트의 검증에 사용할 수 있게 하는 목 오브젝트를 만들 필요가 있다.

**고립된 단위 테스트 활용**

- UserServiceTest의 upgradeLevels() 테스트는 다섯 단계의 작업으로 구성된다.
1. 테스트 실행 중에 UserDao를 통해 가져올 테스트용 정보를 DB에 넣는다.
2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트를 DI 해준다.
3. 실제 테스트 대상인 userService의 메소드를 실행한다.
4. 결과가 DB에 반영됐는지 확인한다.
5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지를 확인한다.

1. 의존관계를 따라 마지막에 등장하는 DB를 준비하는 것
2. 테스트를 의존 오브젝트와 서버 등에서 고립시키도록 테스트만을 위한 목 오브젝트를 준비하는 것

  4. 의존관계를 따라 결국 최종 결과가 반영된 DB의 내용을 확인하는 것

  5. 메일 서버까지 갈 필요 없이 목 오브젝트를 통해 upgradeLevels() 메소드가 실행되는 중에 메일 발송 요청이 나간 적이 있는지만 확인하는 것

**UserDao 목 오브젝트**

- UserServiceImpl의 코드를 살펴보면 upgradeLevels() 메소드와 그 사용 메소드에서 UserDao를 사용하는 경우는 두 가지다.

```java
List<User> users = userDao.getAll(); // 업그레이드 후보 사용자 목록을 가져온다.
userDao.update(user); // 수정된 사용자 정보를 DB에 반영한다.
```

- 테스트용 UserDao에는 DB에서 읽어온 것처럼 미리 준비된 사용자 목록을 제공해줘야 한다.
- update() 메소드의 사용은 upgradeLevels()의 핵심 로직인 ‘전체 사용자 중에서 업그레이드 대상자는 레벨을 변경해준다’에서 ‘변경’에 해당하는 부분을 검증할 수 있는 중요한 기능이다.
- getAll()에 대해서는 스텁으로서, update()에 대해서는 목 오브젝트로서 동작하는 UserDao 타입의 테스트 대역이 필요하다.
- 이 클래스의 이름을 MockUserDao라고 하자.

```java
static class MockUserDao implements UserDao {
		private List<User> users;
		private List<User> updated = new ArrayList();

		private MockUserDao(List<User> users) {
				this.users = users;
		}

		public List<User> getUpdated() {
				return this.updated;
		}

		public List<User> getAll() {
				return this.users;
		}

		public void update(User user) {
				updated.add(user);
		}

		public void add(User user) { throw new UnsupportedOperationException(); 
		...
}
```

- MockUserDao는 UserDao 구현 클래스를 대신해야 하니 당연히 UserDao 인터페이스를 구현해야 한다.
- 사용하지 않을 메소드도 구현해줘야 한다면 예외를 던지도록 만드는 편이 좋다.
- MockUserDao에는 두 개의 User 타입 리스트를 정의해둔다.
    - 생성자를 통해 전달받은 사용자 목록을 저장해뒀다가, getAll() 메소드가 호출되면 DB에서 가져온 것처럼 돌려주는 용도
    - update() 메소드를 실행하면서 넘겨준 업그레이드 대상 User 오브젝트를 저장해뒀다가 검증을 위해 돌려주기 위한 것

```java
@Test
public void upgradeLevels() throws Exception {
		UserServiceImpl userServiceImpl = new UserServiceImpl();

		MockUserDao mockUserDao = new MockUserDao(this.users);
		userServiceImpl.setUserDao(mockUserDao);

		...

		List<User> updated = mockUserDao.getUpdated();
		assertThat(updated.size(), is(2));
		checkUserAndLevel(updated.get(0), "joytouch", Level.SILVER);
		checkUserAndLevel(updated.get(1), "madnite1", Level.GOLD);

		...
}

private void checkUserAndLevel(User updated, String expectedId, Level expectedLevel) {
		assertThat(updated.getId(), is(expectedId));
		assertThat(updated.getLevel(), is(expectedLevel));
}
```

- 완전히 고립돼서 테스트만을 위해 독립적으로 동작하는 테스트 대상을 사용할 것이기 때문에 스프링 컨테이너에서 빈을 가져올 필요가 없다.

**테스트 수행 성능의 향상**

- UserServiceImpl와 테스트를 도와주는 두 개의 목 오브젝트 외에는 사용자 관리 로직을 검증하는 데 직접적으로 필요하지 않은 의존 오브젝트와 서비스를 모두 제거했기 때문에 매우 빠르게 테스트가 가능하다.
- 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡하게 준비할 필요가 없다
- 테스트 수행 성능도 크게 향상된다.

### 단위 테스트와 통합 테스트

- 책에서의 테스트 정의
- 단위 테스트
    - 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트
- 통합 테스트
    - 두 개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트
- 단위 테스트와 통합 테스트 간의 가이드라인 → 책 참고, 인간적으로 너무 길다 ㅋㅋㅋ

### 목 프레임워크

- MockUserDao처럼 목 오브젝트를 만드는 것은 매우 귀찮은 작업이다.

**Mockito 프레임워크**

```java
UserDao mockUserDao = mock(UserDao.class);
when(mockUserDao.getAll()).thenReturn(this.users);
verify(mockUserDao, times(2)).update(any(User.class));
```

- mockUserDao.getAll()이 호출될 때 users 리스트를 리턴해준다.
- User 타입의 오브젝트를 파라미터로 받으며 update() 메소드가 두 번 호출됐는지 확인하라.
- Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용한다
    - 인터페이스를 이용해 목 오브젝트를 만든다.
    - 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
    - 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
    - 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.

```java
@Test
public void mockUpgradeLevels() throws Exception() {
		UserServiceImpl userServiceImpl = new UserServiceImpl();

		UserDao mockUserDao = mock(UserDao.class);
		when(mockUserDao.getAll()).thenReturn(this.users);
		userServiceImpl.setUserDao(mockUserDao);

		MailSender mockMailSender = mock(MailSender.class);
		userServiceImpl.setMailSender(mockMailSender);

		userServiceImpl.upgradeLevles();

		verify(mockUserDao, times(2)).update(any(User.class));
		verify(mockUserDao, times(2)).update(any(User.class));
		verify(mockUserDao).update(users.get(1));
		assertThat(users.get(1).getLevel(), is(Level.SILVER));
		verify(mockUserDao).update(users.get(3));
		assertThat(users.get(3).getLevel(), is(Level.GOLD));
		
		...
}
```

- any() → 파라미터의 내용은 무시하고 호출 횟수만 확인할 수 있다.
- verify(mockUserDao).update(users.get(1)) → users.get(1)을 파라미터로 update()가 호출된 적이 있는지를 확인해준다.
- 레벨의 변화는 파라미터의 직접 비교로는 확인이 되지 않으므로 User 목록의 내용을 가지고 직접 확인해봐야한다.