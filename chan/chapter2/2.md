# 3주차

테스트

내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업

단위 테스트

작은 단위의 코드에 대해 테스트를 수행한 것

단위 : 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위

db의 상태가 매번 달라지고, 테스트를 위해 db를 특정 상태로 만들어줄 수 없다면 → 단위 테스트로서 가치가 없어짐

하는 이유 : 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서

빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드 → 자동화된 테스트 → 과감한 수정 이후에도 전체적인 동작 여부에 안심할 수 있음

Junit 프레임워크의 조건

1. public
2. @Test

단위 테스트 : 항상 일관성 있는 결과가 보장돼야 한다.

Junit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어가는 것을 허용한다.

- @Test가 붙어 있고
- public 접근자가 붙어 있으며
- 리턴 값이 void형이고
- 파라미터가 없다는 조건을 지키기만 하면 된다.

Junit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다.

@Test(expected= exception.class)

→ 테스트 중에 발생할 것으로 기대하는 예외 클래스를 지정해준다.

테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

@Before

Junit이 제공하는 애노테이션, @Test 메소드가 실행되기 전에 먼저 실행돼야 하는 메소드를 정의한다.

Junit의 테스트 수행 방식

1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는 이유

- 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해

픽스처

- 테스트를 수행하는 데 필요한 정보나 오브젝트

# 4주차

### 스프링 테스트 적용

- 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙
    - 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 함.
    - 따라서 애플리케이션 컨텍스트는 한 번만 만들고 여러 테스트가 공유해서 사용해도 된다.
- Junit은 매번 테스트 클래스의 오브젝트를 새로 만든다.
    - JUnit은 테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 @BeforeClass 스태틱 메소드를 지원한다.
    - 이보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 가능을 사용하는 것이 편리하다.
    1. @RunWith와 @ContextConfiguration 애노테이션을 사용하는 방법인데 다른 더 좋은 방법이 있는 거 같아 서술은 하지 않겠다.
        - 재사용을 통해 테스트 메소드 실행 속도가 빨라진다는 장점이 있다.
        - 서로 다른 테스트 클래스도 같은 설정파일을 사용한다면 한 개의 애플리케이션 컨텍스트만이 만들어져 두 클래스가 이를 공유하게 된다.
    2. @Autowired
        - 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다.
        - 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 셈이고 DI도 가능하다.
        - 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다.
            - 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.
            - 이 때 변수의 이름과 같은 이름의 빈이 있는 지를 확인한다.
            - 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.
            - 자동으로 찾는다는 특징이 있지만 되도록 변수타입으로 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다. 이유는 아래에 서술한다.
                - 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
                - 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다.
                - 테스트
                
- 테스트 코드에 의한 DI
    - DI는 애플리케이션 컨텍스트 같은 스프링 컨테이너에서만 할 수 있는 작업이 아니다.
        - UserDao의 수정자 메소드 사용
    - DAO가 사용할 DataSource 오브젝트 바꿔주기
        - SingleConnectionDataSource를 통해 DB 커넥션 하나만 만들어두고 사용하기
    - 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에 알려주기 위해 @DirtiesContext를 사용해야 한다.
    - xml 설정 파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다.
    - 이미 xml 파일의 설정정보를 따라 애플리케이션 컨텍스트에서 구성된 오브젝트를 가져와 의존관계를 강제로 변경했기 때문에 매우 주의해서 사용해야 한다.
    - 애플리케이션 컨텍스트는 테스트 중에 딱 한 개만 만들어지고 모든 테스트에서 공유해서사용하는데 이를 임의로 변경하는 것은 옳지 않다.
    - @DirtiesContext 애노테이션이 붙은 테스트 클래스에서는 애플리케이션 컨텍스트 공유를 허용하지 않는다.
        - 이 때문에 애플리케이션 컨텍스트를 매번 만드는 건 조금 그렇다.
        - 메소드에도 사용 가능하다.
        
- 테스트를 위한 별도의 DI 설정
    - 테스트 전용 설정 파일을 따로 만들어두자.
    - 번거롭게 수동 DI 하는 코드나 @DirtiesContext도 필요없다.
    
- 컨테이너 없은 DI 테스트
    - @Before 메소드에서 직접 UserDao의 오브젝트를 생성하고, 테스트용 DataSource 오브젝트를 만들어 직접 DI해준다.
    - 코드가 더 단순해지고 이해하기 편해진다.
    - 애플리케이션 컨텍스트가 만들어지는 번거로움이 없어졌으니 테스트 시간도 절약된다.
    - 매번 새로운 UserDao 오브젝트가 만들어진다. → JUnit은 매번 새로운 테스트 오브젝트를 만들기 때문에

→ 테스트하기 좋은 코드가 좋은 코드일 가능성이 높다.

- DI를 이용한 테스트 방법 선택
    - 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자.
        - 테스트 수행속도가 가장 빠르고 간결하다.
    - 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우 DI 방식의 테스트를 이용하자.
        - 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정파일을 따로 만들어 사용하는 편이 편하다.
    - 예외적이 ㄴ의존관계를 강제로 구성해서 테스트를 해야하는 경우 수동 DI 해서 테스트하자.
        - @DirtiesContext 애노테이션을 잊지말자.

### 학습 테스트로 배우는 스프링

- 학습 테스트
    - 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것
    - 테스트이지만 **프레임워크나 기능에 대한 검증이 목적이 아니다**.
    - 자신의 이해도 검증이 목적이다.
- 학습 테스트의 장점
    - 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
    - 학습 테스트 코드를 개발 중에 참고할 수 있다.
        - 다양한 기능에대한 샘플 코드가 테스트 안에 모두 만들어지기 때문에 좋은 참고자료가 된다.
    - 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
        - 소프티 개발에서 사용한 gson이 그 예라고 생각한다.
        - 최신 버전 업데이트를 권장해서 업그레이드 했었는데 버전이 바뀌면서 생긴 자잘한 변경사항이 서비스에 악영향을 끼칠 수도 있었다.
        - 이를 체크할 수 있다.
    - 테스트 작성에 대한 좋은 훈련이 된다.
    - 새로운 기술을 공부하는 과정이 즐거워진다.
        - 개발한 코드가 동작하는 것을 봤을 때의 그 짜릿함을 학습 과정에서도 느낄 수 있으니 얼마나 좋겠는가! → 저자는 확실히 개발자다.
- 버그 테스트
    - 오류를 드러내기 위한 테스트
    - 일단 실패하도록 만들어야 한다.
    - 성공할 수 있도록 코드를 수정한다.
    - 테스트의 완성도를 높여준다.
        - 미처 검증하지 못했던 부분을 보완해준다.
        - 에러 추적이 용이해진다.
    - 버그의 내용을 명확하게 분석하게 해준다.
    - 기술적인 문제를 해결하는 데 도움이 된다.
- 동등분할
    - 결과가 true, false, 예외 발생이라면 세 가지 모두에 대한 테스트 생성
- 경계값 분석
    - 최소값, 최대값 분석
    - ~~코테 기본 소양~~
    

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7f8945cc-fa99-4fa3-a059-5821bb5f91c9/9b384140-5066-4b78-915d-6edc4da0cdb7/Untitled.png)

- 최종 정리