# 3주차

테스트

내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업

단위 테스트

작은 단위의 코드에 대해 테스트를 수행한 것

단위 : 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위

db의 상태가 매번 달라지고, 테스트를 위해 db를 특정 상태로 만들어줄 수 없다면 → 단위 테스트로서 가치가 없어짐

하는 이유 : 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서

빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드 → 자동화된 테스트 → 과감한 수정 이후에도 전체적인 동작 여부에 안심할 수 있음

Junit 프레임워크의 조건

1. public
2. @Test

단위 테스트 : 항상 일관성 있는 결과가 보장돼야 한다.

Junit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어가는 것을 허용한다.

- @Test가 붙어 있고
- public 접근자가 붙어 있으며
- 리턴 값이 void형이고
- 파라미터가 없다는 조건을 지키기만 하면 된다.

Junit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다.

@Test(expected= exception.class)

→ 테스트 중에 발생할 것으로 기대하는 예외 클래스를 지정해준다.

테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

@Before

Junit이 제공하는 애노테이션, @Test 메소드가 실행되기 전에 먼저 실행돼야 하는 메소드를 정의한다.

Junit의 테스트 수행 방식

1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는 이유

- 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해

픽스처

- 테스트를 수행하는 데 필요한 정보나 오브젝트