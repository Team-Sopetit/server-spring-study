# 1주차

**1.1**

스프링 → 자바 → 객체지향 프로그래밍

스프링 → 오브젝트 

코드 기능 검증 → 오브젝트 스스로 자신을 검증하도록 만들어주는 것 → main()

**1.2**

객체 설계 → 미래의 변화를 어떻게 대비해야할지 염두해야 함.

객체지향 프로그래밍 → 초기에 좀 더 많은, 번거로운 작업 요구

→ 변화에 효과적으로 대처 가능

관심사의 분리

→ 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 함

→ 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리

1. 중복된 코드 분리
    1. 메소드로 중복된 코드를 뽑아내는 것 → 메소드 추출
2. 상속을 통한 코드 분리
    1. 슈퍼클래스에 기본적인 로직의 흐름 생성, 기능 일부를 서브클래스에서 오버라이딩
        
        → 템플릿 메소드 패턴
        
    2. 서브 클래스에서 구체적인 오브젝트 생성 방법 결정 
        
        → 팩토리 메소드 패턴
        
    
    상속 문제점
    
    1. 상속을 이미 받고있다면? (1개까지만 됨)
    2. 상속은 여전히 관계가 긴밀함
3. 클래스 분리

# 2주차

스프링의 핵심

- 빈 팩토리 또는 애플리케이션 컨텍스트

스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트 → 빈

스프링 컨테이너가 생성과 관계 설정, 사용 등을 제어해주는 IoC가 적용된 오브젝트 → 스프링 빈

빈의 생성과 관계 설정 같은 제어를 담당하는 IoC 오브젝트 → 빈 팩토리

→ 근데 이거보다는 애플리케이션 컨텍스트를 주로 사용

→ 애플리케이션 컨텍스트가 빈 팩토리의 일종이라 그냥 동일하다고 생각

애플리케이션 컨텍스트

- 별도로 설정정보를 담고 있는 무엇인가를 가져와 이를 활용해야 함.
    - ex. DaoFactory에서 DconnectionMaker를 생성

방법

- 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스에 @Configuration을 붙여줌

→ DaoFactory에 @Configuration을 붙여줌

- 오브젝트를 만들어주는 메소드에 @Bean을 붙여줌

→ userDao() 메소드에 @Bean을 붙여줌

→ connectionMaker()에도 붙여줌

```java
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
UserDao dao = context.getBean("userDao", UserDao.class);
```

- 이렇게 불러올 수 있음
- 근데 이렇게 할거면 그냥 하는 거랑 뭐가 다른거임?
- 스프링은 더 다양한 기능과 활용 방법을 제공해줌

DaoFactory

- UserDao를 비롯한 DAO 오브젝트를 생성하고 DB 생성 오브젝트와 관계를 맺어주는 **제한적인 역할**을 수행

ApplicationContext

- 애플리케이션에서 IoC를 적용해서 **관리할 모든 오브젝트에 대한 생성과 관계설정을 담당**
- 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻어야 함 (@Bean)

ApplicationContext의 진행방식

- 클라이언트가 getBean()으로 요청할 때 내부적으로 호출한 userDao() 메소드의 오브젝트를 전달해줌.

ApplicationContext > DaoFactory?

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
    - 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 사용해야하는지 알아야 함
    - 필요할 때마다 팩토리 클래스를 생성해야하는 번거로움 발생
    - **오브젝트 팩토리가 아무리 많아져도 이를 알아야 하거나 직접 사용할 필요가 없다.**
    - 일관된 방식으로 원하는 오브젝트를 가져올 수 있다.
- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
    - 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.
    - 어떤 기능?
        
        오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 이에 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 
        
- 애플리케이션 컨텍스틑 빈을 검색하는 다양한 방법을 제공한다.
    - getBean() → 빈의 이름을 이용
    - 타입으로도 검색 가능

스프링 IoC 용어 정리

- 빈
    - 스프링이 IoC 방식으로 관리하는 오브젝트
    - **스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부름**
- 빈 팩토리
    - 스프링의 IoC를 담당하는 핵심 컨테이너
    - 빈을 등록, 생성, 조회, 반환 및 관리하는 기능 담당
    - getBean()과 같은 메소드가 BeanFactory라고 하는 인터페이스에 정의되어있음
- 애플리케이션 컨텍스트
    - 빈 팩토리를 확장한 IoC 컨테이너
    - BeanFactory를 상속함
- 설정정보 / 설정 메타정보
    - IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용
- 컨테이너 또는 IoC 컨테이너
    - 애플리케이션 콘텍스트 ↔ 컨테이너, 빈 팩토리 ↔ IoC 컨테이너라 생각
- 스프링 프레임워크
    - 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용
    

## 1.6

동일

- 같은 오브젝트이다.

동등

- 다른 오브젝트인데 같은 값을 가지고 있다.

DaoFactory에서 userDao() 메소드를 여러번 호출

→ 전부 다른 객체가 호출

ApplicationContext에서 getBean() 메소드 여러번 호출

→ 모두 같은 객체가 호출

→ 어째서 매 번 userDao() 메소드를 호출하고, 매번 new에 의해 새로운 UserDao가 만들어지지 않을까??

- 애플리케이션 컨텍스트는 **싱글톤을 저장하고 관리하는 싱글톤 레지스트리**이다.
- 스프링은 싱글톤으로 빈을 만든다.
    - 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이다.
    - 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 사용한다.
    - 서비스 오브젝트 → 매번 클라이언트의 요청이 올 때마다 오브젝트를 새로 만들어서 제공하면 부하가 생기므로 싱글톤 전략 사용

- 싱글톤은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이기 때문에 사용에 주의를 해야 함.

자바에서 싱글톤을 구현하는 방법

- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
- 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다. 만들어진 오브젝트는 스태틱 필드에 저장된다.
- getInstance()가 이후에 호출된다면 저장해둔 오브젝트를 넘겨준다.

```java
public class UserDao {

	private static UserDao INSTANCE;
	...

	private UserDao(ConnectionMaker connectionMaker) {
		this.connectionMaker = connectionMaker;
	}

	public static synchronized UserDao getInstance() {
		if (INSTANCE == null) INSTANCE = new UserDao(???);
		return INSTANCE;
	}
} 
```

- 싱글톤 패턴을 도입한 UserDao
- private 생성자 → DaoFactory에서 UserDao를 생성할 수 없게 됨.

싱글톤 패턴 구현 방식에 대한 문제점

- private 생성자를 갖고 있기 때무에 상속할 수 없다.
    - 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없음
- 싱글톤은 테스트하기가 힘들다.
- 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
- 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
    - 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.

→ 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 존재한다.

- 싱글톤 레지스트리
    - 스프링이 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능
    - 평범한 자바 클래스를 싱글톤으로 활용하게 해줌 (제어권을 넘겨줌으로서)
    - public 생성자를 가질 수 있기 때문에 생성자 파라미터를 이용해서 사용할 오브젝트를 넣어줄 수 있다.
    - 테스트도 수행 가능하다.
    - 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다.

주의해야할 점

- 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 한다.
    - 여러 요청을 한꺼번에 처리하는 과정에서 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있음.
    - 읽기 전용이면 괜찮 ㅋ
    - 파라미터로 로컬 변수, 리턴 값 등을 이용하면 여러 요청을 처리할 수 있음.
    

```java
public class UserDao {
	// 읽기 전용이라 얘는 괜찮
	// @Bean을 통해 만들어서 싱글톤이 보장됨
	// 단순한 읽기 전용이니 final 추가해주면 더 좋
	private ConnectionMaker connectionMaker;   

	private Connection c;
	private User user;

	public User get(String id) {
		this.c = connectionMaker.makeConnection();
		...
		this.user = new User();
		...
		return this.user;
	}
}
```

- 기존에 만들었던 UserDao와 다른 점
    - Connection c와 User user가 인스턴스 필드로 선언됨.
    - 멀티스레드 환경에서 사용하면 값이 뒤죽박죽이되는 심각한 상황 발생
    - 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나 파라미터로 주고받아야 함.
    
- 스프링 빈의 스코프
    - 싱글톤 스코프를 가짐.
    - 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지됨.
    

## 1.7

DI (의존성 주입)

- 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것
- 의존관게에는 방향성이 있다.
    - A → B
        - B의 변화가 A에 영향을 끼친다.
        - A의 변화가 B에 영향을 끼치지는 않는다.
- 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다. → 결합도가 낮다.

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

- 설계 시점에서는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는 것이다.
- 제 3의 존재는 바로 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트
- DaoFactory, 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 제 3의 존재

```java
public UserDao() {
	connectionMaker = new DConnectionMaker();
}
```

- 런타임 시의 의존관계가 코드 속에 다 미리 결정되어 있다.
- DaoFactory를 통해 DI 이용
    - 두 오브젝트 사이의 런타임 의존관계를 설정해주는 의존관계 주입 작업을 주도하는 존재
    - IoC 방식으로 오브젝트의 생성과 초기화, 제공 등의 작업을 수행하는 컨테이너
    - DI 컨테이너

- 오브젝트에 무엇인가를 넣어준다 == 메소드를 실행하면서 파라미터로 오브젝트의 레퍼런스를 전달해준다. → 생성자

의존관계 검색

- 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.

```java
public UserDao() {

	// 의존관계 검색 예시 1
	DaoFactory daoFactory = new DaoFactory();
	this.connectionMaker = daoFactory.connectionMaker();

	// 의존관계 검색 예시 2
	AnnotationConfigApplicationContext context = 
	new AnnotationConfigApplicationContext(DaoFactory.class);
	this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
}
```

- 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타남.
- 따라서 대개는 의존관계 주입 방식을 사용하는 편이 낫다.